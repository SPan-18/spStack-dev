[{"path":"https://span-18.github.io/spStack-dev/articles/spStack.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"spStack: Bayesian Geostatistics Using Predictive Stacking","text":"Geostatistics refers study spatially distributed variable interest, theory defined every point bounded study region interest. Statistical modelling analysis spatially oriented point-referenced outcomes play crucial role diverse scientific applications earth environmental sciences, ecology, epidemiology, economics. advent Markov chain Monte Carlo (MCMC) algorithms, Bayesian hierarchical models gained massive popularity analyzing point-referenced , geostatistical data. models involve latent spatial processes characterized spatial process parameters, besides lacking substantive relevance scientific contexts, also weakly identified hence, impedes convergence MCMC algorithms. Thus, even moderately large datasets (~10310^3 higher), computation MCMC becomes onerous practical use. introduce R package spStack implements Bayesian inference class geostatistical models, obviate issues mentioned sampling analytically available posterior distributions conditional upon candidate values spatial process parameters , subsequently assimilate inference individual posterior distributions using Bayesian predictive stacking. Besides delivering competitive predictive performance compared fully Bayesian inference using MCMC, proposed algorithm embarrassingly parallel, thus drastically improves runtime elevating utility package diverse group practitioners limited computational resources disposal. package, best knowledge, first implement stacking Bayesian analysis spatial data. Technical details surrounding methodology can found articles Zhang, Tang, Banerjee (2024) discuss case distribution point-referenced outcomes Gaussian, , Pan et al. (2024) case non-Gaussian outcomes explored. code package written primarily C/C++ additional calls FORTRAN routines optimized linear algebra operations. leverage F77_NAME macro interface legacy FORTRAN functions conjunction efficient matrix computation libraries BLAS (Basic Linear Algebra Subprograms) LAPACK (Linear Algebra Package) implement stacking algorithm. remainder vignette evolves follows - next two sections discuss Bayesian hierarchical spatial models Gaussian non-Gaussian outcomes, followed section providing brief details predictive stacking section dedicated illustration functions package.","code":""},{"path":"https://span-18.github.io/spStack-dev/articles/spStack.html","id":"bayesian-gaussian-spatial-regression-models","dir":"Articles","previous_headings":"","what":"Bayesian Gaussian spatial regression models","title":"spStack: Bayesian Geostatistics Using Predictive Stacking","text":"Let χ={s1,…,sn}∈𝒟\\chi = \\{s_1, \\ldots, s_n\\} \\\\mathcal{D} set nn spatial locations yielding measurements y=(y1,…,yn)⊤y = (y_1, \\ldots, y_n)^{ \\scriptstyle \\top } known values predictors locations collected n×pn \\times p full rank matrix X=[x(s1),…,x(sn)]⊤X = [x(s_1), \\ldots, x(s_n)]^{ \\scriptstyle \\top }. customary geostatistical model yi=x(si)⊤β+z(si)+ϵi,=1,…,n,\\begin{equation}   y_i = x(s_i)^{ \\scriptstyle \\top }\\beta + z(s_i) + \\epsilon_i, \\quad = 1, \\ldots, n, \\end{equation} β\\beta p×1p \\times 1 vector slopes, z(s)∼GP(0,R(⋅,⋅;θsp))z(s) \\sim \\mathrm{GP}(0, R(\\cdot, \\cdot; {\\theta_{\\text{sp}}})) zero-centered spatial Gaussian process 𝒟\\mathcal{D} spatial correlation function R(⋅,⋅;θsp)R(\\cdot, \\cdot; {\\theta_{\\text{sp}}}) characterized process parameters θsp{\\theta_{\\text{sp}}}, σ2\\sigma^2 spatial variance parameter (“partial sill”) ϵi∼𝒩(0,τ2),=1,…,n\\epsilon_i \\sim \\mathcal{N}(0, \\tau^2), = 1, \\ldots, n ..d. variance τ2\\tau^2 (“nugget”) capturing measurement error. spatial process z(⋅)z(\\cdot) assumed independent measurement errors {ϵi,=1,…,n}\\{\\epsilon_i, = 1, \\ldots, n\\}. Let z=(z(s1),…,z(sn))⊤z = (z(s_1), \\ldots, z(s_n))^{ \\scriptstyle \\top } denotes realization spatial process χ\\chi n×nn \\times n correlation matrix R(χ;θsp)=(R(si,sjθsp))1≤,j≤nR(\\chi; {\\theta_{\\text{sp}}}) = (R(s_i, s_j {\\theta_{\\text{sp}}}))_{1 \\leq ,j \\leq n}. build conjugate Bayesian hierarchical spatial model, y∣z,β,σ2∼N(Xβ+z,δ2σ2In),z∣σ2∼N(0,σ2R(χ;θsp)),β∣σ2∼N(μβ,σ2Vβ),σ2∼IG(aσ,bσ),\\begin{equation} \\begin{split} y \\mid z, \\beta, \\sigma^2 &\\sim N(X\\beta + z, \\delta^2 \\sigma^2 I_n), \\\\ z \\mid \\sigma^2 &\\sim N(0, \\sigma^2 R(\\chi; {\\theta_{\\text{sp}}})), \\\\ \\beta \\mid \\sigma^2 &\\sim N(\\mu_\\beta, \\sigma^2 V_\\beta), \\quad \\sigma^2 \\sim \\mathrm{IG}(a_\\sigma, b_\\sigma), \\end{split} \\end{equation} fix noise--spatial variance ratio δ2=τ2/σ2\\delta^2 = \\tau^2 / \\sigma^2, process parameters θsp{\\theta_{\\text{sp}}} hyperparameters μβ\\mu_\\beta, VβV_\\beta, aσa_\\sigma bσb_\\sigma. package, use Matern covariogram specified spatial decay parameter ϕ\\phi smoothness parameter ν\\nu .e., θsp={ϕ,ν}{\\theta_{\\text{sp}}}= \\{\\phi, \\nu\\}, given R(s,s′;θsp)=(ϕ|s−s′|)ν2ν−1Γ(ν)Kν(ϕ|s−s′|)).\\begin{equation} R(s, s'; {\\theta_{\\text{sp}}}) = \\frac{(\\phi \\lvert s - s' \\rvert)^\\nu}{2^{\\nu - 1} \\Gamma(\\nu)} K_\\nu (\\phi \\lvert s - s' \\rvert)). \\end{equation} utilize composition sampling strategy sample model parameters joint posterior distribution can written p(σ2,β,z∣y)=p(σ2∣y)×p(β∣σ2,y)×p(z∣β,σ2,y).\\begin{equation} p(\\sigma^2, \\beta, z \\mid y) = p(\\sigma^2 \\mid y) \\times p(\\beta \\mid \\sigma^2, y) \\times p(z \\mid \\beta, \\sigma^2, y). \\end{equation} proceed first sampling σ2\\sigma^2 marginal posterior, given samples σ2\\sigma^2, sample β\\beta subsequently, sample zz conditioned posterior samples β\\beta σ2\\sigma^2(Banerjee 2020). function spLMexact() delivers samples posterior distribution. details can found Zhang, Tang, Banerjee (2024).","code":""},{"path":"https://span-18.github.io/spStack-dev/articles/spStack.html","id":"bayesian-non-gaussian-spatial-regression-models","dir":"Articles","previous_headings":"","what":"Bayesian non-Gaussian spatial regression models","title":"spStack: Bayesian Geostatistics Using Predictive Stacking","text":"Analyzing non-Gaussian spatial data typically requires introducing spatial dependence generalized linear models link function exponential family distribution. Let y(s)y(s) outcome location s∈𝒟s \\\\mathcal{D} endowed probability law natural exponential family, denote y(s)∼EF(x(s)⊤β+z(s);b,ψy)\\begin{equation}     y(s) \\sim \\mathrm{EF}(x(s)^{ \\scriptstyle \\top }\\beta  + z(s); b, \\psi_y) \\end{equation} positive parameter b>0b > 0 unit log partition function ψy\\psi_y. Fixed effects regression spatial dependence, e.g., x(s)⊤β+z(s)x(s)^{{ \\scriptstyle \\top }}\\beta + z(s), introduced natural parameter, x(s)x(s) p×1p \\times 1 vector predictors referenced respect ss, β\\beta p×1p \\times 1 vector slopes measuring trend, z(s)z(s) zero-centered spatial process 𝒟\\mathcal{D} specified scale parameter σz\\sigma_z spatial correlation function R(⋅,⋅;θsp)R(\\cdot, \\cdot ; {\\theta_{\\text{sp}}}) θsp{\\theta_{\\text{sp}}} consisting spatial-temporal decay smoothness parameters. Unlike Gaussian likelihoods, inference considerably encumbered inability analytically integrate random effects reduce dimension parameter space. Iterative algorithms Markov Chain Monte Carlo (MCMC), thus attempt sample high-dimensional posterior distribution, convergence often hampered high auto-correlations weakly identified spatial process parameters θsp{\\theta_{\\text{sp}}}. consider following three cases - Point-referenced Poisson count data: b=1b = 1 ψy(t)=et\\psi_y(t) = e^t. y(si)∼Poisson(λ(si)),=1,…,n.λ(si)=exp(x(si)⊤β+z(si))\\begin{equation} \\begin{split} y(s_i) &\\sim \\mathrm{Poisson}(\\lambda(s_i)), \\quad = 1, \\dots, n.\\\\ \\lambda(s_i) & = \\exp(x(s_i)^{ \\scriptstyle \\top }\\beta + z(s_i)) \\end{split} \\end{equation} Point-referenced binomial count data: b=m(si)b = m(s_i) ii ψy(t)=log(1+et)\\psi_y(t) = \\log(1 + e^t). y(si)∼Binomial(m(si),π(si)),=1,…,n.π(si)=ilogit(x(si)⊤β+z(si))\\begin{equation} \\begin{split} y(s_i) &\\sim \\mathrm{Binomial}(m(s_i), \\pi(s_i)), \\quad = 1, \\dots, n.\\\\ \\pi(s_i) & = \\mathrm{ilogit}(x(s_i)^{ \\scriptstyle \\top }\\beta + z(s_i)) \\end{split} \\end{equation} Point-referenced binary data: b=1b = 1 ψy(t)=log(1+et)\\psi_y(t) = \\log(1 + e^t). y(si)∼Bernoulli(π(si)),=1,…,n.π(si)=ilogit(x(si)⊤β+z(si))\\begin{equation} \\begin{split} y(s_i) &\\sim \\mathrm{Bernoulli}(\\pi(s_i)), \\quad = 1, \\dots, n.\\\\ \\pi(s_i) & = \\mathrm{ilogit}(x(s_i)^{ \\scriptstyle \\top }\\beta + z(s_i)) \\end{split} \\end{equation} Following Bradley Clinch (2024), introduce Bayesian hierarchical spatial model y(si)∣β,z,ξ∼EF(x(si)⊤β+z(si)+ξi−μi;bi,ψy),=1,…,nβ∣σβ2∼N(0,σβ2Vβ),σβ2∼IG(νβ/2,νβ/2)z∣σz2∼N(0,σz2R(χ;θsp)),σz2∼IG(νz/2,νz/2),ξ∣β,z,σξ2,αϵ∼GCMc(μ̃ξ,Hξ,ϵ,κξ;ψξ),\\begin{equation} \\begin{split} y(s_i) \\mid \\beta, z, \\xi & \\sim \\mathrm{EF}\\left(x(s_i)^{ \\scriptstyle \\top }\\beta + z(s_i) + \\xi_i - \\mu_i; b_i, \\psi_y\\right), = 1, \\ldots, n\\\\ \\beta \\mid \\sigma^2_\\beta &\\sim N(0, \\sigma^2_\\beta V_\\beta), \\quad \\sigma^2_\\beta \\sim \\mathrm{IG}(\\nu_\\beta/2, \\nu_\\beta/2)\\\\ z \\mid \\sigma^2_z &\\sim N\\left(0, \\sigma^2_z R(\\chi; {\\theta_{\\text{sp}}})\\right), \\quad \\sigma^2_z \\sim \\mathrm{IG}(\\nu_z/2, \\nu_z/2),\\\\ \\xi \\mid \\beta, z, \\sigma^2_\\xi, \\alpha_\\epsilon &\\sim \\mathrm{GCM_c}\\left(\\tilde{\\mu}_\\xi, H_\\xi, \\epsilon, \\kappa_\\xi; \\psi_\\xi\\right), \\end{split} \\end{equation} μ=(μ1,…,μn)⊤\\mu = (\\mu_1, \\ldots, \\mu_n)^{ \\scriptstyle \\top } denotes discrepancy parameter. fix spatial process parameters θsp{\\theta_{\\text{sp}}}, boundary adjustment parameter ϵ\\epsilon hyperparameters VβV_\\beta, νβ\\nu_\\beta, νz\\nu_z σξ2\\sigma^2_\\xi. term ξ\\xi known fine-scale variation term given conditional generalized conjugate multivariate distribution (GCMc\\mathrm{GCM_c}) prior. details, see Pan et al. (2024).","code":""},{"path":"https://span-18.github.io/spStack-dev/articles/spStack.html","id":"predictive-stacking","dir":"Articles","previous_headings":"","what":"Predictive stacking","title":"spStack: Bayesian Geostatistics Using Predictive Stacking","text":"Following Yao et al. (2018), consider set candidate models based grid values parameters {θsp,δ2}\\{ {\\theta_{\\text{sp}}}, \\delta^2 \\} Gaussian case, {θsp,ϵ}\\{ {\\theta_{\\text{sp}}}, \\epsilon \\} non-Gaussian case, supplied user. build set candidate models based Cartesian product collection values individual parameter ℳ={M1,…,MG}\\mathcal{M} = \\{M_1, \\ldots, M_G\\}. , g=1,…,Gg = 1, \\ldots, G, sample posterior distribution p(σ2,β,z∣y,Mg)p(\\sigma^2, \\beta, z \\mid y, M_g) model MgM_g find leave-one-predictive densities p(yi∣y−,Mg)p(y_i \\mid y_{-}, M_g). solve optimization problem maxw1,…,wG1n∑=1nlog∑g=1Gwgp(yi∣y−,Mg)subject towg≥0,∑g=1Gwg=1\\begin{equation} \\begin{split}  \\max_{w_1, \\ldots, w_G}& \\, \\frac{1}{n} \\sum_{= 1}^n \\log \\sum_{g = 1}^G  w_g p(y_i \\mid y_{-}, M_g) \\\\  \\text{subject } & \\quad w_g \\geq 0, \\sum_{g = 1}^G w_g = 1 \\end{split} \\end{equation} find optimal stacking weights ŵ1,…,ŵG\\hat{w}_1, \\ldots, \\hat{w}_G. obtaining optimal stacking weights, posterior inference quantity interest subsequently proceed stacked posterior, p̃(⋅∣y)=∑g=1Gŵgp(⋅∣y,Mg).\\begin{equation} \\tilde{p}(\\cdot \\mid y) = \\sum_{g = 1}^G \\hat{w}_g p(\\cdot \\mid y, M_g). \\end{equation}","code":""},{"path":"https://span-18.github.io/spStack-dev/articles/spStack.html","id":"illustrations","dir":"Articles","previous_headings":"","what":"Illustrations","title":"spStack: Bayesian Geostatistics Using Predictive Stacking","text":"section, thoroughly illustrate method synthetic Gaussian well non-Gaussian spatial data provide code analyze output functions. start loading package. synthetic spatial data lazy-loaded includes synthetic spatial Gaussian data simGaussian, Poisson data simPoisson, binomial data simBinom binary data simBinary. One can use function sim_spData() simulate spatial data. applying functions datasets.","code":"library(spStack)"},{"path":"https://span-18.github.io/spStack-dev/articles/spStack.html","id":"analysis-of-spatial-gaussian-data","dir":"Articles","previous_headings":"Illustrations","what":"Analysis of spatial Gaussian data","title":"spStack: Bayesian Geostatistics Using Predictive Stacking","text":"first load data simGaussian set priors. Supplying priors optional. See documentation spLMexact() learn default priors. Besides, setting priors, also fix values spatial process parameters noise--spatial variance ratio. pass parameters main function. Next, can summarize posterior samples fixed effects follows. interested finding leave-one-predictive densities (LOO-PD) model, set loopd TRUE provide loopd.method. Valid inputs loopd.method \"exact\" \"PSIS\" finds exact LOO-PD using closed form expressions approximate LOO-PD using Pareto smoothed importance sampling (Vehtari, Gelman, Gabry 2017). curiosity, compare LOO-PD obtained two methods.  Next, move Bayesian spatial stacking algorithm Gaussian data. supply prior list provide candidate values spatial process parameters noise--spatial variance ratio. user can check solver status runtime issuing following. sample stacked posterior, package provides helper function called stackedSampler(). Subsequent inference proceeds samples obtained stacked posterior. collect samples fixed effects summarize follows. , compare posterior samples spatial random effects corresponding true values.  package also provides functions plot interpolated spatial surfaces order visualization purposes. function surfaceplot() creates single spatial surface plot, surfaceplot2() creates two side--side surface plots. using later visually inspect interpolated spatial surfaces true spatial effects posterior medians.","code":"data(\"simGaussian\") dat <- simGaussian[1:200, ] # work with first 200 rows  muBeta <- c(0, 0) VBeta <- cbind(c(10.0, 0.0), c(0.0, 10.0)) sigmaSqIGa <- 2 sigmaSqIGb <- 2 phi0 <- 2 nu0 <- 0.5 noise_sp_ratio <- 0.8 prior_list <- list(beta.norm = list(muBeta, VBeta),                    sigma.sq.ig = c(sigmaSqIGa, sigmaSqIGb)) nSamples <- 2000 set.seed(1729) mod1 <- spLMexact(y ~ x1, data = dat,                   coords = as.matrix(dat[, c(\"s1\", \"s2\")]),                   cor.fn = \"matern\",                   priors = prior_list,                   spParams = list(phi = phi0, nu = nu0),                   noise_sp_ratio = noise_sp_ratio, n.samples = nSamples,                   loopd = TRUE, loopd.method = \"exact\",                   verbose = TRUE) #> ---------------------------------------- #>  Model description #> ---------------------------------------- #> Model fit with 200 observations. #>  #> Number of covariates 2 (including intercept). #>  #> Using the matern spatial correlation function. #>  #> Priors: #>  beta: Gaussian #>  mu: 0.00    0.00     #>  cov: #>  10.00   0.00     #>  0.00    10.00    #>  #>  sigma.sq: Inverse-Gamma #>  shape = 2.00, scale = 2.00. #>  #> Spatial process parameters: #>  phi = 2.00, and, nu = 0.50. #> Noise-to-spatial variance ratio = 0.80. #>  #> Number of posterior samples = 2000. #>  #> LOO-PD calculation method = exact. #> ---------------------------------------- post_beta <- mod1$samples$beta summary_beta <- t(apply(post_beta, 1, function(x) quantile(x, c(0.025, 0.5, 0.975)))) rownames(summary_beta) <- mod1$X.names print(summary_beta) #>                 2.5%      50%    97.5% #> (Intercept) 1.388249 2.129140 2.932428 #> x1          4.865843 4.954446 5.045627 mod2 <- spLMexact(y ~ x1, data = dat,                   coords = as.matrix(dat[, c(\"s1\", \"s2\")]),                   cor.fn = \"matern\",                   priors = prior_list,                   spParams = list(phi = phi0, nu = nu0),                   noise_sp_ratio = noise_sp_ratio, n.samples = nSamples,                   loopd = TRUE, loopd.method = \"PSIS\",                   verbose = FALSE) loopd_exact <- mod1$loopd loopd_psis <- mod2$loopd loopd_df <- data.frame(exact = loopd_exact, psis = loopd_psis)  library(ggplot2) plot1 <- ggplot(data = loopd_df, aes(x = exact)) +   geom_point(aes(y = psis), size = 1, alpha = 0.5) +   geom_abline(slope = 1, intercept = 0, color = \"red\", alpha = 0.5) +   xlab(\"Exact\") + ylab(\"PSIS\") + theme_bw() +   theme(panel.background = element_blank(), aspect.ratio = 1) plot1 mod3 <- spLMstack(y ~ x1, data = dat,                   coords = as.matrix(dat[, c(\"s1\", \"s2\")]),                   cor.fn = \"matern\",                   priors = prior_list,                   params.list = list(phi = c(1.5, 3, 5),                                      nu = c(0.5, 1, 1.5),                                      noise_sp_ratio = c(0.5, 1.5)),                   n.samples = 1000, loopd.method = \"exact\",                   parallel = FALSE, solver = \"ECOS\", verbose = TRUE) #>  #> STACKING WEIGHTS: #>  #>            | phi | nu  | noise_sp_ratio | weight | #> +----------+-----+-----+----------------+--------+ #> | Model 1  |  1.5|  0.5|             0.5| 0.000  | #> | Model 2  |  3.0|  0.5|             0.5| 0.000  | #> | Model 3  |  5.0|  0.5|             0.5| 0.000  | #> | Model 4  |  1.5|  1.0|             0.5| 0.226  | #> | Model 5  |  3.0|  1.0|             0.5| 0.000  | #> | Model 6  |  5.0|  1.0|             0.5| 0.774  | #> | Model 7  |  1.5|  1.5|             0.5| 0.000  | #> | Model 8  |  3.0|  1.5|             0.5| 0.000  | #> | Model 9  |  5.0|  1.5|             0.5| 0.000  | #> | Model 10 |  1.5|  0.5|             1.5| 0.000  | #> | Model 11 |  3.0|  0.5|             1.5| 0.000  | #> | Model 12 |  5.0|  0.5|             1.5| 0.000  | #> | Model 13 |  1.5|  1.0|             1.5| 0.000  | #> | Model 14 |  3.0|  1.0|             1.5| 0.000  | #> | Model 15 |  5.0|  1.0|             1.5| 0.000  | #> | Model 16 |  1.5|  1.5|             1.5| 0.000  | #> | Model 17 |  3.0|  1.5|             1.5| 0.000  | #> | Model 18 |  5.0|  1.5|             1.5| 0.000  | #> +----------+-----+-----+----------------+--------+ print(mod3$solver.status) #> [1] \"optimal\" print(mod3$run.time) #>    user  system elapsed  #>   2.501   2.896   1.678 post_samps <- stackedSampler(mod3) post_beta <- post_samps$beta summary_beta <- t(apply(post_beta, 1, function(x) quantile(x, c(0.025, 0.5, 0.975)))) rownames(summary_beta) <- mod3$X.names print(summary_beta) #>                  2.5%      50%    97.5% #> (Intercept) 0.9303819 2.185930 2.949784 #> x1          4.8678581 4.954272 5.030520 post_z <- post_samps$z post_z_summ <- t(apply(post_z, 1, function(x) quantile(x, c(0.025, 0.5, 0.975)))) z_combn <- data.frame(z = dat$z_true, zL = post_z_summ[, 1],                       zM = post_z_summ[, 2], zU = post_z_summ[, 3])  plotz <- ggplot(data = z_combn, aes(x = z)) +   geom_point(aes(y = zM), size = 0.75, color = \"darkblue\", alpha = 0.5) +   geom_errorbar(aes(ymin = zL, ymax = zU), width = 0.05, alpha = 0.15,                  color = \"skyblue\") +    geom_abline(slope = 1, intercept = 0, color = \"red\") +   xlab(\"True z\") + ylab(\"Stacked posterior of z\") + theme_bw() +   theme(panel.background = element_blank(), aspect.ratio = 1) plotz postmedian_z <- apply(post_z, 1, median) dat$z_hat <- postmedian_z plot_z <- surfaceplot2(dat, coords_name = c(\"s1\", \"s2\"),                        var1_name = \"z_true\", var2_name = \"z_hat\") library(ggpubr) ggarrange(plotlist = plot_z, common.legend = TRUE, legend = \"right\")"},{"path":"https://span-18.github.io/spStack-dev/articles/spStack.html","id":"analysis-of-spatial-non-gaussian-data","dir":"Articles","previous_headings":"Illustrations","what":"Analysis of spatial non-Gaussian data","title":"spStack: Bayesian Geostatistics Using Predictive Stacking","text":"package, offer functions Bayesian analysis Poisson binomial count data well binary data.","code":""},{"path":"https://span-18.github.io/spStack-dev/articles/spStack.html","id":"spatial-poisson-count-data","dir":"Articles","previous_headings":"Illustrations > Analysis of spatial non-Gaussian data","what":"Spatial Poisson count data","title":"spStack: Bayesian Geostatistics Using Predictive Stacking","text":"first load plot point-referenced Poisson count data.  Next, demonstrate function spGLMexact() delivers posterior samples fixed effects spatial random effects. option family must specified correctly using function. instance, example family = \"poisson\". provide fixed values spatial process parameters boundary adjustment parameter, given argument boundary, supplied, defaults 0.5. details priors default value, see function documentation. next collect samples fixed effects summarize . true value fixed effects data simulated β=(2,−0.5)\\beta = (2, -0.5) (details, see documentation data simPoisson). Next, move function spGLMstack() implement proposed stacking algorithm. argument loopd.controls used provide details algorithm used find LOO-PD. Valid options tag method \"exact\" \"CV\". use KK-fold cross-validation assigning method = \"CV\"CV.K = 10. tag nMC decides number Monte Carlo samples used find LOO-PD. can extract information solver status runtime following. first obtain final posterior samples sampling stacked sampler. Subsequently, summarize posterior samples fixed effects. Finally, analyze posterior samples spatial random effects.  can also compare interpolated spatial surfaces true spatial effects posterior median.","code":"data(\"simPoisson\") dat <- simPoisson[1:200, ] # work with first 200 observations  ggplot(dat, aes(x = s1, y = s2)) +   geom_point(aes(color = y), alpha = 0.75) +   scale_color_distiller(palette = \"RdYlGn\", direction = -1,                          label = function(x) sprintf(\"%.0f\", x)) +   guides(alpha = 'none') + theme_bw() +   theme(axis.ticks = element_line(linewidth = 0.25),         panel.background = element_blank(), panel.grid = element_blank(),         legend.title = element_text(size = 10, hjust = 0.25),         legend.box.just = \"center\", aspect.ratio = 1) mod1 <- spGLMexact(y ~ x1, data = dat, family = \"poisson\",                    coords = as.matrix(dat[, c(\"s1\", \"s2\")]), cor.fn = \"matern\",                    spParams = list(phi = phi0, nu = nu0),                    boundary = 0.5,                    n.samples = 1000, verbose = TRUE) #> ---------------------------------------- #>  Model description #> ---------------------------------------- #> Model fit with 200 observations. #>  #> Family = poisson. #>  #> Number of covariates 2 (including intercept). #>  #> Using the matern spatial correlation function. #>  #> Priors: #>  beta: Gaussian #>  mu: 0.00    0.00     #>  cov: #>  100.00  0.00     #>  0.00    100.00   #>  #>  sigmaSq.beta ~ IG(nu.beta/2, nu.beta/2) #>  sigmaSq.z ~ IG(nu.z/2, nu.z/2) #>  nu.beta = 2.10, nu.z = 2.10. #>  sigmaSq.xi = 0.10. #>  Boundary adjustment parameter = 0.50. #>  #> Spatial process parameters: #>  phi = 2.00, and, nu = 0.50. #>  #> Number of posterior samples = 1000. #> ---------------------------------------- post_beta <- mod1$samples$beta summary_beta <- t(apply(post_beta, 1, function(x) quantile(x, c(0.025, 0.5, 0.975)))) rownames(summary_beta) <- mod1$X.names print(summary_beta) #>                   2.5%        50%      97.5% #> (Intercept) -0.1302807  1.9026041  4.3045317 #> x1          -0.6664152 -0.5545303 -0.4543145 mod2 <- spGLMstack(y ~ x1, data = dat, family = \"poisson\",                    coords = as.matrix(dat[, c(\"s1\", \"s2\")]), cor.fn = \"matern\",                    params.list = list(phi = c(3, 7, 10), nu = c(0.5, 1.5),                                       boundary = c(0.5, 0.6)),                    n.samples = 1000,                    loopd.controls = list(method = \"CV\", CV.K = 10, nMC = 1000),                    parallel = TRUE, solver = \"ECOS\", verbose = TRUE) #>  #> STACKING WEIGHTS: #>  #>            | phi | nu  | boundary | weight | #> +----------+-----+-----+----------+--------+ #> | Model 1  |    3|  0.5|       0.5| 0.000  | #> | Model 2  |    7|  0.5|       0.5| 0.000  | #> | Model 3  |   10|  0.5|       0.5| 0.000  | #> | Model 4  |    3|  1.5|       0.5| 0.000  | #> | Model 5  |    7|  1.5|       0.5| 0.000  | #> | Model 6  |   10|  1.5|       0.5| 0.000  | #> | Model 7  |    3|  0.5|       0.6| 0.000  | #> | Model 8  |    7|  0.5|       0.6| 0.000  | #> | Model 9  |   10|  0.5|       0.6| 0.000  | #> | Model 10 |    3|  1.5|       0.6| 0.175  | #> | Model 11 |    7|  1.5|       0.6| 0.825  | #> | Model 12 |   10|  1.5|       0.6| 0.000  | #> +----------+-----+-----+----------+--------+ print(mod2$solver.status) #> [1] \"optimal\" print(mod2$run.time) #>    user  system elapsed  #>  24.478  35.767  15.297 post_samps <- stackedSampler(mod2) post_beta <- post_samps$beta summary_beta <- t(apply(post_beta, 1, function(x) quantile(x, c(0.025, 0.5, 0.975)))) rownames(summary_beta) <- mod3$X.names print(summary_beta) #>                   2.5%        50%      97.5% #> (Intercept) -0.8032363  2.0460414  3.8253354 #> x1          -0.6275769 -0.5471968 -0.4529202 post_z <- post_samps$z post_z_summ <- t(apply(post_z, 1, function(x) quantile(x, c(0.025, 0.5, 0.975)))) z_combn <- data.frame(z = dat$z_true, zL = post_z_summ[, 1],                       zM = post_z_summ[, 2], zU = post_z_summ[, 3])  plotz <- ggplot(data = z_combn, aes(x = z)) +   geom_point(aes(y = zM), size = 0.75, color = \"darkblue\", alpha = 0.5) +   geom_errorbar(aes(ymin = zL, ymax = zU), width = 0.05, alpha = 0.15,                 color = \"skyblue\") +   geom_abline(slope = 1, intercept = 0, color = \"red\") +   xlab(\"True z\") + ylab(\"Stacked posterior of z\") + theme_bw() +   theme(panel.background = element_blank(), aspect.ratio = 1) plotz postmedian_z <- apply(post_z, 1, median) dat$z_hat <- postmedian_z plot_z <- surfaceplot2(dat, coords_name = c(\"s1\", \"s2\"),                        var1_name = \"z_true\", var2_name = \"z_hat\") library(ggpubr) ggarrange(plotlist = plot_z, common.legend = TRUE, legend = \"right\")"},{"path":"https://span-18.github.io/spStack-dev/articles/spStack.html","id":"spatial-binomial-count-data","dir":"Articles","previous_headings":"Illustrations > Analysis of spatial non-Gaussian data","what":"Spatial binomial count data","title":"spStack: Bayesian Geostatistics Using Predictive Stacking","text":", present spGLMexact() function brevity. argument change case spatial Poisson data structure formula defines model. Similarly, collect posterior samples fixed effects summarize . true value fixed effects data simulated β=(0.5,−0.5)\\beta = (0.5, -0.5).","code":"data(\"simBinom\") dat <- simBinom[1:200, ] # work with first 200 rows  mod1 <- spGLMexact(cbind(y, n_trials) ~ x1, data = dat, family = \"binomial\",                    coords = as.matrix(dat[, c(\"s1\", \"s2\")]), cor.fn = \"matern\",                    spParams = list(phi = 3, nu = 0.5),                    boundary = 0.5, n.samples = 1000, verbose = FALSE) post_beta <- mod1$samples$beta summary_beta <- t(apply(post_beta, 1, function(x) quantile(x, c(0.025, 0.5, 0.975)))) rownames(summary_beta) <- mod1$X.names print(summary_beta) #>                   2.5%        50%      97.5% #> (Intercept) -1.2039026  0.7229478  2.5872269 #> x1          -0.5815266 -0.4016808 -0.2365151"},{"path":"https://span-18.github.io/spStack-dev/articles/spStack.html","id":"spatial-binary-data","dir":"Articles","previous_headings":"Illustrations > Analysis of spatial non-Gaussian data","what":"Spatial binary data","title":"spStack: Bayesian Geostatistics Using Predictive Stacking","text":"Finally, present spGLMexact() function spatial binary data avoid repetition. case, unlike binomial model, almost nothing changes case spatial Poisson data. Similarly, collect posterior samples fixed effects summarize . true value fixed effects data simulated β=(0.5,−0.5)\\beta = (0.5, -0.5).","code":"data(\"simBinary\") dat <- simBinary[1:200, ]  mod1 <- spGLMexact(y ~ x1, data = dat, family = \"binary\",                    coords = as.matrix(dat[, c(\"s1\", \"s2\")]), cor.fn = \"matern\",                    spParams = list(phi = 4, nu = 0.4),                    boundary = 0.5, n.samples = 1000, verbose = FALSE) post_beta <- mod1$samples$beta summary_beta <- t(apply(post_beta, 1, function(x) quantile(x, c(0.025, 0.5, 0.975)))) rownames(summary_beta) <- mod1$X.names print(summary_beta) #>                   2.5%        50%      97.5% #> (Intercept) -1.1291296  0.3061828 1.70795510 #> x1          -0.6507851 -0.3088350 0.04471555"},{"path":"https://span-18.github.io/spStack-dev/articles/spStack.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"spStack: Bayesian Geostatistics Using Predictive Stacking","text":"devised demonstrated Bayesian predictive stacking effective tool estimating spatial regression models yielding robust predictions Gaussian well non-Gaussian spatial data. develop exploit analytically accessible distribution theory pertaining Bayesian analysis linear mixed model generalized linear mixed models enables us directly sample posterior distributions. focus package effectively combining inference across different closed-form posterior distributions circumventing inference weakly identified parameters. Future developments investigations consider zero-inflated non-Gaussian data adapting variants Gaussian process models scale inference massive datasets circumventing Cholesky decomposition dense covariance matrices.","code":""},{"path":[]},{"path":"https://span-18.github.io/spStack-dev/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Soumyakanti Pan. Author, maintainer. Sudipto Banerjee. Author.","code":""},{"path":"https://span-18.github.io/spStack-dev/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Pan S, Banerjee S (2024). spStack: Bayesian Geostatistics Using Predictive Stacking. R package version 1.0.1, https://span-18.github.io/spStack-dev/.","code":"@Manual{,   title = {spStack: Bayesian Geostatistics Using Predictive Stacking},   author = {Soumyakanti Pan and Sudipto Banerjee},   year = {2024},   note = {R package version 1.0.1},   url = {https://span-18.github.io/spStack-dev/}, }"},{"path":[]},{"path":"https://span-18.github.io/spStack-dev/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Bayesian Geostatistics Using Predictive Stacking","text":"spStack R package delivers Bayesian inference point-referenced spatial data assimilating posterior inference collection candidate models using stacking predictive densities. Currently, supports point-referenced Gaussian, Poisson, binomial binary outcomes. Users can supply candidate values spatial process parameters certain auxiliary model parameters, based collection models created. spStack utilizes Bayesian conjugate linear modelling framework Gaussian data generalized conjugate multivariate distribution theory non-Gaussian exponential family data. Learn vignette(\"spStack\"). Technical details methodology available Zhang, Tang, Banerjee 2024 Pan, Zhang, Bradley, , Banerjee 2024.","code":""},{"path":"https://span-18.github.io/spStack-dev/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Bayesian Geostatistics Using Predictive Stacking","text":"quick installation development version, run following command R. installing CRAN, use following.","code":"# Install development version from GitHub # install.packages(\"pak\") pak::pak(\"SPan-18/spStack-dev\") install.packages(\"spStack\")"},{"path":"https://span-18.github.io/spStack-dev/index.html","id":"installing-from-source","dir":"","previous_headings":"Installation","what":"Installing from source","title":"Bayesian Geostatistics Using Predictive Stacking","text":"install package source, download tarball spStack_X.X.XX.tar.gz file. setting working directory file location, either issue R CMD install spStack_X.X.XX.tar.gz terminal, run following command R install package. Note package written C++ calls FORTRAN routines hence contains Makevars file cross-platform portability. , important set correct path FORTRAN libraries well BLAS LAPACK computer. example, working MacOS, create file ~.R/Makevars set global configurations libraries link R. following example Makevars file. tells R use Accelerate framework, comes pre-installed Mac BLAS LAPACK functions. gfortran, simply run brew install gcc terminal install gcc compiler gfortran comes bundled gcc. gcc installed using Homebrew, path , otherwise path gfortran needs set correctly.","code":"install.packages(\"spStack_X.X.XX.tar.gz\", type = \"source\", repos = NULL) # Set Fortran library paths FLIBS = -L/opt/homebrew/opt/gcc/lib/gcc/14 -lgfortran -lquadmath -lm  # BLAS and LAPACK libraries (using Accelerate framework on macOS) BLAS_LIBS = -L/System/Library/Frameworks/Accelerate.framework/Versions/Current/ -framework Accelerate LAPACK_LIBS = -L/System/Library/Frameworks/Accelerate.framework/Versions/Current/ -framework Accelerate"},{"path":"https://span-18.github.io/spStack-dev/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Bayesian Geostatistics Using Predictive Stacking","text":"successfully installed, load library R. View vignette running vignette(\"spStack\") see example code implement predictive stacking different Bayesian hierarchical spatial models.","code":"library(spStack)"},{"path":"https://span-18.github.io/spStack-dev/index.html","id":"acknowledgement","dir":"","previous_headings":"","what":"Acknowledgement","title":"Bayesian Geostatistics Using Predictive Stacking","text":"graphics used logo obtained page Gaussian RF (Boris Kozintsev, 1999). represents realization isotropic Gaussian random field Matérn correlation function decay smoothness parameters 5 2, respectively.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/cholUpdate.html","id":null,"dir":"Reference","previous_headings":"","what":"Different Cholesky factor updates — cholUpdate","title":"Different Cholesky factor updates — cholUpdate","text":"Provides functions implements different types updates Cholesky factor includes rank-one update, single row/column deletion update block deletion update.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/cholUpdate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Different Cholesky factor updates — cholUpdate","text":"","code":"cholUpdateRankOne(A, v, alpha, beta, lower = TRUE)  cholUpdateDel(A, del.index, lower = TRUE)  cholUpdateDelBlock(A, del.start, del.end, lower = TRUE)"},{"path":"https://span-18.github.io/spStack-dev/reference/cholUpdate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Different Cholesky factor updates — cholUpdate","text":"\\(n\\times n\\) triangular matrix v \\(n\\times 1\\) matrix/vector alpha scalar; supplied, default 1 beta scalar; supplied, default 1 lower logical; lower-triangular del.index integer 1 \\(n\\) indicating row/column deleted del.start integer 1 \\(n\\) indicating first row/column block deleted, must least 1 less del.end del.end integer 1 \\(n\\) indicating last row/column block deleted, must least 1 del.start","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/cholUpdate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Different Cholesky factor updates — cholUpdate","text":"\\(m \\times m\\) lower-triangular matrix \\(m = n\\) case cholUpdateRankOne(), \\(m = n - 1\\) case cholUpdateDel(), , \\(m = n - n_k\\) case cholUpdateDelBlock() \\(n_k\\) size block removed.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/cholUpdate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Different Cholesky factor updates — cholUpdate","text":"Suppose \\(B = AA^\\top\\) \\(n \\times n\\) matrix \\(\\) lower-triangular Cholesky factor. rank-one update corresponds finding Cholesky factor matrix \\(C = \\alpha B + \\beta vv^\\top\\) \\(\\alpha,\\beta\\\\mathbb{R}\\) given \\(\\) (see, Krause Igel 2015). Similarly, single row/column deletion update corresponds finding Cholesky factor \\((n-1)\\times(n-1)\\) matrix \\(B_i\\) obtained removing \\(\\)-th row column \\(B\\), given \\(\\) \\(- 1, \\ldots, n\\). Lastly, block deletion corresponds finding Cholesky factor \\((n-n_k)\\times(n-n_k)\\) matrix \\(B_{}\\) subset \\(\\) \\(\\{1, \\ldots, n\\}\\) containing \\(n_k\\) consecutive indices, given factor \\(\\).","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/cholUpdate.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Different Cholesky factor updates — cholUpdate","text":"Oswin Krause Christian Igel. 2015. \"Efficient Rank-one Covariance Matrix Update Evolution Strategies\". Proceedings 2015 ACM Conference Foundations Genetic Algorithms XIII (FOGA '15). Association Computing Machinery, New York, NY, USA, 129-136. doi:10.1145/2725494.2725496 .","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/cholUpdate.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Different Cholesky factor updates — cholUpdate","text":"Soumyakanti Pan span18@ucla.edu, Sudipto Banerjee sudipto@ucla.edu","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/cholUpdate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Different Cholesky factor updates — cholUpdate","text":"","code":"n <- 10 A <- matrix(rnorm(n^2), n, n) A <- crossprod(A) cholA <- chol(A)  ## Rank-1 update v <- 1:n APlusvvT <- A + tcrossprod(v) cholA1 <- t(chol(APlusvvT)) cholA2 <- cholUpdateRankOne(cholA, v, lower = FALSE) print(all(abs(cholA1 - cholA2) < 1E-9)) #> [1] TRUE  ## Single Row-deletion update ind <- 2 A1 <- A[-ind, -ind] cholA1 <- t(chol(A1)) cholA2 <- cholUpdateDel(cholA, del.index = ind, lower = FALSE) print(all(abs(cholA1 - cholA2) < 1E-9)) #> [1] TRUE  ## Block-deletion update start_ind <- 2 end_ind <- 6 del_ind <- c(start_ind:end_ind) A1 <- A[-del_ind, -del_ind] cholA1 <- t(chol(A1)) cholA2 <- cholUpdateDelBlock(cholA, start_ind, end_ind, lower = FALSE) print(all(abs(cholA1 - cholA2) < 1E-9)) #> [1] TRUE"},{"path":"https://span-18.github.io/spStack-dev/reference/get_stacking_weights.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimal stacking weights — get_stacking_weights","title":"Optimal stacking weights — get_stacking_weights","text":"Obtains optimal stacking weights given leave-one-predictive densities candidate model.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/get_stacking_weights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimal stacking weights — get_stacking_weights","text":"","code":"get_stacking_weights(log_loopd, solver = \"ECOS\")"},{"path":"https://span-18.github.io/spStack-dev/reference/get_stacking_weights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimal stacking weights — get_stacking_weights","text":"log_loopd \\(n \\times M\\) matrix \\(\\)-th row containing leave-one-predictive densities \\(\\)-th data point \\(M\\) candidate models. solver specifies solver use obtaining optimal weights. Default \"ECOS\". Internally calls CVXR::psolve().","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/get_stacking_weights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimal stacking weights — get_stacking_weights","text":"list length 2. weights optimal stacking weights numeric vector length \\(M\\) status solver status, returns \"optimal\" solver succeeded.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/get_stacking_weights.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Optimal stacking weights — get_stacking_weights","text":"Yao Y, Vehtari , Simpson D, Gelman (2018). \"Using Stacking Average Bayesian Predictive Distributions (Discussion).\" Bayesian Analysis, 13(3), 917-1007. doi:10.1214/17-BA1091 .","code":""},{"path":[]},{"path":"https://span-18.github.io/spStack-dev/reference/get_stacking_weights.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Optimal stacking weights — get_stacking_weights","text":"Soumyakanti Pan span18@ucla.edu, Sudipto Banerjee sudipto@ucla.edu","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/get_stacking_weights.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Optimal stacking weights — get_stacking_weights","text":"","code":"data(simGaussian) dat <- simGaussian[1:100, ]  mod1 <- spLMstack(y ~ x1, data = dat,                   coords = as.matrix(dat[, c(\"s1\", \"s2\")]),                   cor.fn = \"matern\",                   params.list = list(phi = c(1.5, 3),                                      nu = c(0.5, 1),                                      noise_sp_ratio = c(1)),                   n.samples = 1000, loopd.method = \"exact\",                   parallel = FALSE, solver = \"ECOS\", verbose = TRUE) #>  #> STACKING WEIGHTS: #>  #>           | phi | nu  | noise_sp_ratio | weight | #> +---------+-----+-----+----------------+--------+ #> | Model 1 |  1.5|  0.5|               1| 0.000  | #> | Model 2 |  3.0|  0.5|               1| 0.285  | #> | Model 3 |  1.5|  1.0|               1| 0.000  | #> | Model 4 |  3.0|  1.0|               1| 0.715  | #> +---------+-----+-----+----------------+--------+ #>   loopd_mat <- do.call('cbind', mod1$loopd) w_hat <- get_stacking_weights(loopd_mat) print(round(w_hat$weights, 4)) #> [1] 0.0000 0.2845 0.0000 0.7155 print(w_hat$status) #> [1] \"optimal\""},{"path":"https://span-18.github.io/spStack-dev/reference/iDist.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate distance matrix — iDist","title":"Calculate distance matrix — iDist","text":"Computes inter-site Euclidean distance matrix one two sets points.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/iDist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate distance matrix — iDist","text":"","code":"iDist(coords.1, coords.2, ...)"},{"path":"https://span-18.github.io/spStack-dev/reference/iDist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate distance matrix — iDist","text":"coords.1 \\(n\\times p\\) matrix row corresponding point \\(p\\)-dimensional space. coords.2 \\(m\\times p\\) matrix row corresponding point \\(p\\) dimensional space. missing coords.1 used. ... currently additional arguments.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/iDist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate distance matrix — iDist","text":"\\(n\\times n\\) \\(n\\times m\\) inter-site Euclidean distance matrix.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/iDist.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate distance matrix — iDist","text":"Soumyakanti Pan span18@ucla.edu, Sudipto Banerjee sudipto@ucla.edu","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/iDist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate distance matrix — iDist","text":"","code":"n <- 10 p1 <- cbind(runif(n),runif(n)) m <- 5 p2 <- cbind(runif(m),runif(m)) D <- iDist(p1, p2)"},{"path":"https://span-18.github.io/spStack-dev/reference/simBinary.html","id":null,"dir":"Reference","previous_headings":"","what":"Synthetic point-referenced binary data — simBinary","title":"Synthetic point-referenced binary data — simBinary","text":"Dataset size 500, binary response variable indexed spatial coordinates sampled uniformly unit square. model includes one covariate spatial random effects induced Matérn covariogram.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/simBinary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Synthetic point-referenced binary data — simBinary","text":"","code":"data(simBinary)"},{"path":"https://span-18.github.io/spStack-dev/reference/simBinary.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Synthetic point-referenced binary data — simBinary","text":"data.frame object. s1, s2 2-D coordinates; latitude longitude. x1 covariate sampled standard normal distribution. y response vector (0/1). z_true true spatial random effects generated data.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/simBinary.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Synthetic point-referenced binary data — simBinary","text":"\\(n = 500\\), binary data simulated using $$ \\begin{aligned} y(s_i) &\\sim \\mathrm{Bernoulli}(\\pi(s_i)), = 1, \\ldots, n,\\\\ \\pi(s_i) &= \\mathrm{ilogit}(x(s_i)^\\top \\beta + z(s_i)) \\end{aligned} $$ function \\(\\mathrm{ilogit}\\) refers inverse-logit function, spatial effects \\(z \\sim N(0, \\sigma^2 R)\\) \\(R\\) \\(n \\times n\\) correlation matrix given Matérn covariogram $$ R(s, s') = \\frac{(\\phi |s-s'|)^\\nu}{\\Gamma(\\nu) 2^{\\nu - 1}} K_\\nu(\\phi |s-s'|), $$ \\(\\phi\\) spatial decay parameter \\(\\nu\\) spatial smoothness parameter. sampled data \\(\\beta = (0.5, -0.5)\\), \\(\\phi = 5\\), \\(\\nu = 0.5\\), \\(\\sigma^2 = 0.4\\). data can generated code given example .","code":""},{"path":[]},{"path":"https://span-18.github.io/spStack-dev/reference/simBinary.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Synthetic point-referenced binary data — simBinary","text":"Soumyakanti Pan span18@ucla.edu, Sudipto Banerjee sudipto@ucla.edu","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/simBinary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Synthetic point-referenced binary data — simBinary","text":"","code":"set.seed(1729) n <- 500 beta <- c(0.5, -0.5) phi0 <- 5 nu0 <- 0.5 spParams <- c(phi0, nu0) spvar <- 0.4 sim1 <- sim_spData(n = n, beta = beta, cor.fn = \"matern\",                    spParams = spParams, spvar = spvar, deltasq = deltasq,                    family = \"binary\") plot1 <- surfaceplot(sim1, coords_name = c(\"s1\", \"s2\"), var_name = \"z_true\")  library(ggplot2) plot2 <- ggplot(sim1, aes(x = s1, y = s2)) +   geom_point(aes(color = factor(y)), alpha = 0.75) +   scale_color_manual(values = c(\"red\", \"blue\"), labels = c(\"0\", \"1\")) +   guides(alpha = 'none') +   theme_bw() +   theme(axis.ticks = element_line(linewidth = 0.25),         panel.background = element_blank(),         panel.grid = element_blank(),         legend.title = element_text(size = 10, hjust = 0.25),         legend.box.just = \"center\", aspect.ratio = 1)"},{"path":"https://span-18.github.io/spStack-dev/reference/simBinom.html","id":null,"dir":"Reference","previous_headings":"","what":"Synthetic point-referenced binomial count data — simBinom","title":"Synthetic point-referenced binomial count data — simBinom","text":"Dataset size 500, binomial response variable indexed spatial coordinates sampled uniformly unit square. model includes one covariate spatial random effects induced Matérn covariogram. number trials location sampled Poisson distribution mean 20.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/simBinom.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Synthetic point-referenced binomial count data — simBinom","text":"","code":"data(simBinom)"},{"path":"https://span-18.github.io/spStack-dev/reference/simBinom.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Synthetic point-referenced binomial count data — simBinom","text":"data.frame object. s1, s2 2-D coordinates; latitude longitude. x1 covariate sampled standard normal distribution. y response vector. n_trials Number trials location. z_true true spatial random effects generated data.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/simBinom.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Synthetic point-referenced binomial count data — simBinom","text":"\\(n = 500\\), count data simulated using $$ \\begin{aligned} y(s_i) &\\sim \\mathrm{Binomial}(m(s_i), \\pi(s_i)), = 1, \\ldots, n,\\\\ \\pi(s_i) &= \\mathrm{ilogit}(x(s_i)^\\top \\beta + z(s_i)) \\end{aligned} $$ function \\(\\mathrm{ilogit}\\) refers inverse-logit function, number trials \\(m(s_i)\\) sampled Poisson distribution mean 20, spatial effects \\(z \\sim N(0, \\sigma^2 R)\\) \\(R\\) \\(n \\times n\\) correlation matrix given Matérn covariogram $$ R(s, s') = \\frac{(\\phi |s-s'|)^\\nu}{\\Gamma(\\nu) 2^{\\nu - 1}} K_\\nu(\\phi |s-s'|), $$ \\(\\phi\\) spatial decay parameter \\(\\nu\\) spatial smoothness parameter. sampled data \\(\\beta = (0.5, -0.5)\\), \\(\\phi = 3\\), \\(\\nu = 0.5\\), \\(\\sigma^2 = 0.4\\). data can generated code given example .","code":""},{"path":[]},{"path":"https://span-18.github.io/spStack-dev/reference/simBinom.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Synthetic point-referenced binomial count data — simBinom","text":"Soumyakanti Pan span18@ucla.edu, Sudipto Banerjee sudipto@ucla.edu","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/simBinom.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Synthetic point-referenced binomial count data — simBinom","text":"","code":"set.seed(1729) n <- 500 beta <- c(0.5, -0.5) phi0 <- 3 nu0 <- 0.5 spParams <- c(phi0, nu0) spvar <- 0.4 sim1 <- sim_spData(n = n, beta = beta, cor.fn = \"matern\",                    spParams = spParams, spvar = spvar, deltasq = deltasq,                    n_binom = rpois(n, 20),                    family = \"binomial\") plot1 <- surfaceplot(sim1, coords_name = c(\"s1\", \"s2\"), var_name = \"z_true\")  library(ggplot2) plot2 <- ggplot(sim1, aes(x = s1, y = s2)) +   geom_point(aes(color = y), alpha = 0.75) +   scale_color_distiller(palette = \"RdYlGn\", direction = -1,                         label = function(x) sprintf(\"%.0f\", x)) +   guides(alpha = 'none') +   theme_bw() +   theme(axis.ticks = element_line(linewidth = 0.25),         panel.background = element_blank(),         panel.grid = element_blank(),         legend.title = element_text(size = 10, hjust = 0.25),         legend.box.just = \"center\", aspect.ratio = 1)"},{"path":"https://span-18.github.io/spStack-dev/reference/simGaussian.html","id":null,"dir":"Reference","previous_headings":"","what":"Synthetic point-referenced Gaussian data — simGaussian","title":"Synthetic point-referenced Gaussian data — simGaussian","text":"Dataset size 500 Gaussian response variable, simulated spatial coordinates sampled uniformly unit square. model includes one covariate spatial random effects induced Matérn covariogram.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/simGaussian.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Synthetic point-referenced Gaussian data — simGaussian","text":"","code":"data(simGaussian)"},{"path":"https://span-18.github.io/spStack-dev/reference/simGaussian.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Synthetic point-referenced Gaussian data — simGaussian","text":"data.frame object. s1, s2 2-D coordinates; latitude longitude. x1 covariate sampled standard normal distribution. y response vector. z_true true spatial random effects generated data.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/simGaussian.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Synthetic point-referenced Gaussian data — simGaussian","text":"data generated using model $$ y = X \\beta + z + \\epsilon, $$ spatial effects \\(z \\sim N(0, \\sigma^2 R)\\) independent measurement error \\(\\epsilon \\sim N(0, \\delta^2 \\sigma^2 I_n)\\) \\(\\delta^2\\) noise--spatial variance ratio \\(R\\) \\(n \\times n\\) correlation matrix given Matérn covariogram $$ R(s, s') = \\frac{(\\phi |s-s'|)^\\nu}{\\Gamma(\\nu) 2^{\\nu - 1}} K_\\nu(\\phi |s-s'|), $$ \\(\\phi\\) spatial decay parameter \\(\\nu\\) spatial smoothness parameter. sampled data \\(\\beta = (2, 5)\\), \\(\\phi = 2\\), \\(\\nu = 0.5\\), \\(\\delta^2 = 1\\) \\(\\sigma^2 = 0.4\\). data can generated code given example.","code":""},{"path":[]},{"path":"https://span-18.github.io/spStack-dev/reference/simGaussian.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Synthetic point-referenced Gaussian data — simGaussian","text":"Soumyakanti Pan span18@ucla.edu","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/simGaussian.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Synthetic point-referenced Gaussian data — simGaussian","text":"","code":"set.seed(1729) n <- 500 beta <- c(2, 5) phi0 <- 2 nu0 <- 0.5 spParams <- c(phi0, nu0) spvar <- 0.4 deltasq <- 1 sim1 <- sim_spData(n = n, beta = beta, cor.fn = \"matern\",                    spParams = spParams, spvar = spvar, deltasq = deltasq,                    family = \"gaussian\") plot1 <- surfaceplot(sim1, coords_name = c(\"s1\", \"s2\"), var_name = \"z_true\",                      mark_points = TRUE) plot1   library(ggplot2) plot2 <- ggplot(sim1, aes(x = s1, y = s2)) +   geom_point(aes(color = y), alpha = 0.75) +   scale_color_distiller(palette = \"RdYlGn\", direction = -1,                         label = function(x) sprintf(\"%.0f\", x)) +   guides(alpha = 'none') + theme_bw() +   theme(axis.ticks = element_line(linewidth = 0.25),         panel.background = element_blank(), panel.grid = element_blank(),         legend.title = element_text(size = 10, hjust = 0.25),         legend.box.just = \"center\", aspect.ratio = 1) plot2"},{"path":"https://span-18.github.io/spStack-dev/reference/simPoisson.html","id":null,"dir":"Reference","previous_headings":"","what":"Synthetic point-referenced Poisson count data — simPoisson","title":"Synthetic point-referenced Poisson count data — simPoisson","text":"Dataset size 500, Poisson distributed response variable indexed spatial coordinates sampled uniformly unit square. model includes one covariate spatial random effects induced Matérn covariogram.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/simPoisson.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Synthetic point-referenced Poisson count data — simPoisson","text":"","code":"data(simPoisson)"},{"path":"https://span-18.github.io/spStack-dev/reference/simPoisson.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Synthetic point-referenced Poisson count data — simPoisson","text":"data.frame object. s1, s2 2-D coordinates; latitude longitude. x1 covariate sampled standard normal distribution. y response vector. z_true true spatial random effects generated data.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/simPoisson.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Synthetic point-referenced Poisson count data — simPoisson","text":"\\(n = 500\\), count data simulated using $$ \\begin{aligned} y(s_i) &\\sim \\mathrm{Poisson}(\\lambda(s_i)), = 1, \\ldots, n,\\\\ \\log \\lambda(s_i) &= x(s_i)^\\top \\beta + z(s_i) \\end{aligned} $$ spatial effects \\(z \\sim N(0, \\sigma^2 R)\\) \\(R\\) \\(n \\times n\\) correlation matrix given Matérn covariogram $$ R(s, s') = \\frac{(\\phi |s-s'|)^\\nu}{\\Gamma(\\nu) 2^{\\nu - 1}} K_\\nu(\\phi |s-s'|), $$ \\(\\phi\\) spatial decay parameter \\(\\nu\\) spatial smoothness parameter. sampled data \\(\\beta = (2, -0.5)\\), \\(\\phi = 5\\), \\(\\nu = 0.5\\), \\(\\sigma^2 = 0.4\\). data can generated code given example .","code":""},{"path":[]},{"path":"https://span-18.github.io/spStack-dev/reference/simPoisson.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Synthetic point-referenced Poisson count data — simPoisson","text":"","code":"set.seed(1729) n <- 500 beta <- c(2, -0.5) phi0 <- 5 nu0 <- 0.5 spParams <- c(phi0, nu0) spvar <- 0.4 sim1 <- sim_spData(n = n, beta = beta, cor.fn = \"matern\",                    spParams = spParams, spvar = spvar, deltasq = deltasq,                    family = \"poisson\")  # Plot an interpolated spatial surface of the true random spatial effects plot1 <- surfaceplot(sim1, coords_name = c(\"s1\", \"s2\"), var_name = \"z_true\")  # Plot the simulated count data library(ggplot2) plot2 <- ggplot(sim1, aes(x = s1, y = s2)) +   geom_point(aes(color = y), alpha = 0.75) +   scale_color_distiller(palette = \"RdYlGn\", direction = -1,                         label = function(x) sprintf(\"%.0f\", x)) +   guides(alpha = 'none') + theme_bw() +   theme(axis.ticks = element_line(linewidth = 0.25),         panel.background = element_blank(), panel.grid = element_blank(),         legend.title = element_text(size = 10, hjust = 0.25),         legend.box.just = \"center\", aspect.ratio = 1)"},{"path":"https://span-18.github.io/spStack-dev/reference/sim_spData.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate spatial data on unit square — sim_spData","title":"Simulate spatial data on unit square — sim_spData","text":"Generates synthetic spatial data different types spatial co-ordinates sampled uniformly unit square. Different types include point-referenced Gaussian, Poisson, binomial binary data. design includes intercept fixed covariates sampled standard normal distribution.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/sim_spData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate spatial data on unit square — sim_spData","text":"","code":"sim_spData(n, beta, cor.fn, spParams, spvar, deltasq, family, n_binom)"},{"path":"https://span-18.github.io/spStack-dev/reference/sim_spData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate spatial data on unit square — sim_spData","text":"n sample size. beta \\(p\\)-dimensional vector fixed effects. cor.fn quoted keyword specifies correlation function used model spatial dependence structure among observations. Supported covariance model key words : 'exponential' 'matern'. spParams numeric vector containing spatial process parameters - e.g., spatial decay smoothness. spvar value spatial variance parameter. deltasq value noise--spatial variance ratio. family character specifying distribution response member exponential family. Valid inputs 'gaussian', 'poisson', 'binary', 'binomial'. n_binom necessary family = 'binomial'. Must vector length n specify number trials observation. length 1, value considered common value number trials n observations.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/sim_spData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate spatial data on unit square — sim_spData","text":"data.frame object containing columns - s1, s2 2D-coordinates unit square x1, x2, ... covariates, including intercept y response n_trials present binomial data generated z_true true spatial effects data generated","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/sim_spData.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulate spatial data on unit square — sim_spData","text":"Soumyakanti Pan span18@ucla.edu, Sudipto Banerjee sudipto@ucla.edu","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/sim_spData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate spatial data on unit square — sim_spData","text":"","code":"set.seed(1729) n <- 10 beta <- c(2, 5) phi0 <- 2 nu0 <- 0.5 spParams <- c(phi0, nu0) spvar <- 0.4 deltasq <- 1 sim1 <- sim_spData(n = n, beta = beta, cor.fn = \"matern\",                    spParams = spParams, spvar = spvar, deltasq = deltasq,                    family = \"gaussian\")"},{"path":"https://span-18.github.io/spStack-dev/reference/spGLMexact.html","id":null,"dir":"Reference","previous_headings":"","what":"Univariate Bayesian spatial generalized linear model — spGLMexact","title":"Univariate Bayesian spatial generalized linear model — spGLMexact","text":"Fits Bayesian spatial generalized linear model fixed values spatial process parameters auxiliary model parameters. output contains posterior samples fixed effects, spatial random effects , required, finds leave-one-predictive densities.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spGLMexact.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Univariate Bayesian spatial generalized linear model — spGLMexact","text":"","code":"spGLMexact(   formula,   data = parent.frame(),   family,   coords,   cor.fn,   priors,   spParams,   boundary = 0.5,   n.samples,   loopd = FALSE,   loopd.method = \"exact\",   CV.K = 10,   loopd.nMC = 500,   verbose = TRUE,   ... )"},{"path":"https://span-18.github.io/spStack-dev/reference/spGLMexact.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Univariate Bayesian spatial generalized linear model — spGLMexact","text":"formula symbolic description regression model fit. See example . data optional data frame containing variables model. found data, variables taken environment(formula), typically environment spGLMexact called. family Specifies distribution response member exponential family. Supported options 'poisson', 'binomial' 'binary'. coords \\(n \\times 2\\) matrix observation coordinates \\(\\mathbb{R}^2\\) (e.g., easting northing). cor.fn quoted keyword specifies correlation function used model spatial dependence structure among observations. Supported covariance model key words : 'exponential' 'matern'. See details. priors (optional) list tag corresponding hyperparameter name containing hyperprior details. Valid tags include V.beta, nu.beta, nu.z sigmaSq.xi. Values nu.beta nu.z must least 2.1. supplied, uses defaults. spParams fixed values spatial process parameters. boundary Specifies boundary adjustment parameter. Must real number 0 1. Default 0.5. n.samples number posterior samples generated. loopd logical. loopd=TRUE, returns leave-one-predictive densities, using method given loopd.method. Default FALSE. loopd.method character. Ignored loopd=FALSE. loopd=TRUE, valid inputs 'exact', 'CV' 'PSIS'. option 'exact' corresponds exact leave-one-predictive densities requires computation almost equivalent fitting model \\(n\\) times. options 'CV' 'PSIS' faster implement \\(K\\)-fold cross validation Pareto-smoothed importance sampling find approximate leave-one-predictive densities (Vehtari et al. 2017). CV.K integer 10 20. Considered loopd.method='CV'. Default 10 (recommended Vehtari et. al 2017). loopd.nMC Number Monte Carlo samples used evaluate leave-one-predictive densities loopd.method set either 'exact' 'CV'. verbose logical. verbose = TRUE, prints model description. ... currently additional argument.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spGLMexact.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Univariate Bayesian spatial generalized linear model — spGLMexact","text":"object class spGLMexact, list following tags - priors details priors used, containing values boundary adjustment parameter (boundary), variance parameter fine-scale variation term (simasq.xi) others. samples list length 3, containing posterior samples fixed effects (beta), spatial effects (z) fine-scale variation term (xi). loopd loopd=TRUE, contains leave-one-predictive densities. model.params Values fixed parameters includes phi (spatial decay), nu (spatial smoothness). return object might include additional data can used subsequent prediction /model fit evaluation.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spGLMexact.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Univariate Bayesian spatial generalized linear model — spGLMexact","text":"function, fit Bayesian hierarchical spatial generalized linear model sampling exactly joint posterior distribution utilizing generalized conjugate multivariate distribution theory (Bradley Clinch 2024). Suppose \\(\\chi = (s_1, \\ldots, s_n)\\) denotes \\(n\\) spatial locations response \\(y\\) observed. Let \\(y(s)\\) outcome location \\(s\\) endowed probability law natural exponential family, denote $$ y(s) \\sim \\mathrm{EF}(x(s)^\\top \\beta + z(s); b, \\psi) $$ positive parameter \\(b > 0\\) unit log partition function \\(\\psi\\). consider following response models based input supplied argument family. 'poisson' considers point-referenced Poisson responses \\(y(s) \\sim \\mathrm{Poisson}(e^{x(s)^\\top \\beta + z(s)})\\). , \\(b = 1\\) \\(\\psi(t) = e^t\\). 'binomial' considers point-referenced binomial counts \\(y(s) \\sim \\mathrm{Binomial}(m(s), \\pi(s))\\) , \\(m(s)\\) denotes total number trials probability success \\(\\pi(s) = \\mathrm{ilogit}(x(s)^\\top \\beta + z(s))\\) location \\(s\\). , \\(b = m(s)\\) \\(\\psi(t) = \\log(1+e^t)\\). 'binary' considers point-referenced binary data (0 , 1) .e., \\(y(s) \\sim \\mathrm{Bernoulli}(\\pi(s))\\), probability success \\(\\pi(s) = \\mathrm{ilogit}(x(s)^\\top \\beta + z(s))\\) location \\(s\\). , \\(b = 1\\) \\(\\psi(t) = \\log(1 + e^t)\\). hierarchical model given $$ \\begin{aligned} y(s_i) &\\mid \\beta, z, \\xi \\sim EF(x(s_i)^\\top \\beta + z(s_i) + \\xi_i - \\mu_i; b_i, \\psi_y), = 1, \\ldots, n\\\\ \\xi &\\mid \\beta, z, \\sigma^2_\\xi, \\alpha_\\epsilon \\sim \\mathrm{GCM_c}(\\cdots),\\\\ \\beta &\\mid \\sigma^2_\\beta \\sim N(0, \\sigma^2_\\beta V_\\beta), \\quad \\sigma^2_\\beta \\sim \\mathrm{IG}(\\nu_\\beta/2, \\nu_\\beta/2)\\\\ z &\\mid \\sigma^2_z \\sim N(0, \\sigma^2_z R(\\chi; \\phi, \\nu)), \\quad \\sigma^2_z \\sim \\mathrm{IG}(\\nu_z/2, \\nu_z/2), \\end{aligned} $$ \\(\\mu = (\\mu_1, \\ldots, \\mu_n)^\\top\\) denotes discrepancy parameter. fix spatial process parameters \\(\\phi\\) \\(\\nu\\) hyperparameters \\(V_\\beta\\), \\(\\nu_\\beta\\), \\(\\nu_z\\) \\(\\sigma^2_\\xi\\). term \\(\\xi\\) known fine-scale variation term given conditional generalized conjugate multivariate distribution prior. details, see Pan et al. 2024. Default values \\(V_\\beta\\), \\(\\nu_\\beta\\), \\(\\nu_z\\), \\(\\sigma^2_\\xi\\) diagonal diagonal element 100, 2.1, 2.1 0.1 respectively.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spGLMexact.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Univariate Bayesian spatial generalized linear model — spGLMexact","text":"Bradley JR, Clinch M (2024). \"Generating Independent Replicates Directly Posterior Distribution Class Spatial Hierarchical Models.\" Journal Computational Graphical Statistics, 0(0), 1-17. doi:10.1080/10618600.2024.2365728 . Pan S, Zhang L, Bradley JR, Banerjee S (2024). \"Bayesian Inference Spatial-temporal Non-Gaussian Data Using Predictive Stacking.\" doi:10.48550/arXiv.2406.04655 . Vehtari , Gelman , Gabry J (2017). \"Practical Bayesian Model Evaluation Using Leave-One-Cross-Validation WAIC.\" Statistics Computing, 27(5), 1413-1432. ISSN 0960-3174. doi:10.1007/s11222-016-9696-4 .","code":""},{"path":[]},{"path":"https://span-18.github.io/spStack-dev/reference/spGLMexact.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Univariate Bayesian spatial generalized linear model — spGLMexact","text":"Soumyakanti Pan span18@ucla.edu","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spGLMexact.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Univariate Bayesian spatial generalized linear model — spGLMexact","text":"","code":"# Example 1: Analyze spatial poisson count data data(simPoisson) dat <- simPoisson[1:10, ] mod1 <- spGLMexact(y ~ x1, data = dat, family = \"poisson\",                    coords = as.matrix(dat[, c(\"s1\", \"s2\")]),                    cor.fn = \"matern\",                    spParams = list(phi = 4, nu = 0.4),                    n.samples = 100, verbose = TRUE) #> ---------------------------------------- #> \tModel description #> ---------------------------------------- #> Model fit with 10 observations. #>  #> Family = poisson. #>  #> Number of covariates 2 (including intercept). #>  #> Using the matern spatial correlation function. #>  #> Priors: #> \tbeta: Gaussian #> \tmu:\t0.00\t0.00\t #> \tcov: #> \t100.00\t0.00\t #> \t0.00\t100.00\t #>  #> \tsigmaSq.beta ~ IG(nu.beta/2, nu.beta/2) #> \tsigmaSq.z ~ IG(nu.z/2, nu.z/2) #> \tnu.beta = 2.10, nu.z = 2.10. #> \tsigmaSq.xi = 0.10. #> \tBoundary adjustment parameter = 0.50. #>  #> Spatial process parameters: #> \tphi = 4.00, and, nu = 0.40. #>  #> Number of posterior samples = 100. #> ----------------------------------------  # summarize posterior samples post_beta <- mod1$samples$beta print(t(apply(post_beta, 1, function(x) quantile(x, c(0.025, 0.5, 0.975))))) #>             2.5%        50%    97.5% #> [1,]  0.07462851  2.2074935 5.541867 #> [2,] -2.32273414 -0.3911022 1.343105  # Example 2: Analyze spatial binomial count data data(simBinom) dat <- simBinom[1:10, ] mod2 <- spGLMexact(cbind(y, n_trials) ~ x1, data = dat, family = \"binomial\",                    coords = as.matrix(dat[, c(\"s1\", \"s2\")]),                    cor.fn = \"matern\",                    spParams = list(phi = 3, nu = 0.4),                    n.samples = 100, verbose = TRUE) #> ---------------------------------------- #> \tModel description #> ---------------------------------------- #> Model fit with 10 observations. #>  #> Family = binomial. #>  #> Number of covariates 2 (including intercept). #>  #> Using the matern spatial correlation function. #>  #> Priors: #> \tbeta: Gaussian #> \tmu:\t0.00\t0.00\t #> \tcov: #> \t100.00\t0.00\t #> \t0.00\t100.00\t #>  #> \tsigmaSq.beta ~ IG(nu.beta/2, nu.beta/2) #> \tsigmaSq.z ~ IG(nu.z/2, nu.z/2) #> \tnu.beta = 2.10, nu.z = 2.10. #> \tsigmaSq.xi = 0.10. #> \tBoundary adjustment parameter = 0.50. #>  #> Spatial process parameters: #> \tphi = 3.00, and, nu = 0.40. #>  #> Number of posterior samples = 100. #> ----------------------------------------  # summarize posterior samples post_beta <- mod2$samples$beta print(t(apply(post_beta, 1, function(x) quantile(x, c(0.025, 0.5, 0.975))))) #>            2.5%        50%     97.5% #> [1,] -0.3347374  1.1426362 2.9358010 #> [2,] -1.9595693 -0.6214757 0.4642419  # Example 3: Analyze spatial binary data data(simBinary) dat <- simBinary[1:10, ] mod3 <- spGLMexact(y ~ x1, data = dat, family = \"binary\",                    coords = as.matrix(dat[, c(\"s1\", \"s2\")]),                    cor.fn = \"matern\",                    spParams = list(phi = 4, nu = 0.4),                    n.samples = 100, verbose = TRUE) #> ---------------------------------------- #> \tModel description #> ---------------------------------------- #> Model fit with 10 observations. #>  #> Family = binary. #>  #> Number of covariates 2 (including intercept). #>  #> Using the matern spatial correlation function. #>  #> Priors: #> \tbeta: Gaussian #> \tmu:\t0.00\t0.00\t #> \tcov: #> \t100.00\t0.00\t #> \t0.00\t100.00\t #>  #> \tsigmaSq.beta ~ IG(nu.beta/2, nu.beta/2) #> \tsigmaSq.z ~ IG(nu.z/2, nu.z/2) #> \tnu.beta = 2.10, nu.z = 2.10. #> \tsigmaSq.xi = 0.10. #> \tBoundary adjustment parameter = 0.50. #>  #> Spatial process parameters: #> \tphi = 4.00, and, nu = 0.40. #>  #> Number of posterior samples = 100. #> ----------------------------------------  # summarize posterior samples post_beta <- mod3$samples$beta print(t(apply(post_beta, 1, function(x) quantile(x, c(0.025, 0.5, 0.975))))) #>           2.5%        50%    97.5% #> [1,] -2.012890  1.2453228 4.693207 #> [2,] -2.096343 -0.2022237 1.335701"},{"path":"https://span-18.github.io/spStack-dev/reference/spGLMstack.html","id":null,"dir":"Reference","previous_headings":"","what":"Bayesian spatial generalized linear model using predictive stacking — spGLMstack","title":"Bayesian spatial generalized linear model using predictive stacking — spGLMstack","text":"Fits Bayesian spatial generalized linear model collection candidate models constructed based candidate values model parameters specified user subsequently combines inference stacking predictive densities. See Pan, Zhang, Bradley, Banerjee (2024) details.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spGLMstack.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bayesian spatial generalized linear model using predictive stacking — spGLMstack","text":"","code":"spGLMstack(   formula,   data = parent.frame(),   family,   coords,   cor.fn,   priors,   params.list,   n.samples,   loopd.controls,   parallel = FALSE,   solver = \"ECOS\",   verbose = TRUE,   ... )"},{"path":"https://span-18.github.io/spStack-dev/reference/spGLMstack.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bayesian spatial generalized linear model using predictive stacking — spGLMstack","text":"formula symbolic description regression model fit. See example . data optional data frame containing variables model. found data, variables taken environment(formula), typically environment spLMstack called. family Specifies distribution response member exponential family. Supported options 'poisson', 'binomial' 'binary'. coords \\(n \\times 2\\) matrix observation coordinates \\(\\mathbb{R}^2\\) (e.g., easting northing). cor.fn quoted keyword specifies correlation function used model spatial dependence structure among observations. Supported covariance model key words : 'exponential' 'matern'. See details. priors (optional) list tag corresponding parameter name containing prior details. Valid tags include V.beta, nu.beta, nu.z sigmaSq.xi. params.list list containing candidate values spatial process parameters cor.fn used, , boundary parameter. n.samples number posterior samples generated. loopd.controls list details leave-one-predictive densities (LOO-PD) calculated. Valid tags include method, CV.K nMC. tag method can either 'exact' 'CV'. sample size 100, default 'CV' CV.K equal default value 10 (Gelman et al. 2024). tag nMC decides many Monte Carlo samples used evaluate leave-one-predictive densities, must least 500 (default). parallel logical. parallel=FALSE, parallelization plan, set user, ignored. parallel=TRUE, function inherits parallelization plan set user via function future::plan() . Depending parallel backend available, users may choose plan. details available https://cran.R-project.org/package=future. solver (optional) Specifies name solver used obtain optimal stacking weights candidate model. Default 'ECOS'. Users can use solvers supported CVXR-package package. verbose logical. TRUE, prints model-specific optimal stacking weights. ... currently additional argument.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spGLMstack.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bayesian spatial generalized linear model using predictive stacking — spGLMstack","text":"object class spGLMstack, list including following tags - family distribution responses indicated function call samples list length equal total number candidate models entry corresponding list length 3, containing posterior samples fixed effects (beta), spatial effects (z) fine-scale variation term (xi) particular model. loopd list length equal total number candidate models entry containing leave-one-predictive densities particular model. loopd.method list containing details algorithm used calculation leave-one-predictive densities. n.models number candidate models fit. candidate.models matrix n_model rows row containing details model parameters optimal weight. stacking.weights numeric vector length equal number candidate models storing optimal stacking weights. run.time proc_time object runtime details. solver.status solver status returned optimization routine. return object might include additional data useful subsequent prediction, model fit evaluation utilities.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spGLMstack.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Bayesian spatial generalized linear model using predictive stacking — spGLMstack","text":"Instead assigning prior process parameters \\(\\phi\\) \\(\\nu\\), boundary adjustment parameter \\(\\epsilon\\), consider set candidate models based candidate values parameters supplied user. Suppose set candidate models \\(\\mathcal{M} = \\{M_1, \\ldots, M_G\\}\\). \\(g = 1, \\ldots, G\\), sample posterior distribution \\(p(\\sigma^2, \\beta, z \\mid y, M_g)\\) model \\(M_g\\) find leave-one-predictive densities \\(p(y_i \\mid y_{-}, M_g)\\). solve optimization problem $$ \\begin{aligned} \\max_{w_1, \\ldots, w_G}& \\, \\frac{1}{n} \\sum_{= 1}^n \\log \\sum_{g = 1}^G w_g p(y_i \\mid y_{-}, M_g) \\\\ \\text{subject } & \\quad w_g \\geq 0, \\sum_{g = 1}^G w_g = 1 \\end{aligned} $$ find optimal stacking weights \\(\\hat{w}_1, \\ldots, \\hat{w}_G\\).","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spGLMstack.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Bayesian spatial generalized linear model using predictive stacking — spGLMstack","text":"Pan S, Zhang L, Bradley JR, Banerjee S (2024). \"Bayesian Inference Spatial-temporal Non-Gaussian Data Using Predictive Stacking.\" doi:10.48550/arXiv.2406.04655 . Vehtari , Simpson D, Gelman , Yao Y, Gabry J (2024). \"Pareto Smoothed Importance Sampling.\" Journal Machine Learning Research, 25(72), 1-58. URL https://jmlr.org/papers/v25/19-556.html.","code":""},{"path":[]},{"path":"https://span-18.github.io/spStack-dev/reference/spGLMstack.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Bayesian spatial generalized linear model using predictive stacking — spGLMstack","text":"Soumyakanti Pan span18@ucla.edu, Sudipto Banerjee sudipto@ucla.edu","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spGLMstack.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bayesian spatial generalized linear model using predictive stacking — spGLMstack","text":"","code":"# \\donttest{ data(\"simPoisson\") dat <- simPoisson[1:100,] mod1 <- spGLMstack(y ~ x1, data = dat, family = \"poisson\",                    coords = as.matrix(dat[, c(\"s1\", \"s2\")]), cor.fn = \"matern\",                   params.list = list(phi = c(3, 7, 10), nu = c(0.25, 0.5, 1.5),                                      boundary = c(0.5, 0.6)),                   n.samples = 1000,                   loopd.controls = list(method = \"CV\", CV.K = 10, nMC = 1000),                   parallel = TRUE, solver = \"ECOS\", verbose = TRUE) #>  #> STACKING WEIGHTS: #>  #>            | phi | nu   | boundary | weight | #> +----------+-----+------+----------+--------+ #> | Model 1  |    3|  0.25|       0.5| 0.000  | #> | Model 2  |    7|  0.25|       0.5| 0.000  | #> | Model 3  |   10|  0.25|       0.5| 0.000  | #> | Model 4  |    3|  0.50|       0.5| 0.000  | #> | Model 5  |    7|  0.50|       0.5| 0.000  | #> | Model 6  |   10|  0.50|       0.5| 0.000  | #> | Model 7  |    3|  1.50|       0.5| 0.000  | #> | Model 8  |    7|  1.50|       0.5| 0.000  | #> | Model 9  |   10|  1.50|       0.5| 0.000  | #> | Model 10 |    3|  0.25|       0.6| 0.000  | #> | Model 11 |    7|  0.25|       0.6| 0.000  | #> | Model 12 |   10|  0.25|       0.6| 0.000  | #> | Model 13 |    3|  0.50|       0.6| 0.000  | #> | Model 14 |    7|  0.50|       0.6| 0.000  | #> | Model 15 |   10|  0.50|       0.6| 0.000  | #> | Model 16 |    3|  1.50|       0.6| 0.405  | #> | Model 17 |    7|  1.50|       0.6| 0.595  | #> | Model 18 |   10|  1.50|       0.6| 0.000  | #> +----------+-----+------+----------+--------+ #>   # print(mod1$solver.status) # print(mod1$run.time)  post_samps <- stackedSampler(mod1) post_beta <- post_samps$beta print(t(apply(post_beta, 1, function(x) quantile(x, c(0.025, 0.5, 0.975))))) #>                   2.5%        50%      97.5% #> (Intercept) -0.1449355  2.0974892  4.4808250 #> x1          -0.7239918 -0.5682882 -0.4508448  post_z <- post_samps$z post_z_summ <- t(apply(post_z, 1, function(x) quantile(x, c(0.025, 0.5, 0.975))))  z_combn <- data.frame(z = dat$z_true,                       zL = post_z_summ[, 1],                       zM = post_z_summ[, 2],                       zU = post_z_summ[, 3])  library(ggplot2) plot_z <- ggplot(data = z_combn, aes(x = z)) +  geom_errorbar(aes(ymin = zL, ymax = zU),                width = 0.05, alpha = 0.15,                color = \"skyblue\") +  geom_point(aes(y = zM), size = 0.25,             color = \"darkblue\", alpha = 0.5) +  geom_abline(slope = 1, intercept = 0,              color = \"red\", linetype = \"solid\") +  xlab(\"True z\") + ylab(\"Posterior of z\") +  theme_bw() +  theme(panel.background = element_blank(),        aspect.ratio = 1) # }"},{"path":"https://span-18.github.io/spStack-dev/reference/spLMexact.html","id":null,"dir":"Reference","previous_headings":"","what":"Univariate Bayesian spatial linear model — spLMexact","title":"Univariate Bayesian spatial linear model — spLMexact","text":"Fits Bayesian spatial linear model spatial process parameters noise--spatial variance ratio fixed value supplied user. output contains posterior samples fixed effects, variance parameter, spatial random effects , required, leave-one-predictive densities.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spLMexact.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Univariate Bayesian spatial linear model — spLMexact","text":"","code":"spLMexact(   formula,   data = parent.frame(),   coords,   cor.fn,   priors,   spParams,   noise_sp_ratio,   n.samples,   loopd = FALSE,   loopd.method = \"exact\",   verbose = TRUE,   ... )"},{"path":"https://span-18.github.io/spStack-dev/reference/spLMexact.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Univariate Bayesian spatial linear model — spLMexact","text":"formula symbolic description regression model fit. See example . data optional data frame containing variables model. found data, variables taken environment(formula), typically environment spLMexact called. coords \\(n \\times 2\\) matrix observation coordinates \\(\\mathbb{R}^2\\) (e.g., easting northing). cor.fn quoted keyword specifies correlation function used model spatial dependence structure among observations. Supported covariance model key words : 'exponential' 'matern'. See details. priors list tag corresponding parameter name containing prior details. spParams fixed value spatial process parameters. noise_sp_ratio noise--spatial variance ratio. n.samples number posterior samples generated. loopd logical. loopd=TRUE, returns leave-one-predictive densities, using method given loopd.method. Default FALSE. loopd.method character. Ignored loopd=FALSE. loopd=TRUE, valid inputs 'exact' 'PSIS'. option 'exact' corresponds exact leave-one-predictive densities requires computation almost equivalent fitting model \\(n\\) times. option 'PSIS' faster finds approximate leave-one-predictive densities using Pareto-smoothed importance sampling (Gelman et al. 2024). verbose logical. verbose = TRUE, prints model description. ... currently additional argument.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spLMexact.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Univariate Bayesian spatial linear model — spLMexact","text":"object class spLMexact, list following tags - samples list length 3, containing posterior samples fixed effects (beta), variance parameter (sigmaSq), spatial effects (z). loopd loopd=TRUE, contains leave-one-predictive densities. model.params Values fixed parameters includes phi (spatial decay), nu (spatial smoothness) noise_sp_ratio (noise--spatial variance ratio). return object might include additional data used subsequent prediction /model fit evaluation.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spLMexact.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Univariate Bayesian spatial linear model — spLMexact","text":"Suppose \\(\\chi = (s_1, \\ldots, s_n)\\) denotes \\(n\\) spatial locations response \\(y\\) observed. function, fit conjugate Bayesian hierarchical spatial model $$ \\begin{aligned} y \\mid z, \\beta, \\sigma^2 &\\sim N(X\\beta + z, \\delta^2 \\sigma^2 I_n), \\quad z \\mid \\sigma^2 \\sim N(0, \\sigma^2 R(\\chi; \\phi, \\nu)), \\\\ \\beta \\mid \\sigma^2 &\\sim N(\\mu_\\beta, \\sigma^2 V_\\beta), \\quad \\sigma^2 \\sim \\mathrm{IG}(a_\\sigma, b_\\sigma) \\end{aligned} $$ fix spatial process parameters \\(\\phi\\) \\(\\nu\\), noise--spatial variance ratio \\(\\delta^2\\) hyperparameters \\(\\mu_\\beta\\), \\(V_\\beta\\), \\(a_\\sigma\\) \\(b_\\sigma\\). utilize composition sampling strategy sample model parameters joint posterior distribution can written $$ p(\\sigma^2, \\beta, z \\mid y) = p(\\sigma^2 \\mid y) \\times p(\\beta \\mid \\sigma^2, y) \\times p(z \\mid \\beta, \\sigma^2, y). $$ proceed first sampling \\(\\sigma^2\\) marginal posterior, given samples \\(\\sigma^2\\), sample \\(\\beta\\) subsequently, sample \\(z\\) conditioned posterior samples \\(\\beta\\) \\(\\sigma^2\\) (Banerjee 2020).","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spLMexact.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Univariate Bayesian spatial linear model — spLMexact","text":"Banerjee S (2020). \"Modeling massive spatial datasets using conjugate Bayesian linear modeling framework.\" Spatial Statistics, 37, 100417. ISSN 2211-6753. doi:10.1016/j.spasta.2020.100417 . Vehtari , Simpson D, Gelman , Yao Y, Gabry J (2024). \"Pareto Smoothed Importance Sampling.\" Journal Machine Learning Research, 25(72), 1-58. URL https://jmlr.org/papers/v25/19-556.html.","code":""},{"path":[]},{"path":"https://span-18.github.io/spStack-dev/reference/spLMexact.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Univariate Bayesian spatial linear model — spLMexact","text":"Soumyakanti Pan span18@ucla.edu, Sudipto Banerjee sudipto@ucla.edu","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spLMexact.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Univariate Bayesian spatial linear model — spLMexact","text":"","code":"# load data data(simGaussian) dat <- simGaussian[1:100, ]  # setup prior list muBeta <- c(0, 0) VBeta <- cbind(c(1.0, 0.0), c(0.0, 1.0)) sigmaSqIGa <- 2 sigmaSqIGb <- 0.1 prior_list <- list(beta.norm = list(muBeta, VBeta),                    sigma.sq.ig = c(sigmaSqIGa, sigmaSqIGb))  # supply fixed values of model parameters phi0 <- 3 nu0 <- 0.75 noise.sp.ratio <- 0.8  mod1 <- spLMexact(y ~ x1, data = dat,                   coords = as.matrix(dat[, c(\"s1\", \"s2\")]),                   cor.fn = \"matern\",                   priors = prior_list,                   spParams = list(phi = phi0, nu = nu0),                   noise_sp_ratio = noise.sp.ratio,                   n.samples = 100,                   loopd = TRUE, loopd.method = \"exact\") #> ---------------------------------------- #> \tModel description #> ---------------------------------------- #> Model fit with 100 observations. #>  #> Number of covariates 2 (including intercept). #>  #> Using the matern spatial correlation function. #>  #> Priors: #> \tbeta: Gaussian #> \tmu:\t0.00\t0.00\t #> \tcov: #> \t1.00\t0.00\t #> \t0.00\t1.00\t #>  #> \tsigma.sq: Inverse-Gamma #> \tshape = 2.00, scale = 0.10. #>  #> Spatial process parameters: #> \tphi = 3.00, and, nu = 0.75. #> Noise-to-spatial variance ratio = 0.80. #>  #> Number of posterior samples = 100. #>  #> LOO-PD calculation method = exact. #> ----------------------------------------  beta.post <- mod1$samples$beta z.post.median <- apply(mod1$samples$z, 1, median) dat$z.post.median <- z.post.median plot1 <- surfaceplot(dat, coords_name = c(\"s1\", \"s2\"),                      var_name = \"z_true\") plot2 <- surfaceplot(dat, coords_name = c(\"s1\", \"s2\"),                      var_name = \"z.post.median\") plot1  plot2"},{"path":"https://span-18.github.io/spStack-dev/reference/spLMstack.html","id":null,"dir":"Reference","previous_headings":"","what":"Bayesian spatial linear model using predictive stacking — spLMstack","title":"Bayesian spatial linear model using predictive stacking — spLMstack","text":"Fits Bayesian spatial linear model collection candidate models constructed based candidate values model parameters specified user subsequently combines inference stacking predictive densities. See Zhang, Tang Banerjee (2024) details.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spLMstack.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bayesian spatial linear model using predictive stacking — spLMstack","text":"","code":"spLMstack(   formula,   data = parent.frame(),   coords,   cor.fn,   priors,   params.list,   n.samples,   loopd.method,   parallel = FALSE,   solver = \"ECOS\",   verbose = TRUE,   ... )"},{"path":"https://span-18.github.io/spStack-dev/reference/spLMstack.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bayesian spatial linear model using predictive stacking — spLMstack","text":"formula symbolic description regression model fit. See example . data optional data frame containing variables model. found data, variables taken environment(formula), typically environment spLMstack called. coords \\(n \\times 2\\) matrix observation coordinates \\(\\mathbb{R}^2\\) (e.g., easting northing). cor.fn quoted keyword specifies correlation function used model spatial dependence structure among observations. Supported covariance model key words : 'exponential' 'matern'. See details. priors list tag corresponding parameter name containing prior details. supplied, uses defaults. params.list list containing candidate values spatial process parameters cor.fn used, , noise--spatial variance ratio. n.samples number posterior samples generated. loopd.method character. Valid inputs 'exact' 'PSIS'. option 'exact' corresponds exact leave-one-predictive densities. option 'PSIS' faster, finds approximate leave-one-predictive densities using Pareto-smoothed importance sampling (Gelman et al. 2024). parallel logical. parallel=FALSE, parallelization plan, set user, ignored. parallel=TRUE, function inherits parallelization plan set user via function future::plan() . Depending parallel backend available, users may choose plan. details available https://cran.R-project.org/package=future. solver (optional) Specifies name solver used obtain optimal stacking weights candidate model. Default \"ECOS\". Users can use solvers supported CVXR-package package. verbose logical. TRUE, prints model-specific optimal stacking weights. ... currently additional argument.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spLMstack.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bayesian spatial linear model using predictive stacking — spLMstack","text":"object class spLMstack, list including following tags - samples list length equal total number candidate models entry corresponding list length 3, containing posterior samples fixed effects (beta), variance parameter (sigmaSq), spatial effects (z) model. loopd list length equal total number candidate models entry containing leave-one-predictive densities particular model. n.models number candidate models fit. candidate.models matrix n_model rows row containing details model parameters optimal weight. stacking.weights numeric vector length equal number candidate models storing optimal stacking weights. run.time proc_time object runtime details. solver.status solver status returned optimization routine. return object might include additional data useful subsequent prediction, model fit evaluation utilities.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spLMstack.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Bayesian spatial linear model using predictive stacking — spLMstack","text":"Instead assigning prior process parameters \\(\\phi\\) \\(\\nu\\), noise--spatial variance ratio \\(\\delta^2\\), consider set candidate models based candidate values parameters supplied user. Suppose set candidate models \\(\\mathcal{M} = \\{M_1, \\ldots, M_G\\}\\). \\(g = 1, \\ldots, G\\), sample posterior distribution \\(p(\\sigma^2, \\beta, z \\mid y, M_g)\\) model \\(M_g\\) find leave-one-predictive densities \\(p(y_i \\mid y_{-}, M_g)\\). solve optimization problem $$  \\begin{aligned}  \\max_{w_1, \\ldots, w_G}& \\, \\frac{1}{n} \\sum_{= 1}^n \\log \\sum_{g = 1}^G  w_g p(y_i \\mid y_{-}, M_g) \\\\  \\text{subject } & \\quad w_g \\geq 0, \\sum_{g = 1}^G w_g = 1  \\end{aligned}  $$ find optimal stacking weights \\(\\hat{w}_1, \\ldots, \\hat{w}_G\\).","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spLMstack.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Bayesian spatial linear model using predictive stacking — spLMstack","text":"Vehtari , Simpson D, Gelman , Yao Y, Gabry J (2024). \"Pareto Smoothed Importance Sampling.\" Journal Machine Learning Research, 25(72), 1-58. URL https://jmlr.org/papers/v25/19-556.html. Zhang L, Tang W, Banerjee S (2024). \"Bayesian Geostatistics Using Predictive Stacking.\" doi:10.48550/arXiv.2304.12414 .","code":""},{"path":[]},{"path":"https://span-18.github.io/spStack-dev/reference/spLMstack.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Bayesian spatial linear model using predictive stacking — spLMstack","text":"Soumyakanti Pan span18@ucla.edu, Sudipto Banerjee sudipto@ucla.edu","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spLMstack.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bayesian spatial linear model using predictive stacking — spLMstack","text":"","code":"# load data and work with first 100 rows data(simGaussian) dat <- simGaussian[1:100, ]  # setup prior list muBeta <- c(0, 0) VBeta <- cbind(c(1.0, 0.0), c(0.0, 1.0)) sigmaSqIGa <- 2 sigmaSqIGb <- 2 prior_list <- list(beta.norm = list(muBeta, VBeta),                    sigma.sq.ig = c(sigmaSqIGa, sigmaSqIGb))  mod1 <- spLMstack(y ~ x1, data = dat,                   coords = as.matrix(dat[, c(\"s1\", \"s2\")]),                   cor.fn = \"matern\",                   priors = prior_list,                   params.list = list(phi = c(1.5, 3),                                      nu = c(0.5, 1),                                      noise_sp_ratio = c(1)),                   n.samples = 1000, loopd.method = \"exact\",                   parallel = FALSE, solver = \"ECOS\", verbose = TRUE) #>  #> STACKING WEIGHTS: #>  #>           | phi | nu  | noise_sp_ratio | weight | #> +---------+-----+-----+----------------+--------+ #> | Model 1 |  1.5|  0.5|               1| 0      | #> | Model 2 |  3.0|  0.5|               1| 0      | #> | Model 3 |  1.5|  1.0|               1| 0      | #> | Model 4 |  3.0|  1.0|               1| 1      | #> +---------+-----+-----+----------------+--------+ #>   post_samps <- stackedSampler(mod1) post_beta <- post_samps$beta print(t(apply(post_beta, 1, function(x) quantile(x, c(0.025, 0.5, 0.975))))) #>                  2.5%      50%    97.5% #> (Intercept) 0.8835376 1.710863 2.542696 #> x1          4.7465115 4.921408 5.090629  post_z <- post_samps$z post_z_summ <- t(apply(post_z, 1,                        function(x) quantile(x, c(0.025, 0.5, 0.975))))  z_combn <- data.frame(z = dat$z_true,                       zL = post_z_summ[, 1],                       zM = post_z_summ[, 2],                       zU = post_z_summ[, 3])  library(ggplot2) plot1 <- ggplot(data = z_combn, aes(x = z)) +   geom_point(aes(y = zM), size = 0.25,              color = \"darkblue\", alpha = 0.5) +   geom_errorbar(aes(ymin = zL, ymax = zU),                 width = 0.05, alpha = 0.15) +   geom_abline(slope = 1, intercept = 0,               color = \"red\", linetype = \"solid\") +   xlab(\"True z\") + ylab(\"Stacked posterior of z\") +   theme_bw() +   theme(panel.background = element_blank(),         aspect.ratio = 1)"},{"path":"https://span-18.github.io/spStack-dev/reference/spStack-package.html","id":null,"dir":"Reference","previous_headings":"","what":"spStack: Bayesian Geostatistics Using Predictive Stacking — spStack-package","title":"spStack: Bayesian Geostatistics Using Predictive Stacking — spStack-package","text":"package delivers functions fit Bayesian hierarchical spatial process models point-referenced Gaussian, Poisson, binomial, binary data using stacking predictive densities. involves sampling analytically available posterior distributions conditional upon candidate values spatial process parameters Gaussian response model well non-Gaussian responses, , subsequently assimilate inference individual posterior distributions using Bayesian predictive stacking. algorithm highly parallelizable hence, much faster traditional Markov chain Monte Carlo algorithms delivering competitive predictive performance. context inference spatial point-referenced data, Bayesian hierarchical models involve latent spatial processes characterized spatial process parameters, besides lacking substantive relevance scientific contexts, also weakly identified hence, impedes convergence MCMC algorithms. motivates us build methodology involves fast sampling posterior distributions conditioned grid weakly identified model parameters combine inference stacking predictive densities (Yao et. al 2018). exploit Bayesian conjugate linear modeling framework Gaussian case (Zhang, Tang Banerjee 2024) generalized conjugate multivariate distribution theory (Pan, Zhang, Bradley Banerjee 2024) analytically derive individual posterior distributions.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spStack-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"spStack: Bayesian Geostatistics Using Predictive Stacking — spStack-package","text":"Accepts formula, e.g., y~x1+x2, regression models accompanied candidate values spatial process parameters, returns posterior samples regression coefficients latent spatial random effects. Posterior inference prediction quantity interest proceed samples. Main functions - spLMexact()spGLMexact()spLMstack()spGLMstack()","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spStack-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"spStack: Bayesian Geostatistics Using Predictive Stacking — spStack-package","text":"Zhang L, Tang W, Banerjee S (2024). \"Bayesian Geostatistics Using Predictive Stacking.\" doi:10.48550/arXiv.2304.12414 . Pan S, Zhang L, Bradley JR, Banerjee S (2024). \"Bayesian Inference Spatial-temporal Non-Gaussian Data Using Predictive Stacking.\" doi:10.48550/arXiv.2406.04655 . Yao Y, Vehtari , Simpson D, Gelman (2018). \"Using Stacking Average Bayesian Predictive Distributions (Discussion).\" Bayesian Analysis, 13(3), 917-1007. doi:10.1214/17-BA1091 .","code":""},{"path":[]},{"path":"https://span-18.github.io/spStack-dev/reference/spStack-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"spStack: Bayesian Geostatistics Using Predictive Stacking — spStack-package","text":"Maintainer: Soumyakanti Pan span18@ucla.edu (ORCID) Authors: Sudipto Banerjee sudipto@ucla.edu","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/stackedSampler.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample from the stacked posterior distribution — stackedSampler","title":"Sample from the stacked posterior distribution — stackedSampler","text":"helper function sample stacked posterior distribution obtain final posterior samples can used subsequent analysis. function applies outputs functions spLMstack() spGLMstack().","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/stackedSampler.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample from the stacked posterior distribution — stackedSampler","text":"","code":"stackedSampler(mod_out, n.samples)"},{"path":"https://span-18.github.io/spStack-dev/reference/stackedSampler.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample from the stacked posterior distribution — stackedSampler","text":"mod_out object class spLMstack spGLMstack. n.samples (optional) missing, inherits number posterior samples original output. Otherwise, specifies number posterior samples draw stacked posterior. exceeds number posterior draws used original function, warning thrown samples obtained resampling. recommended, run original function enough samples.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/stackedSampler.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample from the stacked posterior distribution — stackedSampler","text":"object class stacked_posterior, list includes following tags - beta samples fixed effect stacked joint posterior. z samples spatial random effects stacked joint posterior. case model output class spLMstack, list additionally contains sigmaSq samples variance parameter stacked joint posterior spatial linear model. model output class spGLMstack, list also contains xi samples fine-scale variation term stacked joint posterior spatial generalized linear model.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/stackedSampler.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sample from the stacked posterior distribution — stackedSampler","text":"obtaining optimal stacking weights \\(\\hat{w}_1, \\ldots, \\hat{w}_G\\), posterior inference quantities interest subsequently proceed stacked posterior, $$ \\tilde{p}(\\cdot \\mid y) = \\sum_{g = 1}^G \\hat{w}_g p(\\cdot \\mid y, M_g), $$ \\(\\mathcal{M} = \\{M_1, \\ldots, M_g\\}\\) collection candidate models.","code":""},{"path":[]},{"path":"https://span-18.github.io/spStack-dev/reference/stackedSampler.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Sample from the stacked posterior distribution — stackedSampler","text":"Soumyakanti Pan span18@ucla.edu, Sudipto Banerjee sudipto@ucla.edu","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/stackedSampler.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample from the stacked posterior distribution — stackedSampler","text":"","code":"data(simGaussian) dat <- simGaussian[1:100, ]  mod1 <- spLMstack(y ~ x1, data = dat,                   coords = as.matrix(dat[, c(\"s1\", \"s2\")]),                   cor.fn = \"matern\",                   params.list = list(phi = c(1.5, 3),                                      nu = c(0.5, 1),                                      noise_sp_ratio = c(1)),                   n.samples = 1000, loopd.method = \"exact\",                   parallel = FALSE, solver = \"ECOS\", verbose = TRUE) #>  #> STACKING WEIGHTS: #>  #>           | phi | nu  | noise_sp_ratio | weight | #> +---------+-----+-----+----------------+--------+ #> | Model 1 |  1.5|  0.5|               1| 0.000  | #> | Model 2 |  3.0|  0.5|               1| 0.285  | #> | Model 3 |  1.5|  1.0|               1| 0.000  | #> | Model 4 |  3.0|  1.0|               1| 0.715  | #> +---------+-----+-----+----------------+--------+ #>  print(mod1$solver.status) #> [1] \"optimal\" print(mod1$run.time) #>    user  system elapsed  #>   0.334   0.406   0.237   post_samps <- stackedSampler(mod1) post_beta <- post_samps$beta print(t(apply(post_beta, 1, function(x) quantile(x, c(0.025, 0.5, 0.975))))) #>                 2.5%      50%    97.5% #> (Intercept) 1.671868 2.373899 3.038539 #> x1          4.851400 4.976516 5.108664"},{"path":"https://span-18.github.io/spStack-dev/reference/surfaceplot.html","id":null,"dir":"Reference","previous_headings":"","what":"Make a surface plot — surfaceplot","title":"Make a surface plot — surfaceplot","text":"Make surface plot","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/surfaceplot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make a surface plot — surfaceplot","text":"","code":"surfaceplot(tab, coords_name, var_name, h = 8, col.pal, mark_points = FALSE)"},{"path":"https://span-18.github.io/spStack-dev/reference/surfaceplot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make a surface plot — surfaceplot","text":"tab data-frame containing spatial co-ordinates variable plot coords_name name two columns contains co-ordinates points var_name name column containing variable plotted h integer; (optional) controls smoothness spatial interpolation appearing MBA::mba.surf() function. Default 8. col.pal Optional; color palette, preferably divergent, use colorRampPalette function grDevices. Default 'RdYlBu'. mark_points Logical; TRUE, input points marked. Default FALSE.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/surfaceplot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make a surface plot — surfaceplot","text":"ggplot object containing surface plot","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/surfaceplot.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Make a surface plot — surfaceplot","text":"Soumyakanti Pan span18@ucla.edu, Sudipto Banerjee sudipto@ucla.edu","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/surfaceplot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make a surface plot — surfaceplot","text":"","code":"data(simGaussian) plot1 <- surfaceplot(simGaussian, coords_name = c(\"s1\", \"s2\"),                      var_name = \"z_true\") plot1   # try your favourite color palette col.br <- colorRampPalette(c(\"blue\", \"white\", \"red\")) col.br.pal <- col.br(100) plot2 <- surfaceplot(simGaussian, coords_name = c(\"s1\", \"s2\"),                      var_name = \"z_true\", col.pal = col.br.pal) plot2"},{"path":"https://span-18.github.io/spStack-dev/reference/surfaceplot2.html","id":null,"dir":"Reference","previous_headings":"","what":"Make two side-by-side surface plots — surfaceplot2","title":"Make two side-by-side surface plots — surfaceplot2","text":"Make two side--side surface plots, particularly useful towards comparative study two spatial surfaces.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/surfaceplot2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make two side-by-side surface plots — surfaceplot2","text":"","code":"surfaceplot2(   tab,   coords_name,   var1_name,   var2_name,   h = 8,   col.pal,   mark_points = FALSE )"},{"path":"https://span-18.github.io/spStack-dev/reference/surfaceplot2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make two side-by-side surface plots — surfaceplot2","text":"tab data-frame containing spatial co-ordinates variables plot coords_name name two columns contains co-ordinates points var1_name name column containing first variable plotted var2_name name column containing second variable plotted h integer; (optional) controls smoothness spatial interpolation appearing MBA::mba.surf() function. Default 8. col.pal Optional; color palette, preferably divergent, use colorRampPalette function grDevices. Default 'RdYlBu'. mark_points Logical; TRUE, input points marked. Default FALSE.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/surfaceplot2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make two side-by-side surface plots — surfaceplot2","text":"list containing two ggplot objects","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/surfaceplot2.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Make two side-by-side surface plots — surfaceplot2","text":"Soumyakanti Pan span18@ucla.edu, Sudipto Banerjee sudipto@ucla.edu","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/surfaceplot2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make two side-by-side surface plots — surfaceplot2","text":"","code":"data(simGaussian) plots_2 <- surfaceplot2(simGaussian, coords_name = c(\"s1\", \"s2\"),                         var1_name = \"z_true\", var2_name = \"y\") plots_2 #> [[1]]  #>  #> [[2]]  #>"},{"path":"https://span-18.github.io/spStack-dev/news/index.html","id":"spstack-101","dir":"Changelog","previous_headings":"","what":"spStack 1.0.1","title":"spStack 1.0.1","text":"CRAN release: 2024-10-08 Fix memory leak issue.","code":""},{"path":"https://span-18.github.io/spStack-dev/news/index.html","id":"spstack-100","dir":"Changelog","previous_headings":"","what":"spStack 1.0.0","title":"spStack 1.0.0","text":"CRAN release: 2024-10-03 Initial CRAN submission.","code":""}]
