[{"path":"https://span-18.github.io/spStack-dev/articles/posterior-predictive.html","id":"prediction-in-spatial-linear-model","dir":"Articles","previous_headings":"","what":"Prediction in spatial linear model","title":"Posterior Predictive Inference","text":"Define collection candidate parameters fit model using spLMstack(). Define new coordinates, run posteriorPredict(), finally sample stacked posterior. Finally, analyze posterior predictive distributions spatial process well responses corresponding true values order assess well predictions made.","code":"# training and test data sizes n_train <- 150 n_pred <- 50  data(\"simGaussian\") dat_train <- simGaussian[1:n_train, ] dat_pred <- simGaussian[n_train + 1:n_pred, ]  mod1 <- spLMstack(y ~ x1, data = dat_train,                   coords = as.matrix(dat_train[, c(\"s1\", \"s2\")]),                   cor.fn = \"matern\",                   params.list = list(phi = c(1.5, 3, 5),                                      nu = c(0.75, 1.25),                                      noise_sp_ratio = c(0.5, 1, 2)),                   n.samples = 1000, loopd.method = \"psis\",                   parallel = FALSE, solver = \"ECOS\", verbose = TRUE) ##  ## STACKING WEIGHTS: ##  ##            | phi | nu   | noise_sp_ratio | weight | ## +----------+-----+------+----------------+--------+ ## | Model 1  |  1.5|  0.75|             0.5| 0.72   | ## | Model 2  |  3.0|  0.75|             0.5| 0.00   | ## | Model 3  |  5.0|  0.75|             0.5| 0.28   | ## | Model 4  |  1.5|  1.25|             0.5| 0.00   | ## | Model 5  |  3.0|  1.25|             0.5| 0.00   | ## | Model 6  |  5.0|  1.25|             0.5| 0.00   | ## | Model 7  |  1.5|  0.75|             1.0| 0.00   | ## | Model 8  |  3.0|  0.75|             1.0| 0.00   | ## | Model 9  |  5.0|  0.75|             1.0| 0.00   | ## | Model 10 |  1.5|  1.25|             1.0| 0.00   | ## | Model 11 |  3.0|  1.25|             1.0| 0.00   | ## | Model 12 |  5.0|  1.25|             1.0| 0.00   | ## | Model 13 |  1.5|  0.75|             2.0| 0.00   | ## | Model 14 |  3.0|  0.75|             2.0| 0.00   | ## | Model 15 |  5.0|  0.75|             2.0| 0.00   | ## | Model 16 |  1.5|  1.25|             2.0| 0.00   | ## | Model 17 |  3.0|  1.25|             2.0| 0.00   | ## | Model 18 |  5.0|  1.25|             2.0| 0.00   | ## +----------+-----+------+----------------+--------+ sp_pred <- as.matrix(dat_pred[, c(\"s1\", \"s2\")]) X_new <- as.matrix(cbind(rep(1, n_pred), dat_pred$x1)) mod.pred <- posteriorPredict(mod1, coords_new = sp_pred, covars_new = X_new, joint = TRUE) post_samps <- stackedSampler(mod.pred) postpred_z <- post_samps$z.pred post_z_summ <- t(apply(postpred_z, 1, function(x) quantile(x, c(0.025, 0.5, 0.975)))) z_combn <- data.frame(z = dat_pred$z_true, zL = post_z_summ[, 1],                       zM = post_z_summ[, 2], zU = post_z_summ[, 3]) plot_z_summ <- ggplot(data = z_combn, aes(x = z)) +   geom_errorbar(aes(ymin = zL, ymax = zU), alpha = 0.5, color = \"skyblue\") +   geom_point(aes(y = zM), size = 0.5, color = \"darkblue\", alpha = 0.5) +   geom_abline(slope = 1, intercept = 0, color = \"red\", linetype = \"solid\") +   xlab(\"True z1\") + ylab(\"Posterior of z1\") + theme_bw() +   theme(panel.grid = element_blank(), aspect.ratio = 1)  postpred_y <- post_samps$y.pred post_y_summ <- t(apply(postpred_y, 1, function(x) quantile(x, c(0.025, 0.5, 0.975)))) y_combn <- data.frame(y = dat_pred$y, yL = post_y_summ[, 1],                       yM = post_y_summ[, 2], yU = post_y_summ[, 3])  plot_y_summ <- ggplot(data = y_combn, aes(x = y)) +   geom_errorbar(aes(ymin = yL, ymax = yU), alpha = 0.5, color = \"skyblue\") +   geom_point(aes(y = yM), size = 0.5, color = \"darkblue\", alpha = 0.5) +   geom_abline(slope = 1, intercept = 0, color = \"red\", linetype = \"solid\") +   xlab(\"True y\") + ylab(\"Posterior of y\") + theme_bw() +   theme(panel.grid = element_blank(), aspect.ratio = 1)  ggpubr::ggarrange(plot_z_summ, plot_y_summ)"},{"path":"https://span-18.github.io/spStack-dev/articles/posterior-predictive.html","id":"prediction-in-spatial-generalized-linear-model","dir":"Articles","previous_headings":"","what":"Prediction in spatial generalized linear model","title":"Posterior Predictive Inference","text":"Define collection candidate parameters fit model using spGLMstack(). use spatial Poisson count data simPoisson example. Define new coordinates, run posteriorPredict(), finally sample stacked posterior. demonstrate usage, specify joint=FALSE prediction task. Finally, analyze posterior predictive distributions spatial process well responses corresponding true values order assess well predictions made.","code":"# training and test data sizes n_train <- 150 n_pred <- 50  # load spatial Poisson data data(\"simPoisson\") dat_train <- simPoisson[1:n_train, ] dat_pred <- simPoisson[n_train + 1:n_pred, ]  mod1 <- spGLMstack(y ~ x1, data = dat_train, family = \"poisson\",                    coords = as.matrix(dat_train[, c(\"s1\", \"s2\")]), cor.fn = \"matern\",                    params.list = list(phi = c(3, 4, 5), nu = c(0.5, 1.0),                                       boundary = c(0.5)),                    priors = list(nu.beta = 5, nu.z = 5),                    n.samples = 1000,                    loopd.controls = list(method = \"CV\", CV.K = 10, nMC = 500),                    verbose = TRUE) ## Some priors were not supplied. Using defaults. ##  ## STACKING WEIGHTS: ##  ##           | phi | nu  | boundary | weight | ## +---------+-----+-----+----------+--------+ ## | Model 1 |    3|  0.5|       0.5| 0.000  | ## | Model 2 |    4|  0.5|       0.5| 0.000  | ## | Model 3 |    5|  0.5|       0.5| 0.000  | ## | Model 4 |    3|  1.0|       0.5| 0.079  | ## | Model 5 |    4|  1.0|       0.5| 0.000  | ## | Model 6 |    5|  1.0|       0.5| 0.921  | ## +---------+-----+-----+----------+--------+ sp_pred <- as.matrix(dat_pred[, c(\"s1\", \"s2\")]) X_new <- as.matrix(cbind(rep(1, n_pred), dat_pred$x1)) mod.pred <- posteriorPredict(mod1, coords_new = sp_pred, covars_new = X_new, joint = FALSE) post_samps <- stackedSampler(mod.pred) postpred_z <- post_samps$z.pred post_z_summ <- t(apply(postpred_z, 1, function(x) quantile(x, c(0.025, 0.5, 0.975)))) z_combn <- data.frame(z = dat_pred$z_true, zL = post_z_summ[, 1],                       zM = post_z_summ[, 2], zU = post_z_summ[, 3])  plot_z_summ <- ggplot(data = z_combn, aes(x = z)) +   geom_errorbar(aes(ymin = zL, ymax = zU), alpha = 0.5, color = \"skyblue\") +   geom_point(aes(y = zM), size = 0.5, color = \"darkblue\", alpha = 0.5) +   geom_abline(slope = 1, intercept = 0, color = \"red\", linetype = \"solid\") +   xlab(\"True z\") + ylab(\"Posterior predictive of z\") + theme_bw() +   theme(panel.grid = element_blank(), aspect.ratio = 1)  postpred_y <- post_samps$y.pred post_y_summ <- t(apply(postpred_y, 1, function(x) quantile(x, c(0.025, 0.5, 0.975)))) y_combn <- data.frame(y = dat_pred$y, yL = post_y_summ[, 1],                       yM = post_y_summ[, 2], yU = post_y_summ[, 3])  plot_y_summ <- ggplot(data = y_combn, aes(x = y)) +   geom_errorbar(aes(ymin = yL, ymax = yU), alpha = 0.5, color = \"skyblue\") +   geom_point(aes(y = yM), size = 0.5, color = \"darkblue\", alpha = 0.5) +   geom_abline(slope = 1, intercept = 0, color = \"red\", linetype = \"solid\") +   xlab(\"True y\") + ylab(\"Posterior predictive of y\") + theme_bw() +   theme(panel.grid = element_blank(), aspect.ratio = 1)  ggpubr::ggarrange(plot_z_summ, plot_y_summ)"},{"path":"https://span-18.github.io/spStack-dev/articles/posterior-predictive.html","id":"prediction-in-spatially-temporally-varying-coefficients-model","dir":"Articles","previous_headings":"","what":"Prediction in spatially-temporally varying coefficients model","title":"Posterior Predictive Inference","text":"Define collection candidate parameters fit model using stvcGLMstack(). use spatial Poisson count data sim_stvcPoisson example. Define new coordinates, run posteriorPredict(), finally sample stacked posterior. use joint=FALSE particular example. Finally, analyze posterior predictive distributions spatial-temporal process plotting corresponding true values.","code":"# Example 2: Spatial-temporal model with varying coefficients n_train <- 150 n_pred <- 50 data(\"sim_stvcPoisson\") dat <- sim_stvcPoisson[1:(n_train + n_pred), ]  # split dataset into test and train dat_train <- dat[1:n_train, ] dat_pred <- dat[n_train + 1:n_pred, ]  # create list of candidate models (multivariate) mod.list2 <- candidateModels(list(phi_s = list(1, 2, 3),                                   phi_t = list(1, 2, 4),                                   boundary = c(0.5, 0.75)), \"cartesian\")  # fit a spatial-temporal varying coefficient model using predictive stacking mod1 <- stvcGLMstack(y ~ x1 + (x1), data = dat_train, family = \"poisson\",                      sp_coords = as.matrix(dat_train[, c(\"s1\", \"s2\")]),                      time_coords = as.matrix(dat_train[, \"t_coords\"]),                      cor.fn = \"gneiting-decay\",                      process.type = \"multivariate\",                      candidate.models = mod.list2,                      loopd.controls = list(method = \"CV\", CV.K = 10, nMC = 500),                      n.samples = 500) ##  ## STACKING WEIGHTS: ##  ##            | phi_s | phi_t | boundary | weight | ## +----------+-------+-------+----------+--------+ ## | Model 1  |      1|      1|      0.50| 0.000  | ## | Model 2  |      2|      1|      0.50| 0.000  | ## | Model 3  |      3|      1|      0.50| 0.152  | ## | Model 4  |      1|      2|      0.50| 0.000  | ## | Model 5  |      2|      2|      0.50| 0.000  | ## | Model 6  |      3|      2|      0.50| 0.172  | ## | Model 7  |      1|      4|      0.50| 0.000  | ## | Model 8  |      2|      4|      0.50| 0.000  | ## | Model 9  |      3|      4|      0.50| 0.339  | ## | Model 10 |      1|      1|      0.75| 0.000  | ## | Model 11 |      2|      1|      0.75| 0.000  | ## | Model 12 |      3|      1|      0.75| 0.000  | ## | Model 13 |      1|      2|      0.75| 0.000  | ## | Model 14 |      2|      2|      0.75| 0.000  | ## | Model 15 |      3|      2|      0.75| 0.000  | ## | Model 16 |      1|      4|      0.75| 0.000  | ## | Model 17 |      2|      4|      0.75| 0.000  | ## | Model 18 |      3|      4|      0.75| 0.336  | ## +----------+-------+-------+----------+--------+ # prepare new coordinates and covariates for prediction sp_pred <- as.matrix(dat_pred[, c(\"s1\", \"s2\")]) tm_pred <- as.matrix(dat_pred[, \"t_coords\"]) X_new <- as.matrix(cbind(rep(1, n_pred), dat_pred$x1)) mod_pred <- posteriorPredict(mod1,                              coords_new = list(sp = sp_pred, time = tm_pred),                              covars_new = list(fixed = X_new, vc = X_new),                              joint = FALSE)  # sample from the stacked posterior and posterior predictive distribution post_samps <- stackedSampler(mod_pred) postpred_z <- post_samps$z.pred post_z1_summ <- t(apply(postpred_z[1:n_pred,], 1,                         function(x) quantile(x, c(0.025, 0.5, 0.975)))) post_z2_summ <- t(apply(postpred_z[n_pred + 1:n_pred,], 1,                         function(x) quantile(x, c(0.025, 0.5, 0.975))))  z1_combn <- data.frame(z = dat_pred$z1_true, zL = post_z1_summ[, 1],                        zM = post_z1_summ[, 2], zU = post_z1_summ[, 3]) z2_combn <- data.frame(z = dat_pred$z2_true, zL = post_z2_summ[, 1],                        zM = post_z2_summ[, 2], zU = post_z2_summ[, 3])  library(ggplot2) plot_z1_summ <- ggplot(data = z1_combn, aes(x = z)) +   geom_errorbar(aes(ymin = zL, ymax = zU), alpha = 0.5, color = \"skyblue\") +   geom_point(aes(y = zM), size = 0.5, color = \"darkblue\", alpha = 0.5) +   geom_abline(slope = 1, intercept = 0, color = \"red\", linetype = \"solid\") +   xlab(\"True z1\") + ylab(\"Posterior predictive of z1\") + theme_bw() +   theme(panel.grid = element_blank(), aspect.ratio = 1)  plot_z2_summ <- ggplot(data = z2_combn, aes(x = z)) +   geom_errorbar(aes(ymin = zL, ymax = zU), alpha = 0.5, color = \"skyblue\") +   geom_point(aes(y = zM), size = 0.5, color = \"darkblue\", alpha = 0.5) +   geom_abline(slope = 1, intercept = 0, color = \"red\", linetype = \"solid\") +   xlab(\"True z2\") + ylab(\"Posterior predictive of z2\") + theme_bw() +   theme(panel.grid = element_blank(), aspect.ratio = 1)  ggpubr::ggarrange(plot_z1_summ, plot_z2_summ)"},{"path":"https://span-18.github.io/spStack-dev/articles/spStack.html","id":"bayesian-gaussian-spatial-regression-models","dir":"Articles","previous_headings":"","what":"Bayesian Gaussian spatial regression models","title":"spStack: Bayesian Geostatistics Using Predictive Stacking","text":"quick example using lazyloaded synthetic data simGaussian. Step 1. Load library spStack prepare data. split data dat_train dat_pred - train model dat_train subsequently carry posterior predictive inference locations dat_pred. Step 2. Run function spLMstack() - define model formula, input spatial coordinates matrix, specify correlation function, accordingly provide candidate values parameters params.list. argument loopd.method can used specify method used calculation leave-one-predictive densities, existing parallelization plan can used parallel set TRUE, solver argument specifies solver used carry optimization routine get stacking weights. Step 3. Use helper function stackedSampler() sample stacked posterior distribution. samples serve final posterior samples corresponding target model. final output tagged list entry containing posterior samples corresponding parameter. Note: following optional steps required interested posterior predictive inference. (Optional) Step 4. Prepare inputs posterior predictive inference. new spatial coordinates intend carry prediction given sp_pred value covariates new locations given X_new. (Optional) Step 5. Pass output obtained running spLMstack() function posteriorPredict() along new coordinates covariates. (Optional) Step 6. samples posterior predictive distribution obtained, run stackedSampler() obtain samples stacked posterior predictive distribution. Next, analyze well predict responses plotting posterior predictive summaries corresponding true values.  details can found vignettes titled “Spatial Models” “Posterior Predictive Inference”.","code":"library(spStack)  # training and test data sizes n_train <- 100 n_pred <- 50  data(\"simGaussian\") dat_train <- simGaussian[1:n_train, ] dat_pred <- simGaussian[n_train + 1:n_pred, ] mod1 <- spLMstack(y ~ x1, data = dat_train,                   coords = as.matrix(dat_train[, c(\"s1\", \"s2\")]),                   cor.fn = \"matern\",                   params.list = list(phi = c(1.5, 3, 5),                                      nu = c(0.75, 1.25),                                      noise_sp_ratio = c(0.5, 1, 2)),                   n.samples = 1000, loopd.method = \"psis\",                   parallel = FALSE, solver = \"ECOS\", verbose = TRUE) #>  #> STACKING WEIGHTS: #>  #>            | phi | nu   | noise_sp_ratio | weight | #> +----------+-----+------+----------------+--------+ #> | Model 1  |  1.5|  0.75|             0.5| 0.000  | #> | Model 2  |  3.0|  0.75|             0.5| 0.030  | #> | Model 3  |  5.0|  0.75|             0.5| 0.000  | #> | Model 4  |  1.5|  1.25|             0.5| 0.287  | #> | Model 5  |  3.0|  1.25|             0.5| 0.000  | #> | Model 6  |  5.0|  1.25|             0.5| 0.683  | #> | Model 7  |  1.5|  0.75|             1.0| 0.000  | #> | Model 8  |  3.0|  0.75|             1.0| 0.000  | #> | Model 9  |  5.0|  0.75|             1.0| 0.000  | #> | Model 10 |  1.5|  1.25|             1.0| 0.000  | #> | Model 11 |  3.0|  1.25|             1.0| 0.000  | #> | Model 12 |  5.0|  1.25|             1.0| 0.000  | #> | Model 13 |  1.5|  0.75|             2.0| 0.000  | #> | Model 14 |  3.0|  0.75|             2.0| 0.000  | #> | Model 15 |  5.0|  0.75|             2.0| 0.000  | #> | Model 16 |  1.5|  1.25|             2.0| 0.000  | #> | Model 17 |  3.0|  1.25|             2.0| 0.000  | #> | Model 18 |  5.0|  1.25|             2.0| 0.000  | #> +----------+-----+------+----------------+--------+ post_samps <- stackedSampler(mod1) post_beta <- post_samps$beta summary_beta <- t(apply(post_beta, 1, function(x) quantile(x, c(0.025, 0.5, 0.975)))) rownames(summary_beta) <- mod1$X.names print(summary_beta) #>                 2.5%      50%    97.5% #> (Intercept) 1.074093 2.318164 3.193045 #> x1          4.848954 4.975130 5.094167 sp_pred <- as.matrix(dat_pred[, c(\"s1\", \"s2\")]) X_new <- as.matrix(cbind(rep(1, n_pred), dat_pred$x1)) mod.pred <- posteriorPredict(mod1,                              coords_new = sp_pred,                              covars_new = X_new,                              joint = TRUE) postpred_samps <- stackedSampler(mod.pred) postpred_y <- postpred_samps$y.pred post_y_summ <- t(apply(postpred_y, 1, function(x) quantile(x, c(0.025, 0.5, 0.975)))) y_combn <- data.frame(y = dat_pred$y, yL = post_y_summ[, 1],                       yM = post_y_summ[, 2], yU = post_y_summ[, 3]) library(ggplot2) ggplot(data = y_combn, aes(x = y)) +   geom_errorbar(aes(ymin = yL, ymax = yU), color = \"skyblue\") +   geom_point(aes(y = yM), color = \"darkblue\", alpha = 0.5) +   geom_abline(slope = 1, intercept = 0, color = \"red\", linetype = \"solid\") +   xlab(\"True y\") + ylab(\"Posterior predictive of y\") + theme_bw() +   theme(panel.background = element_blank(), aspect.ratio = 1)"},{"path":"https://span-18.github.io/spStack-dev/articles/spStack.html","id":"bayesian-non-gaussian-spatial-regression-models","dir":"Articles","previous_headings":"","what":"Bayesian non-Gaussian spatial regression models","title":"spStack: Bayesian Geostatistics Using Predictive Stacking","text":"workflow spatial generalized linear models similar. quick example using lazyloaded synthetic data simPoisson. Step 1. Prepare data splitting train test sets. Step 2. Run function spGLMstack() specifying family, supplying candidate values spatial process parameters phi nu, boundary adjustment parameter boundary. loopd.controls option can used specify method parameters used calculation leave-one-predictive densities. input list(method = \"CV\", CV.K = 10, nMC = 500) corresponds KK-fold cross-validation K=10K = 10 using 500 Monte Carlo samples calculating predictive density. Step 3. Run stackedSampler() obtain posterior samples stacked posterior analyze output. Note: following optional steps required interested posterior predictive inference. (Optional) Step 4. Prepare inputs posterior predictive inference. (Optional) Step 5. Finally, pass model output function posteriorPredict() (Optional) Step 6. samples posterior predictive distribution obtained, obtain samples stacked posterior predictive distribution using stackedSampler(). , analyze posterior predictive distribution spatial process corresponding true values.","code":"# training and test data sizes n_train <- 100 n_pred <- 50  # load spatial Poisson data data(\"simPoisson\") dat_train <- simPoisson[1:n_train, ] dat_pred <- simPoisson[n_train + 1:n_pred, ] mod1 <- spGLMstack(y ~ x1, data = dat_train, family = \"poisson\",                    coords = as.matrix(dat_train[, c(\"s1\", \"s2\")]), cor.fn = \"matern\",                    params.list = list(phi = c(3, 4, 5), nu = c(0.5, 1.0),                                       boundary = c(0.5)),                    priors = list(nu.beta = 5, nu.z = 5),                    n.samples = 1000,                    loopd.controls = list(method = \"CV\", CV.K = 10, nMC = 500),                    verbose = TRUE) #> Some priors were not supplied. Using defaults. #>  #> STACKING WEIGHTS: #>  #>           | phi | nu  | boundary | weight | #> +---------+-----+-----+----------+--------+ #> | Model 1 |    3|  0.5|       0.5| 0.000  | #> | Model 2 |    4|  0.5|       0.5| 0.000  | #> | Model 3 |    5|  0.5|       0.5| 0.000  | #> | Model 4 |    3|  1.0|       0.5| 0.115  | #> | Model 5 |    4|  1.0|       0.5| 0.357  | #> | Model 6 |    5|  1.0|       0.5| 0.528  | #> +---------+-----+-----+----------+--------+ post_samps <- stackedSampler(mod1)  post_beta <- post_samps$beta summary_beta <- t(apply(post_beta, 1, function(x) quantile(x, c(0.025, 0.5, 0.975)))) rownames(summary_beta) <- mod1$X.names print(summary_beta) #>                   2.5%        50%      97.5% #> (Intercept)  0.8915484  2.0784747  3.3153751 #> x1          -0.6754765 -0.5677041 -0.4517785 sp_pred <- as.matrix(dat_pred[, c(\"s1\", \"s2\")]) X_new <- as.matrix(cbind(rep(1, n_pred), dat_pred$x1)) mod.pred <- posteriorPredict(mod1,                              coords_new = sp_pred,                              covars_new = X_new,                              joint = FALSE) postpred_samps <- stackedSampler(mod.pred) postpred_z <- postpred_samps$z.pred post_z_summ <- t(apply(postpred_z, 1, function(x) quantile(x, c(0.025, 0.5, 0.975)))) z_combn <- data.frame(z = dat_pred$z_true, zL = post_z_summ[, 1],                       zM = post_z_summ[, 2], zU = post_z_summ[, 3]) ggplot(data = z_combn, aes(x = z)) +   geom_errorbar(aes(ymin = zL, ymax = zU), color = \"skyblue\") +   geom_point(aes(y = zM), color = \"darkblue\", alpha = 0.5) +   geom_abline(slope = 1, intercept = 0, color = \"red\", linetype = \"solid\") +   xlab(\"True z\") + ylab(\"Posterior predictive of z\") + theme_bw() +   theme(panel.background = element_blank(), aspect.ratio = 1)"},{"path":"https://span-18.github.io/spStack-dev/articles/spStack.html","id":"additional-functionalities","dir":"Articles","previous_headings":"","what":"Additional functionalities","title":"spStack: Bayesian Geostatistics Using Predictive Stacking","text":"devised demonstrated Bayesian predictive stacking effective tool estimating spatial/spatial-temporal regression models yielding robust predictions Gaussian well non-Gaussian data. develop exploit analytically accessible distribution theory pertaining Bayesian analysis linear mixed model generalized linear mixed models enables us directly sample posterior distributions. focus package effectively combining inference across different closed-form posterior distributions circumventing inference weakly identified parameters. “Technical Overview” vignette provides comprehensive review conjugate Bayesian hierarchical models used . “Spatial Models” “Spatial-Temporal Models” explains detail use functions spatial spatial-temporal regressions, respectively. Future developments investigations consider zero-inflated non-Gaussian data adapting variants Gaussian process models scale inference massive datasets circumventing Cholesky decomposition dense covariance matrices.","code":""},{"path":[]},{"path":"https://span-18.github.io/spStack-dev/articles/spatial-temporal.html","id":"bayesian-non-gaussian-spatially-temporally-varying-coefficient-models","dir":"Articles","previous_headings":"","what":"Bayesian non-Gaussian spatially-temporally varying coefficient models","title":"Spatial-Temporal Regression Models","text":"illustrate spatially-temporally varying coefficient model using synthetic spatial-temporal Poisson count data. first load data sim_stvcPoisson consists data 500 spatial-temporal locations. use first 100 locations following analysis. dataset consists one covariate x1, response variable y, spatial locations given s1 s2, temporal coordinate t_coords, true spatially-temporally varying coefficients z1_true z2_true associated intercept x1, respectively. elaborate .","code":"library(spStack) data(\"sim_stvcPoisson\") n_train <- 100 dat <- sim_stvcPoisson[1:n_train, ] head(dat) ##          s1         s2   t_coords           x1  y    z1_true     z2_true ## 1 0.8458822 0.43458448 0.51451148 -0.766742372 25  2.0451334  1.28806986 ## 2 0.7965761 0.20391526 0.47538393  0.128523505 12  0.3791130  0.06896414 ## 3 0.9182483 0.07049103 0.85633367  1.669250054 12  0.3188769  0.58753365 ## 4 0.8099342 0.99920483 0.51844637  0.988857940 12  1.8994169 -0.66931170 ## 5 0.7379233 0.70276900 0.54693172  1.233493103 28  0.9009137  0.90728556 ## 6 0.4131629 0.08673831 0.04680728  0.004780498  5 -0.6926862 -0.61172092"},{"path":"https://span-18.github.io/spStack-dev/articles/spatial-temporal.html","id":"formula-for-varying-coefficients-model","dir":"Articles","previous_headings":"Bayesian non-Gaussian spatially-temporally varying coefficient models","what":"Formula for varying coefficients model","title":"Spatial-Temporal Regression Models","text":"define spatially-temporally varying coefficients model using formula, similar widely used lm() function stats package. Suppose ℓ=(s,t)\\ell = (s, t) refers space-time ccoordinate. See “Technical Overview details”. , given family = \"poisson\", formula y ~ x1 + (x1) corresponds spatial-temporal generalized linear model y(ℓ)∼𝖯𝗈𝗂𝗌𝗌𝗈𝗇(λ(ℓ)),logλ(ℓ)=β0+β1x1(ℓ)+z1(ℓ)+x1(ℓ)z2(ℓ),y(\\ell) \\sim \\mathsf{Poisson}(\\lambda(\\ell)), \\quad \\log \\lambda(\\ell) = \\beta_0 + \\beta_1 x_1(\\ell) + z_1(\\ell) + x_1(\\ell) z_2(\\ell)\\;, y corresponds response variable y(ℓ)y(\\ell), regressed predictor x1 given x1(ℓ)x_1(\\ell). model variables specified outside parentheses corresponds predictors fixed effects, model inside parentheses correspond variables spatial-temporal varying coefficient. intercept automatically considered within fixed varying coefficient components model, hence y ~ x1 + (x1) functionally equivalent y ~ 1 + x1 + (1 + x1). spatially-temporally varying coefficients z(ℓ)=(z1(ℓ),z2(ℓ))⊤z(\\ell) = (z_1(\\ell), z_2(\\ell))^{{ \\scriptstyle \\top }} multivariate Gaussian process, pursue following specifications z(ℓ)z(\\ell) - independent process, independent process shared parameters, multivariate process. now, support cor.fn=\"gneiting-decay\" covariogram. See “Technical Overview” details. implement model, just spatial-temporal random effect, one may specify formula y ~ x1 + (1) corresponds model y(ℓ)∼𝖯𝗈𝗂𝗌𝗌𝗈𝗇(λ(ℓ)),logλ(ℓ)=β0+β1x1(ℓ)+z1(ℓ).y(\\ell) \\sim \\mathsf{Poisson}(\\lambda(\\ell)), \\quad \\log \\lambda(\\ell) = \\beta_0 + \\beta_1 x_1(\\ell) + z_1(\\ell)\\;.","code":""},{"path":"https://span-18.github.io/spStack-dev/articles/spatial-temporal.html","id":"using-fixed-hyperparameters","dir":"Articles","previous_headings":"Bayesian non-Gaussian spatially-temporally varying coefficient models","what":"Using fixed hyperparameters","title":"Spatial-Temporal Regression Models","text":"use function stvcGLMexact() fit spatially-temporally varying coefficient generalized linear models. following code snippets, demonstrate uasge argument process.Type implement different variations spatial-temporal process specifications varying coefficients.","code":""},{"path":"https://span-18.github.io/spStack-dev/articles/spatial-temporal.html","id":"independent-processes","dir":"Articles","previous_headings":"Bayesian non-Gaussian spatially-temporally varying coefficient models > Using fixed hyperparameters","what":"Independent processes","title":"Spatial-Temporal Regression Models","text":"case, since two independent processes z1(ℓ)z_1(\\ell) z2(ℓ)z_2(\\ell) candidate values spatial-temporal process parameters sptParams list tags phi_s phi_t, tag length 2. , scale parameter σ=(σz12,σz22)⊤\\sigma = (\\sigma^2_{z1}, \\sigma^2_{z2})^{{ \\scriptstyle \\top }} dimension 2. Posterior samples scale parameters can recovered running recoverGLMscale() mod1. visualize posterior distributions scale parameters follows.","code":"mod1 <- stvcGLMexact(y ~ x1 + (x1), data = dat, family = \"poisson\",                      sp_coords = as.matrix(dat[, c(\"s1\", \"s2\")]),                      time_coords = as.matrix(dat[, \"t_coords\"]),                      cor.fn = \"gneiting-decay\",                      process.type = \"independent\",                      priors = list(nu.beta = 5, nu.z = 5),                      sptParams = list(phi_s = c(1, 2), phi_t = c(1, 2)),                      verbose = FALSE, n.samples = 500) ## Some priors were not supplied. Using defaults. mod1 <- recoverGLMscale(mod1) post_scale_df <- data.frame(value = sqrt(c(mod1$samples$z.scale[1, ], mod1$samples$z.scale[2, ])),                             group = factor(rep(c(\"sigma.z1\", \"sigma.z2\"),                                      each = length(mod1$samples$z.scale[1, ])))) library(ggplot2) ggplot(post_scale_df, aes(x = value)) +   geom_density(fill = \"lightblue\", alpha = 0.6) +   facet_wrap(~ group, scales = \"free\") + labs(x = \"\", y = \"Density\") +   theme_bw() + theme(panel.background = element_blank(),                       panel.grid = element_blank(), aspect.ratio = 1)"},{"path":"https://span-18.github.io/spStack-dev/articles/spatial-temporal.html","id":"independent-shared-processes","dir":"Articles","previous_headings":"Bayesian non-Gaussian spatially-temporally varying coefficient models > Using fixed hyperparameters","what":"Independent shared processes","title":"Spatial-Temporal Regression Models","text":"case, processes z1(ℓ)z_1(\\ell) z2(ℓ)z_2(\\ell) independent share common covariance matrix. Hence, sptParams list tags phi_s phi_t, tag length 1. , scale parameter σ=σz2\\sigma = \\sigma_z^2 1-dimensional. Posterior samples scale parameters can recovered running recoverGLMscale() mod2. visualize posterior distributions scale parameters follows.","code":"mod2 <- stvcGLMexact(y ~ x1 + (x1), data = dat, family = \"poisson\",                      sp_coords = as.matrix(dat[, c(\"s1\", \"s2\")]),                      time_coords = as.matrix(dat[, \"t_coords\"]),                      cor.fn = \"gneiting-decay\",                      process.type = \"independent.shared\",                      priors = list(nu.beta = 5, nu.z = 5),                      sptParams = list(phi_s = 1, phi_t = 1),                      verbose = FALSE, n.samples = 500) ## Some priors were not supplied. Using defaults. mod2 <- recoverGLMscale(mod2) post_scale_df <- data.frame(value = sqrt(mod2$samples$z.scale),                              group = factor(rep(c(\"sigma.z\"),                                                 each = length(mod2$samples$z.scale)))) ggplot(post_scale_df, aes(x = value)) +   geom_density(fill = \"lightblue\", alpha = 0.6) +   facet_wrap(~ group, scales = \"free\") + labs(x = \"\", y = \"Density\") +   theme_bw() + theme(panel.background = element_blank(),                       panel.grid = element_blank(), aspect.ratio = 1)"},{"path":"https://span-18.github.io/spStack-dev/articles/spatial-temporal.html","id":"multivariate-processes","dir":"Articles","previous_headings":"Bayesian non-Gaussian spatially-temporally varying coefficient models > Using fixed hyperparameters","what":"Multivariate processes","title":"Spatial-Temporal Regression Models","text":"case, z(ℓ)=(z1(ℓ),z2(ℓ))⊤z(\\ell) = (z_1(\\ell), z_2(\\ell))^{{ \\scriptstyle \\top }} 2-dimensional Gaussian process covariance matrix Σ\\Sigma. , put inverse-Wishart prior Σ\\Sigma, can specified priors argument. supplied, uses default IW(νz+2r,Ir)\\mathrm{IW}(\\nu_z + 2r, I_r), r=2r = 2 dimension multivariate process. , sptParams list tags phi_s phi_t, tag length 1, scale parameter σ=Σ\\sigma = \\Sigma 2×22 \\times 2 matrix. Posterior samples scale parameters can recovered running recoverGLMscale() mod3. visualize posterior distribution scale matrix Σ\\Sigma follows. Posterior distributions elements scale matrix.","code":"mod3 <- stvcGLMexact(y ~ x1 + (x1), data = dat, family = \"poisson\",                      sp_coords = as.matrix(dat[, c(\"s1\", \"s2\")]),                      time_coords = as.matrix(dat[, \"t_coords\"]),                      cor.fn = \"gneiting-decay\",                      process.type = \"multivariate\",                      priors = list(nu.beta = 5, nu.z = 5),                      sptParams = list(phi_s = 1, phi_t = 1),                      verbose = FALSE, n.samples = 500) ## Some priors were not supplied. Using defaults. mod3 <- recoverGLMscale(mod3) post_scale_z <- mod3$samples$z.scale  r <- sqrt(dim(post_scale_z)[1]) # Function to get (i,j) index from row number (column-major) get_indices <- function(k, r) {   j <- ((k - 1) %/% r) + 1   i <- ((k - 1) %% r) + 1   c(i, j) }  # Generate plots into a matrix plot_matrix <- matrix(vector(\"list\", r * r), nrow = r, ncol = r) for (k in 1:(r^2)) {   ij <- get_indices(k, r)   i <- ij[1]   j <- ij[2]      if (i >= j) {     df <- data.frame(value = post_scale_z[k, ])     p <- ggplot(df, aes(x = value)) +       geom_density(fill = \"lightblue\", alpha = 0.7) +       theme_bw(base_size = 9) +       labs(title = bquote(Sigma[.(i) * .(j)])) +       theme(axis.title = element_blank(), axis.text = element_text(size = 6),         plot.title = element_text(size = 9, hjust = 0.5),         panel.grid = element_blank(), aspect.ratio = 1)   } else {     p <- ggplot() + theme_void()   }      plot_matrix[j, i] <- list(p) }  library(patchwork) # Assemble with patchwork final_plot <- wrap_plots(plot_matrix, nrow = r) final_plot"},{"path":"https://span-18.github.io/spStack-dev/articles/spatial-temporal.html","id":"using-predictive-stacking","dir":"Articles","previous_headings":"Bayesian non-Gaussian spatially-temporally varying coefficient models","what":"Using predictive stacking","title":"Spatial-Temporal Regression Models","text":"implementing predictive stacking spatially-temporally varying models, offer helper function candidateModels() create collection candidate models. grid candidate values can combined either using Cartesian product simple element--element combination. demonstrate stacking based multivariate spatial-temporal process model. Step 1. Create candidate models. Step 2. Run stvcGLMstack(). Step 3. Recover posterior samples scale parameters. Step 4. Sample stacked posterior distribution. Now, analyze posterior distribution latent process obtained stacked posterior.  Next, analyze posterior distribution scale matrix models inter-process dependence structure. Stacked posterior distribution elements inter-process covariance matrix.","code":"mod.list <- candidateModels(list(   phi_s = list(1, 2, 3),   phi_t = list(1, 2, 4),   boundary = c(0.5, 0.75)), \"cartesian\") mod1 <- stvcGLMstack(y ~ x1 + (x1), data = dat, family = \"poisson\",                      sp_coords = as.matrix(dat[, c(\"s1\", \"s2\")]),                      time_coords = as.matrix(dat[, \"t_coords\"]),                      cor.fn = \"gneiting-decay\",                      process.type = \"multivariate\",                      priors = list(nu.beta = 5, nu.z = 5),                      candidate.models = mod.list,                      loopd.controls = list(method = \"CV\", CV.K = 10, nMC = 500),                      n.samples = 1000) ## Some priors were not supplied. Using defaults. ##  ## STACKING WEIGHTS: ##  ##            | phi_s | phi_t | boundary | weight | ## +----------+-------+-------+----------+--------+ ## | Model 1  |      1|      1|      0.50| 0.000  | ## | Model 2  |      2|      1|      0.50| 0.000  | ## | Model 3  |      3|      1|      0.50| 0.091  | ## | Model 4  |      1|      2|      0.50| 0.000  | ## | Model 5  |      2|      2|      0.50| 0.000  | ## | Model 6  |      3|      2|      0.50| 0.000  | ## | Model 7  |      1|      4|      0.50| 0.000  | ## | Model 8  |      2|      4|      0.50| 0.000  | ## | Model 9  |      3|      4|      0.50| 0.411  | ## | Model 10 |      1|      1|      0.75| 0.000  | ## | Model 11 |      2|      1|      0.75| 0.000  | ## | Model 12 |      3|      1|      0.75| 0.000  | ## | Model 13 |      1|      2|      0.75| 0.000  | ## | Model 14 |      2|      2|      0.75| 0.000  | ## | Model 15 |      3|      2|      0.75| 0.255  | ## | Model 16 |      1|      4|      0.75| 0.000  | ## | Model 17 |      2|      4|      0.75| 0.213  | ## | Model 18 |      3|      4|      0.75| 0.031  | ## +----------+-------+-------+----------+--------+ mod1 <- recoverGLMscale(mod1) post_samps <- stackedSampler(mod1) post_z <- post_samps$z  post_z1_summ <- t(apply(post_z[1:n_train,], 1,                         function(x) quantile(x, c(0.025, 0.5, 0.975)))) post_z2_summ <- t(apply(post_z[n_train + 1:n_train,], 1,                         function(x) quantile(x, c(0.025, 0.5, 0.975))))  z1_combn <- data.frame(z = dat$z1_true, zL = post_z1_summ[, 1],                        zM = post_z1_summ[, 2], zU = post_z1_summ[, 3]) z2_combn <- data.frame(z = dat$z2_true, zL = post_z2_summ[, 1],                        zM = post_z2_summ[, 2], zU = post_z2_summ[, 3])  plot_z1_summ <- ggplot(data = z1_combn, aes(x = z)) +   geom_errorbar(aes(ymin = zL, ymax = zU), alpha = 0.5, color = \"skyblue\") +   geom_point(aes(y = zM), size = 0.5, color = \"darkblue\", alpha = 0.5) +   geom_abline(slope = 1, intercept = 0, color = \"red\", linetype = \"solid\") +   xlab(\"True z1\") + ylab(\"Posterior of z1\") + theme_bw() +   theme(panel.grid = element_blank(), aspect.ratio = 1)  plot_z2_summ <- ggplot(data = z2_combn, aes(x = z)) +   geom_errorbar(aes(ymin = zL, ymax = zU), alpha = 0.5, color = \"skyblue\") +   geom_point(aes(y = zM), size = 0.5, color = \"darkblue\", alpha = 0.5) +   geom_abline(slope = 1, intercept = 0, color = \"red\", linetype = \"solid\") +   xlab(\"True z2\") + ylab(\"Posterior of z2\") + theme_bw() +   theme(panel.grid = element_blank(), aspect.ratio = 1)  ggpubr::ggarrange(plot_z1_summ, plot_z2_summ) post_scale_z <- post_samps$z.scale r <- sqrt(dim(post_scale_z)[1]) # Generate plots into a matrix plot_matrix <- matrix(vector(\"list\", r * r), nrow = r, ncol = r) for (k in 1:(r^2)) {   ij <- get_indices(k, r)   i <- ij[1]   j <- ij[2]      if (i >= j) {     df <- data.frame(value = post_scale_z[k, ])     p <- ggplot(df, aes(x = value)) +       geom_density(fill = \"lightblue\", alpha = 0.7) +       theme_bw(base_size = 9) +       labs(title = bquote(Sigma[.(i) * .(j)])) +       theme(axis.title = element_blank(), axis.text = element_text(size = 6),         plot.title = element_text(size = 9, hjust = 0.5),         panel.grid = element_blank(), aspect.ratio = 1)   } else {     p <- ggplot() + theme_void()   }      plot_matrix[j, i] <- list(p) }  # Assemble with patchwork final_plot <- wrap_plots(plot_matrix, nrow = r) final_plot"},{"path":"https://span-18.github.io/spStack-dev/articles/spatial.html","id":"bayesian-gaussian-spatial-regression-models","dir":"Articles","previous_headings":"","what":"Bayesian Gaussian spatial regression models","title":"Spatial Regression Models","text":"section, thoroughly illustrate method synthetic Gaussian well non-Gaussian spatial data provide code analyze output functions. start loading package. synthetic spatial data lazy-loaded includes synthetic spatial Gaussian data simGaussian, Poisson data simPoisson, binomial data simBinom binary data simBinary. One can use function sim_spData() simulate spatial data. applying functions datasets.","code":"library(spStack)"},{"path":"https://span-18.github.io/spStack-dev/articles/spatial.html","id":"using-fixed-hyperparameters","dir":"Articles","previous_headings":"Bayesian Gaussian spatial regression models","what":"Using fixed hyperparameters","title":"Spatial Regression Models","text":"first load data simGaussian set priors. Supplying priors optional. See documentation spLMexact() learn default priors. Besides, setting priors, also fix values spatial process parameters (spatial decay ϕ\\phi smoothness ν\\nu) noise--spatial variance ratio (δ2\\delta^2). define spatial model using formula, similar widely used lm() function stats package. , formula y ~ x1 corresponds spatial linear model y(s)=β0+β1x1(s)+z(s)+ϵ(s),y(s) = \\beta_0 + \\beta_1 x_1(s) + z(s) + \\epsilon(s)\\;, y corresponds response variable y(s)y(s), regressed predictor x1 given x1(s)x_1(s). intercept automatically considered within model, hence y ~ x1 functionally equivalent y ~ 1 + x1. Moreover, spatial random effect inherent model, spatial correlation matrix governed spatial correlation function specified argument cor.fn. Supported correlation functions \"exponential\" \"matern\". exponential covariogram specified hyperparameter ϕ\\phi Matern covariogram specified hyperparameters ϕ\\phi ν\\nu. Fixed values hyperparameters supplied argument spParams. addition, noise--spatial variance ration also fixed argument noise_sp_ratio. interested calculation leave-one-predictive densities (LOO-PD), loopd must set TRUE (default FALSE). Method LOO-PD calculation can also set option loopd.method support keywords \"exact\" \"psis\". option \"exact\" exploits analytically available expressions predictive density implements efficient row-deletion Cholesky factor update fast calculation avoids refitting model nn times, nn sample size. hand, \"psis\" implements Pareto-smoothed importance sampling finds approximate LOO-PD much faster \"exact\". pass arguments function spLMexact(). Next, can summarize posterior samples fixed effects follows.","code":"data(\"simGaussian\") dat <- simGaussian[1:200, ] # work with first 200 rows  muBeta <- c(0, 0) VBeta <- cbind(c(1E4, 0.0), c(0.0, 1E4)) sigmaSqIGa <- 2 sigmaSqIGb <- 2 phi0 <- 3 nu0 <- 0.5 noise_sp_ratio <- 0.8 prior_list <- list(beta.norm = list(muBeta, VBeta),                    sigma.sq.ig = c(sigmaSqIGa, sigmaSqIGb)) nSamples <- 1000 mod1 <- spLMexact(y ~ x1, data = dat,                   coords = as.matrix(dat[, c(\"s1\", \"s2\")]),                   cor.fn = \"matern\",                   priors = prior_list,                   spParams = list(phi = phi0, nu = nu0),                   noise_sp_ratio = noise_sp_ratio, n.samples = nSamples,                   loopd = TRUE, loopd.method = \"exact\",                   verbose = TRUE) #> ---------------------------------------- #>  Model description #> ---------------------------------------- #> Model fit with 200 observations. #>  #> Number of covariates 2 (including intercept). #>  #> Using the matern spatial correlation function. #>  #> Priors: #>  beta: Gaussian #>  mu: 0.00    0.00     #>  cov: #>   10000.00    0.00    #>   0.00    10000.00    #>  #>  sigma.sq: Inverse-Gamma #>  shape = 2.00, scale = 2.00. #>  #> Spatial process parameters: #>  phi = 3.00, and, nu = 0.50. #> Noise-to-spatial variance ratio = 0.80. #>  #> Number of posterior samples = 1000. #>  #> LOO-PD calculation method = exact. #> ---------------------------------------- post_beta <- mod1$samples$beta summary_beta <- t(apply(post_beta, 1, function(x) quantile(x, c(0.025, 0.5, 0.975)))) rownames(summary_beta) <- mod1$X.names print(summary_beta) #>                 2.5%      50%    97.5% #> (Intercept) 1.688957 2.284946 2.955524 #> x1          4.866534 4.954401 5.040862"},{"path":"https://span-18.github.io/spStack-dev/articles/spatial.html","id":"leave-one-out-predictive-densities-using-psis","dir":"Articles","previous_headings":"Bayesian Gaussian spatial regression models","what":"Leave-one-out predictive densities using PSIS","title":"Spatial Regression Models","text":"curiosity, find LOO-PD model using approximate method uses Pareto-smoothed importance sampling, PSIS. See Vehtari, Gelman, Gabry (2017) details. Subsquently, compare LOO-PD obtained two methods.","code":"mod2 <- spLMexact(y ~ x1, data = dat,                   coords = as.matrix(dat[, c(\"s1\", \"s2\")]),                   cor.fn = \"matern\",                   priors = prior_list,                   spParams = list(phi = phi0, nu = nu0),                   noise_sp_ratio = noise_sp_ratio, n.samples = nSamples,                   loopd = TRUE, loopd.method = \"PSIS\",                   verbose = FALSE) loopd_exact <- mod1$loopd loopd_psis <- mod2$loopd loopd_df <- data.frame(exact = loopd_exact, psis = loopd_psis)  library(ggplot2) plot1 <- ggplot(data = loopd_df, aes(x = exact)) +   geom_point(aes(y = psis), size = 1, alpha = 0.5) +   geom_abline(slope = 1, intercept = 0, color = \"red\", alpha = 0.5) +   xlab(\"Exact\") + ylab(\"PSIS\") + theme_bw() +   theme(panel.background = element_blank(),          panel.grid = element_blank(), aspect.ratio = 1) plot1"},{"path":"https://span-18.github.io/spStack-dev/articles/spatial.html","id":"using-predictive-stacking","dir":"Articles","previous_headings":"Bayesian Gaussian spatial regression models","what":"Using predictive stacking","title":"Spatial Regression Models","text":"Next, move Bayesian spatial stacking algorithm Gaussian data. supply prior list provide candidate values spatial process parameters noise--spatial variance ratio. user can check solver status runtime issuing following.","code":"mod3 <- spLMstack(y ~ x1, data = dat,                   coords = as.matrix(dat[, c(\"s1\", \"s2\")]),                   cor.fn = \"matern\",                   priors = prior_list,                   params.list = list(phi = c(1.5, 3, 5),                                      nu = c(0.5, 1, 1.5),                                      noise_sp_ratio = c(0.5, 1.5)),                   n.samples = 1000, loopd.method = \"exact\",                   parallel = FALSE, solver = \"ECOS\", verbose = TRUE) #>  #> STACKING WEIGHTS: #>  #>            | phi | nu  | noise_sp_ratio | weight | #> +----------+-----+-----+----------------+--------+ #> | Model 1  |  1.5|  0.5|             0.5| 0.000  | #> | Model 2  |  3.0|  0.5|             0.5| 0.000  | #> | Model 3  |  5.0|  0.5|             0.5| 0.000  | #> | Model 4  |  1.5|  1.0|             0.5| 0.242  | #> | Model 5  |  3.0|  1.0|             0.5| 0.000  | #> | Model 6  |  5.0|  1.0|             0.5| 0.751  | #> | Model 7  |  1.5|  1.5|             0.5| 0.000  | #> | Model 8  |  3.0|  1.5|             0.5| 0.000  | #> | Model 9  |  5.0|  1.5|             0.5| 0.000  | #> | Model 10 |  1.5|  0.5|             1.5| 0.000  | #> | Model 11 |  3.0|  0.5|             1.5| 0.000  | #> | Model 12 |  5.0|  0.5|             1.5| 0.000  | #> | Model 13 |  1.5|  1.0|             1.5| 0.000  | #> | Model 14 |  3.0|  1.0|             1.5| 0.000  | #> | Model 15 |  5.0|  1.0|             1.5| 0.006  | #> | Model 16 |  1.5|  1.5|             1.5| 0.000  | #> | Model 17 |  3.0|  1.5|             1.5| 0.000  | #> | Model 18 |  5.0|  1.5|             1.5| 0.000  | #> +----------+-----+-----+----------------+--------+ print(mod3$solver.status) #> [1] \"optimal\" print(mod3$run.time) #>    user  system elapsed  #>   2.340   2.801   1.647"},{"path":"https://span-18.github.io/spStack-dev/articles/spatial.html","id":"analyzing-samples-from-the-stacked-posterior","dir":"Articles","previous_headings":"Bayesian Gaussian spatial regression models","what":"Analyzing samples from the stacked posterior","title":"Spatial Regression Models","text":"sample stacked posterior, package provides helper function called stackedSampler(). Subsequent inference proceeds samples obtained stacked posterior. collect samples fixed effects summarize follows. synthetic data simGaussian simulated using true value β=(2,5)⊤\\beta = (2, 5)^{ \\scriptstyle \\top }. notice stacked posterior concentrated around truth.  Furthermore, compare posterior samples spatial random effects corresponding true values.  package also provides helper functions plot interpolated spatial surfaces order visualization purposes. function surfaceplot() creates single spatial surface plot, surfaceplot2() creates two side--side surface plots. using later visually inspect interpolated spatial surfaces true spatial effects posterior medians.","code":"post_samps <- stackedSampler(mod3) post_beta <- post_samps$beta summary_beta <- t(apply(post_beta, 1, function(x) quantile(x, c(0.025, 0.5, 0.975)))) rownames(summary_beta) <- mod3$X.names print(summary_beta) #>                 2.5%      50%    97.5% #> (Intercept) 1.032605 2.215743 3.115782 #> x1          4.871351 4.949397 5.029925 library(tidyr) library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union  post_beta_df <- as.data.frame(post_beta) post_beta_df <- post_beta_df %>%   mutate(row = paste0(\"beta\", row_number()-1)) %>%   pivot_longer(-row, names_to = \"sample\", values_to = \"value\")  # True values of beta0 and beta1 truth <- data.frame(row = c(\"beta0\", \"beta1\"), true_value = c(2, 5))  ggplot(post_beta_df, aes(x = value)) +   geom_density(fill = \"lightblue\", alpha = 0.6) +   geom_vline(data = truth, aes(xintercept = true_value),               color = \"red\", linetype = \"dashed\", linewidth = 0.5) +   facet_wrap(~ row, scales = \"free\") + labs(x = \"\", y = \"Density\") +   theme_bw() + theme(panel.background = element_blank(),                       panel.grid = element_blank(), aspect.ratio = 1) post_z <- post_samps$z post_z_summ <- t(apply(post_z, 1, function(x) quantile(x, c(0.025, 0.5, 0.975)))) z_combn <- data.frame(z = dat$z_true, zL = post_z_summ[, 1],                       zM = post_z_summ[, 2], zU = post_z_summ[, 3])  plotz <- ggplot(data = z_combn, aes(x = z)) +   geom_point(aes(y = zM), size = 0.75, color = \"darkblue\", alpha = 0.5) +   geom_errorbar(aes(ymin = zL, ymax = zU), width = 0.05, alpha = 0.15,                 color = \"skyblue\") +   geom_abline(slope = 1, intercept = 0, color = \"red\") +   xlab(\"True z\") + ylab(\"Stacked posterior of z\") + theme_bw() +   theme(panel.background = element_blank(),          panel.grid = element_blank(), aspect.ratio = 1) plotz postmedian_z <- apply(post_z, 1, median) dat$z_hat <- postmedian_z plot_z <- surfaceplot2(dat, coords_name = c(\"s1\", \"s2\"),                        var1_name = \"z_true\", var2_name = \"z_hat\") library(ggpubr) ggarrange(plotlist = plot_z, common.legend = TRUE, legend = \"right\")"},{"path":"https://span-18.github.io/spStack-dev/articles/spatial.html","id":"analysis-of-spatial-non-gaussian-data","dir":"Articles","previous_headings":"Bayesian Gaussian spatial regression models","what":"Analysis of spatial non-Gaussian data","title":"Spatial Regression Models","text":"also offer functions Bayesian analysis spatially point-referenced Poisson, binomial count, binary data.","code":""},{"path":"https://span-18.github.io/spStack-dev/articles/spatial.html","id":"spatial-poisson-count-data","dir":"Articles","previous_headings":"Bayesian Gaussian spatial regression models > Analysis of spatial non-Gaussian data","what":"Spatial Poisson count data","title":"Spatial Regression Models","text":"first load plot point-referenced Poisson count data.","code":"data(\"simPoisson\") dat <- simPoisson[1:200, ] # work with first 200 observations  ggplot(dat, aes(x = s1, y = s2)) +   geom_point(aes(color = y), alpha = 0.75) +   scale_color_distiller(palette = \"RdYlGn\", direction = -1,                         label = function(x) sprintf(\"%.0f\", x)) +   guides(alpha = 'none') + theme_bw() +   theme(axis.ticks = element_line(linewidth = 0.25),         panel.background = element_blank(), panel.grid = element_blank(),         legend.title = element_text(size = 10, hjust = 0.25),         legend.box.just = \"center\", aspect.ratio = 1)"},{"path":"https://span-18.github.io/spStack-dev/articles/spatial.html","id":"under-fixed-hyperparameters","dir":"Articles","previous_headings":"Bayesian Gaussian spatial regression models > Analysis of spatial non-Gaussian data","what":"Under fixed hyperparameters","title":"Spatial Regression Models","text":"Next, demonstrate function spGLMexact() delivers posterior samples fixed effects spatial random effects. option family must specified correctly using function. instance, following example, formula y ~ x1 family = \"poisson\" corresponds spatial regression model y(s)∼𝖯𝗈𝗂𝗌𝗌𝗈𝗇(λ(s)),logλ(s)=β0+β1x1(s)+z(s).y(s) \\sim \\mathsf{Poisson} (\\lambda(s)), \\quad \\log \\lambda(s) = \\beta_0 + \\beta_1 x_1(s) + z(s)\\;. provide fixed values spatial process parameters boundary adjustment parameter, given argument boundary, supplied, defaults 0.5. details priors default value, see function documentation. next collect samples fixed effects summarize . true value fixed effects data simulated β=(2,−0.5)\\beta = (2, -0.5) (details, see documentation data simPoisson).","code":"mod1 <- spGLMexact(y ~ x1, data = dat, family = \"poisson\",                    coords = as.matrix(dat[, c(\"s1\", \"s2\")]), cor.fn = \"matern\",                    spParams = list(phi = phi0, nu = nu0),                    priors = list(nu.beta = 5, nu.z = 5),                    boundary = 0.5,                    n.samples = 1000, verbose = TRUE) #> Some priors were not supplied. Using defaults. #> ---------------------------------------- #>  Model description #> ---------------------------------------- #> Model fit with 200 observations. #>  #> Family = poisson. #>  #> Number of covariates 2 (including intercept). #>  #> Using the matern spatial correlation function. #>  #> Priors: #>  beta: Gaussian #>  mu: 0.00    0.00     #>  cov: #>   100.00  0.00    #>   0.00    100.00  #>  #>  sigmaSq.beta ~ IG(nu.beta/2, nu.beta/2) #>  sigmaSq.z ~ IG(nu.z/2, nu.z/2) #>  nu.beta = 5.00, nu.z = 5.00. #>  sigmaSq.xi = 0.10. #>  Boundary adjustment parameter = 0.50. #>  #> Spatial process parameters: #>  phi = 3.00, and, nu = 0.50. #>  #> Number of posterior samples = 1000. #> ---------------------------------------- post_beta <- mod1$samples$beta summary_beta <- t(apply(post_beta, 1, function(x) quantile(x, c(0.025, 0.5, 0.975)))) rownames(summary_beta) <- mod1$X.names print(summary_beta) #>                   2.5%        50%      97.5% #> (Intercept)  0.7922293  2.0457547  3.1933523 #> x1          -0.6452358 -0.5501015 -0.4520658"},{"path":"https://span-18.github.io/spStack-dev/articles/spatial.html","id":"posterior-recovery-of-scale-parameters","dir":"Articles","previous_headings":"Bayesian Gaussian spatial regression models > Analysis of spatial non-Gaussian data","what":"Posterior recovery of scale parameters","title":"Spatial Regression Models","text":"analytic tractability posterior distribution 𝖦𝖢𝖬\\mathsf{GCM} framework enabled marginalizing scale parameters σβ2\\sigma^2_\\beta σz2\\sigma^2_z associated fixed effects β\\beta spatial random effects zz, respectively. However, posterior samples σβ2\\sigma^2_\\beta σz2\\sigma^2_z can recovered using function recoverGLMscale(). visualize posterior distributions σβ\\sigma_\\beta σz\\sigma_z histograms.","code":"mod1 <- recoverGLMscale(mod1) post_scale_df <- data.frame(value = sqrt(c(mod1$samples$sigmasq.beta, mod1$samples$sigmasq.z)),                             group = factor(rep(c(\"sigma.beta\", \"sigma.z\"),                                      each = length(mod1$samples$sigmasq.beta)))) ggplot(post_scale_df, aes(x = value)) +   geom_density(fill = \"lightblue\", alpha = 0.6) +   facet_wrap(~ group, scales = \"free\") + labs(x = \"\", y = \"Density\") +   theme_bw() + theme(panel.background = element_blank(),                       panel.grid = element_blank(), aspect.ratio = 1)"},{"path":"https://span-18.github.io/spStack-dev/articles/spatial.html","id":"using-predictive-stacking-1","dir":"Articles","previous_headings":"Bayesian Gaussian spatial regression models > Analysis of spatial non-Gaussian data","what":"Using predictive stacking","title":"Spatial Regression Models","text":"Next, move function spGLMstack() implement proposed stacking algorithm. argument loopd.controls used provide details algorithm used find LOO-PD. Valid options tag method \"exact\" \"CV\". use KK-fold cross-validation assigning method = \"CV\"CV.K = 10. tag nMC decides number Monte Carlo samples used find LOO-PD. can extract information solver status runtime following. , can recover posterior samples scale parameters passing output obtained running spGLMstack() recoverGLMscale().","code":"mod2 <- spGLMstack(y ~ x1, data = dat, family = \"poisson\",                    coords = as.matrix(dat[, c(\"s1\", \"s2\")]), cor.fn = \"matern\",                    params.list = list(phi = c(3, 7, 10), nu = c(0.5, 1.5),                                       boundary = c(0.5, 0.6)),                    n.samples = 1000, priors = list(mu.beta = 5, nu.z = 5),                    loopd.controls = list(method = \"CV\", CV.K = 10, nMC = 1000),                    parallel = TRUE, solver = \"ECOS\", verbose = TRUE) #> Some priors were not supplied. Using defaults. #>  #> STACKING WEIGHTS: #>  #>            | phi | nu  | boundary | weight | #> +----------+-----+-----+----------+--------+ #> | Model 1  |    3|  0.5|       0.5| 0.000  | #> | Model 2  |    7|  0.5|       0.5| 0.000  | #> | Model 3  |   10|  0.5|       0.5| 0.000  | #> | Model 4  |    3|  1.5|       0.5| 0.000  | #> | Model 5  |    7|  1.5|       0.5| 0.000  | #> | Model 6  |   10|  1.5|       0.5| 0.000  | #> | Model 7  |    3|  0.5|       0.6| 0.000  | #> | Model 8  |    7|  0.5|       0.6| 0.000  | #> | Model 9  |   10|  0.5|       0.6| 0.000  | #> | Model 10 |    3|  1.5|       0.6| 0.005  | #> | Model 11 |    7|  1.5|       0.6| 0.724  | #> | Model 12 |   10|  1.5|       0.6| 0.272  | #> +----------+-----+-----+----------+--------+ print(mod2$solver.status) #> [1] \"optimal\" print(mod2$run.time) #>    user  system elapsed  #>  24.564  35.270  15.139 mod2 <- recoverGLMscale(mod2)"},{"path":"https://span-18.github.io/spStack-dev/articles/spatial.html","id":"sampling-from-stacked-posterior","dir":"Articles","previous_headings":"Bayesian Gaussian spatial regression models > Analysis of spatial non-Gaussian data","what":"Sampling from stacked posterior","title":"Spatial Regression Models","text":"first obtain final posterior samples sampling stacked sampler. Subsequently, summarize posterior samples fixed effects. synthetic data simPoisson simulated using β=(2,−0.5)⊤\\beta = (2, -0.5)^{ \\scriptstyle \\top }.  Finally, analyze posterior samples spatial random effects.  can also compare interpolated spatial surfaces true spatial effects posterior median.","code":"post_samps <- stackedSampler(mod2) post_beta <- post_samps$beta summary_beta <- t(apply(post_beta, 1, function(x) quantile(x, c(0.025, 0.5, 0.975)))) rownames(summary_beta) <- mod3$X.names print(summary_beta) #>                   2.5%        50%     97.5% #> (Intercept)  1.0880659  2.1012781  2.980541 #> x1          -0.6200398 -0.5448897 -0.477557 post_beta_df <- as.data.frame(post_beta) post_beta_df <- post_beta_df %>%   mutate(row = paste0(\"beta\", row_number()-1)) %>%   pivot_longer(-row, names_to = \"sample\", values_to = \"value\")  # True values of beta0 and beta1 truth <- data.frame(row = c(\"beta0\", \"beta1\"), true_value = c(2, -0.5))  ggplot(post_beta_df, aes(x = value)) +   geom_density(fill = \"lightblue\", alpha = 0.6) +   geom_vline(data = truth, aes(xintercept = true_value),               color = \"red\", linetype = \"dashed\", linewidth = 0.5) +   facet_wrap(~ row, scales = \"free\") + labs(x = \"\", y = \"Density\") +   theme_bw() + theme(panel.background = element_blank(),                       panel.grid = element_blank(), aspect.ratio = 1) post_z <- post_samps$z post_z_summ <- t(apply(post_z, 1, function(x) quantile(x, c(0.025, 0.5, 0.975)))) z_combn <- data.frame(z = dat$z_true, zL = post_z_summ[, 1],                       zM = post_z_summ[, 2], zU = post_z_summ[, 3])  plotz <- ggplot(data = z_combn, aes(x = z)) +   geom_point(aes(y = zM), size = 0.75, color = \"darkblue\", alpha = 0.5) +   geom_errorbar(aes(ymin = zL, ymax = zU), width = 0.05, alpha = 0.15,                 color = \"skyblue\") +   geom_abline(slope = 1, intercept = 0, color = \"red\") +   xlab(\"True z\") + ylab(\"Stacked posterior of z\") + theme_bw() +   theme(panel.background = element_blank(),          panel.grid = element_blank(), aspect.ratio = 1) plotz postmedian_z <- apply(post_z, 1, median) dat$z_hat <- postmedian_z plot_z <- surfaceplot2(dat, coords_name = c(\"s1\", \"s2\"),                        var1_name = \"z_true\", var2_name = \"z_hat\") library(ggpubr) ggarrange(plotlist = plot_z, common.legend = TRUE, legend = \"right\")"},{"path":"https://span-18.github.io/spStack-dev/articles/spatial.html","id":"spatial-binomial-count-data","dir":"Articles","previous_headings":"Bayesian Gaussian spatial regression models","what":"Spatial binomial count data","title":"Spatial Regression Models","text":"follow workflow Poisson data exception structure formula defines model also contain total number trials location. , present spGLMexact() function brevity. Similarly, collect posterior samples fixed effects summarize . true value fixed effects data simulated β=(0.5,−0.5)\\beta = (0.5, -0.5).","code":"data(\"simBinom\") dat <- simBinom[1:200, ] # work with first 200 rows  mod1 <- spGLMexact(cbind(y, n_trials) ~ x1, data = dat, family = \"binomial\",                    coords = as.matrix(dat[, c(\"s1\", \"s2\")]), cor.fn = \"matern\",                    spParams = list(phi = 3, nu = 0.5),                    boundary = 0.5, n.samples = 1000, verbose = FALSE) post_beta <- mod1$samples$beta summary_beta <- t(apply(post_beta, 1, function(x) quantile(x, c(0.025, 0.5, 0.975)))) rownames(summary_beta) <- mod1$X.names print(summary_beta) #>                   2.5%        50%     97.5% #> (Intercept) -1.1870121  0.7411895  2.738189 #> x1          -0.5852474 -0.4049237 -0.230766"},{"path":"https://span-18.github.io/spStack-dev/articles/spatial.html","id":"spatial-binary-data","dir":"Articles","previous_headings":"Bayesian Gaussian spatial regression models","what":"Spatial binary data","title":"Spatial Regression Models","text":"Finally, present spGLMexact() function spatial binary data avoid repetition. case, unlike binomial model, almost nothing changes case spatial Poisson data. Similarly, collect posterior samples fixed effects summarize . true value fixed effects data simulated β=(0.5,−0.5)\\beta = (0.5, -0.5).","code":"data(\"simBinary\") dat <- simBinary[1:200, ]  mod1 <- spGLMexact(y ~ x1, data = dat, family = \"binary\",                    coords = as.matrix(dat[, c(\"s1\", \"s2\")]), cor.fn = \"matern\",                    spParams = list(phi = 4, nu = 0.4),                    boundary = 0.5, n.samples = 1000, verbose = FALSE) post_beta <- mod1$samples$beta summary_beta <- t(apply(post_beta, 1, function(x) quantile(x, c(0.025, 0.5, 0.975)))) rownames(summary_beta) <- mod1$X.names print(summary_beta) #>                   2.5%        50%      97.5% #> (Intercept) -1.2015085  0.3212393 2.20401790 #> x1          -0.6653012 -0.3229634 0.07179601"},{"path":[]},{"path":"https://span-18.github.io/spStack-dev/articles/technical_overview.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Technical Overview","text":"Geostatistics refers study spatially distributed variable interest, theory defined every point bounded study region interest. Statistical modelling analysis spatially oriented point-referenced outcomes play crucial role diverse scientific applications earth environmental sciences, ecology, epidemiology, economics. advent Markov chain Monte Carlo (MCMC) algorithms, Bayesian hierarchical models gained massive popularity analyzing point-referenced , geostatistical data. models involve latent spatial processes characterized spatial process parameters, besides lacking substantive relevance scientific contexts, also weakly identified hence, impedes convergence MCMC algorithms. Thus, even moderately large datasets (~10310^3 higher), computation MCMC becomes onerous practical use. introduce R package spStack implements Bayesian inference class geostatistical models, obviate issues mentioned sampling analytically available posterior distributions conditional upon candidate values spatial process parameters , subsequently assimilate inference individual posterior distributions using Bayesian predictive stacking. Besides delivering competitive predictive performance compared fully Bayesian inference using MCMC, proposed algorithm embarrassingly parallel, thus drastically improves runtime elevating utility package diverse group practitioners limited computational resources disposal. package, best knowledge, first implement stacking Bayesian analysis spatial data. Technical details surrounding methodology can found articles Zhang, Tang, Banerjee (2025) discuss case distribution point-referenced outcomes Gaussian, , Pan et al. (2025) case non-Gaussian outcomes explored. code package written primarily C/C++ additional calls FORTRAN routines optimized linear algebra operations. leverage F77_NAME macro interface legacy FORTRAN functions conjunction efficient matrix computation libraries BLAS (Basic Linear Algebra Subprograms) LAPACK (Linear Algebra Package) implement stacking algorithm. remainder vignette evolves follows - next two sections discuss Bayesian hierarchical spatial models Gaussian non-Gaussian outcomes, followed section providing brief details predictive stacking section dedicated illustration functions package.","code":""},{"path":"https://span-18.github.io/spStack-dev/articles/technical_overview.html","id":"bayesian-gaussian-spatial-regression-models","dir":"Articles","previous_headings":"","what":"Bayesian Gaussian spatial regression models","title":"Technical Overview","text":"fix noise--spatial variance ratio δ2=τ2/σ2\\delta^2 = \\tau^2 / \\sigma^2, process parameters θsp{\\theta_{\\text{sp}}} hyperparameters μβ\\mu_\\beta, VβV_\\beta, aσa_\\sigma bσb_\\sigma. package, use Matern covariogram specified spatial decay parameter ϕ\\phi smoothness parameter ν\\nu .e., θsp={ϕ,ν}{\\theta_{\\text{sp}}}= \\{\\phi, \\nu\\}, given R(s,s′;θsp)=(ϕ|s−s′|)ν2ν−1Γ(ν)Kν(ϕ|s−s′|)).\\begin{equation} R(s, s'; {\\theta_{\\text{sp}}}) = \\frac{(\\phi \\lvert s - s' \\rvert)^\\nu}{2^{\\nu - 1} \\Gamma(\\nu)} K_\\nu (\\phi \\lvert s - s' \\rvert)). \\end{equation} utilize composition sampling strategy sample model parameters joint posterior distribution can written p(σ2,β,z∣y)=p(σ2∣y)×p(β∣σ2,y)×p(z∣β,σ2,y).\\begin{equation} p(\\sigma^2, \\beta, z \\mid y) = p(\\sigma^2 \\mid y) \\times p(\\beta \\mid \\sigma^2, y) \\times p(z \\mid \\beta, \\sigma^2, y). \\end{equation} proceed first sampling σ2\\sigma^2 marginal posterior, given samples σ2\\sigma^2, sample β\\beta subsequently, sample zz conditioned posterior samples β\\beta σ2\\sigma^2(Banerjee 2020). details can found Zhang, Tang, Banerjee (2025). function spLMexact() delivers samples posterior distribution conditional fixed hyperparameters. predictive stacking, use function spLMstack().","code":""},{"path":"https://span-18.github.io/spStack-dev/articles/technical_overview.html","id":"bayesian-non-gaussian-spatial-regression-models","dir":"Articles","previous_headings":"","what":"Bayesian non-Gaussian spatial regression models","title":"Technical Overview","text":"Analyzing non-Gaussian spatial data typically requires introducing spatial dependence generalized linear models link function exponential family distribution. Let y(s)y(s) outcome location s∈𝒟s \\\\mathcal{D} endowed probability law natural exponential family, denote y(s)∼𝖤𝖥(x(s)⊤β+z(s);b,ψy)\\begin{equation}     y(s) \\sim \\mathsf{EF}(x(s)^{ \\scriptstyle \\top }\\beta  + z(s); b, \\psi_y) \\end{equation} positive parameter b>0b > 0 unit log partition function ψy\\psi_y. Fixed effects regression spatial dependence, e.g., x(s)⊤β+z(s)x(s)^{{ \\scriptstyle \\top }}\\beta + z(s), introduced natural parameter, x(s)x(s) p×1p \\times 1 vector predictors referenced respect ss, β\\beta p×1p \\times 1 vector slopes measuring trend, z(s)z(s) zero-centered spatial process 𝒟\\mathcal{D} specified scale parameter σz\\sigma_z spatial correlation function R(⋅,⋅;θsp)R(\\cdot, \\cdot ; {\\theta_{\\text{sp}}}) θsp{\\theta_{\\text{sp}}} consisting spatial-temporal decay smoothness parameters. Unlike Gaussian likelihoods, inference considerably encumbered inability analytically integrate random effects reduce dimension parameter space. Iterative algorithms Markov Chain Monte Carlo (MCMC), thus attempt sample high-dimensional posterior distribution, convergence often hampered high auto-correlations weakly identified spatial process parameters θsp{\\theta_{\\text{sp}}}. model implemented using function spGLMexact() using fixed hyperparameters, spGLMstack() using predictive stacking. consider following three point-referenced data - Poisson count data: b=1b = 1 ψy(t)=et\\psi_y(t) = e^t. y(si)∼𝖯𝗈𝗂𝗌𝗌𝗈𝗇(λ(si)),=1,…,n.λ(si)=exp(x(si)⊤β+z(si))\\begin{equation} \\begin{split} y(s_i) &\\sim \\mathsf{Poisson}(\\lambda(s_i)), \\quad = 1, \\dots, n.\\\\ \\lambda(s_i) & = \\exp(x(s_i)^{ \\scriptstyle \\top }\\beta + z(s_i)) \\end{split} \\end{equation} accessed setting family = \"poisson\" functions. Binomial count data: b=m(si)b = m(s_i) ii ψy(t)=log(1+et)\\psi_y(t) = \\log(1 + e^t). y(si)∼𝖡𝗂𝗇𝗈𝗆𝗂𝖺𝗅(m(si),π(si)),=1,…,n.π(si)=ilogit(x(si)⊤β+z(si))\\begin{equation} \\begin{split} y(s_i) &\\sim \\mathsf{Binomial}(m(s_i), \\pi(s_i)), \\quad = 1, \\dots, n.\\\\ \\pi(s_i) & = \\mathrm{ilogit}(x(s_i)^{ \\scriptstyle \\top }\\beta + z(s_i)) \\end{split} \\end{equation} accessed setting family = \"binomial\" functions. Binary data: b=1b = 1 ψy(t)=log(1+et)\\psi_y(t) = \\log(1 + e^t). y(si)∼𝖡𝖾𝗋𝗇𝗈𝗎𝗅𝗅𝗂(π(si)),=1,…,n.π(si)=ilogit(x(si)⊤β+z(si))\\begin{equation} \\begin{split} y(s_i) &\\sim \\mathsf{Bernoulli}(\\pi(s_i)), \\quad = 1, \\dots, n.\\\\ \\pi(s_i) & = \\mathrm{ilogit}(x(s_i)^{ \\scriptstyle \\top }\\beta + z(s_i)) \\end{split} \\end{equation} accessed setting family = \"binary\" functions. Following Bradley Clinch (2024), introduce Bayesian hierarchical spatial model y(si)∣β,z,ξ∼𝖤𝖥(x(si)⊤β+z(si)+ξi−μi;bi,ψy),=1,…,nβ∣σβ2∼𝖭(0,σβ2Vβ),σβ2∼𝖨𝖦(νβ/2,νβ/2)z∣σz2∼𝖭(0,σz2R(χ;θsp)),σz2∼𝖨𝖦(νz/2,νz/2),ξ∣β,z,σξ2,αϵ∼𝖦𝖢𝖬𝖼(μ̃ξ,Hξ,ϵ,κξ;ψξ),\\begin{equation} \\begin{split} y(s_i) \\mid \\beta, z, \\xi & \\sim \\mathsf{EF}\\left(x(s_i)^{ \\scriptstyle \\top }\\beta + z(s_i) + \\xi_i - \\mu_i; b_i, \\psi_y\\right), = 1, \\ldots, n\\\\ \\beta \\mid \\sigma^2_\\beta &\\sim \\mathsf{N}(0, \\sigma^2_\\beta V_\\beta), \\quad \\sigma^2_\\beta \\sim \\mathsf{IG}(\\nu_\\beta/2, \\nu_\\beta/2)\\\\ z \\mid \\sigma^2_z &\\sim \\mathsf{N}\\left(0, \\sigma^2_z R(\\chi; {\\theta_{\\text{sp}}})\\right), \\quad \\sigma^2_z \\sim \\mathsf{IG}(\\nu_z/2, \\nu_z/2),\\\\ \\xi \\mid \\beta, z, \\sigma^2_\\xi, \\alpha_\\epsilon &\\sim \\mathsf{GCM_c}\\left(\\tilde{\\mu}_\\xi, H_\\xi, \\epsilon, \\kappa_\\xi; \\psi_\\xi\\right), \\end{split} \\end{equation} μ=(μ1,…,μn)⊤\\mu = (\\mu_1, \\ldots, \\mu_n)^{ \\scriptstyle \\top } denotes discrepancy parameter. fix spatial process parameters θsp{\\theta_{\\text{sp}}}, boundary adjustment parameter ϵ\\epsilon hyperparameters VβV_\\beta, νβ\\nu_\\beta, νz\\nu_z σξ2\\sigma^2_\\xi. term ξ\\xi known fine-scale variation term given conditional generalized conjugate multivariate distribution (GCMc\\mathrm{GCM_c}) prior. details, see Pan et al. (2025).","code":""},{"path":"https://span-18.github.io/spStack-dev/articles/technical_overview.html","id":"bayesian-non-gaussian-spatial-temporal-regression-model","dir":"Articles","previous_headings":"","what":"Bayesian non-Gaussian spatial-temporal regression model","title":"Technical Overview","text":"consider rich family Bayesian spatial-temporal model spatially-temporally varying regression coefficients. Suppose ℓ=(s,t)\\ell = (s, t), location s∈𝒟s \\\\mathcal{D} time t∈𝒯t \\\\mathcal{T}, denote spatial-temporal coordinate ℒ=𝒟×𝒯\\mathcal{L} = \\mathcal{D} \\times \\mathcal{T}. Let ℒ={ℓ1,…,ℓn}\\mathcal{L} = \\{\\ell_1, \\ldots, \\ell_n\\} fixed set nn distinct space-time coordinates 𝒟\\mathcal{D}, y(ℒ)=(y(ℓ1),…,y(ℓn))⊤y(\\mathcal{L}) = (y(\\ell_1), \\dots, y(\\ell_n))^\\top, simply denote yy, vector observed outcomes, distributed member natural exponential family log partition function ψy\\psi_y. Suppose, x(ℓi)x(\\ell_i) p×1p\\times 1 vector predictors, β\\beta corresponding p×1p \\times 1 vector slopes (fixed effects), x̃(ℓi)\\tilde{x}(\\ell_i) r×1r\\times 1 (r≤pr \\leq p) consisting predictors x(ℓi)x(\\ell_i) posited spatially-temporally varying regression coefficients z(ℓi)=(z1(ℓi),…,zr(ℓi))⊤z(\\ell_i) = (z_1(\\ell_i), \\ldots, z_r(\\ell_i))^\\top, zj(ℓi)z_j(\\ell_i) spatially-temporally varying coefficient predictor x̃j(ℓi)\\tilde{x}_j(\\ell_i), ξi\\xi_i fine-scale variation term μi\\mu_i discrepancy parameter (see ). introduce spatially-temporally varying coefficients η(ℓ)\\eta(\\ell) y(ℓi)∣β,z(ℓi),ξi,μi∼ind𝖤𝖥(η(ℓi)+ξi−μi;bi,ψy),=1,…,n,η(ℓ)=x(ℓ)⊤β+x̃(ℓ)⊤z(ℓ),β∣σβ2,μβ,Vβ∼𝖭(μβ,σβ2Vβ),σβ2∼πβ(σβ2),z(ℓ)∣θz,θsp∼𝖦𝖯(0,Cz(⋅,⋅;θsp,θz)),θz∼πz(θz),ξ∣β,z,μ,αϵ,κϵ,σξ2∼𝖦𝖢𝖬𝖼(μ̃ξ,Hξ,αξ,κξ,Dξ,πξ;ψξ),σξ2∼πξ(σξ2),p(μ)∝1,\\begin{equation} \\begin{split}     y(\\ell_i) &\\mid \\beta, z(\\ell_i), \\xi_i, \\mu_i \\overset{\\text{ind}}{\\sim} \\mathsf{EF}\\left(\\eta(\\ell_i) + \\xi_i - \\mu_i; b_i, \\psi_y \\right), \\ =1,\\ldots,n\\;,\\\\     \\eta(\\ell) &= x(\\ell)^{ \\scriptstyle \\top }\\beta + \\tilde{x}(\\ell)^{{ \\scriptstyle \\top }}z(\\ell), \\quad  \\beta \\mid \\sigma^2_\\beta, \\mu_\\beta, V_\\beta \\sim \\mathsf{N}(\\mu_\\beta, \\sigma^2_\\beta V_\\beta), \\quad \\sigma^2_\\beta \\sim \\pi_\\beta(\\sigma^2_\\beta) \\;,\\\\     z(\\ell) &\\mid \\theta_z, {\\theta_{\\text{sp}}}\\sim \\mathsf{GP}(0, C_z(\\cdot, \\cdot; {\\theta_{\\text{sp}}}, \\theta_z))\\;,\\quad \\theta_z \\sim \\pi_{z}(\\theta_z)\\;, \\\\     \\xi &\\mid \\beta, z, \\mu, \\alpha_\\epsilon, \\kappa_\\epsilon, \\sigma^2_\\xi \\sim \\mathsf{GCM_c}(\\tilde{\\mu}_\\xi, H_\\xi, \\alpha_\\xi, \\kappa_\\xi, D_\\xi, \\pi_\\xi; \\psi_\\xi), \\ \\sigma^2_\\xi \\sim \\pi_\\xi(\\sigma^2_\\xi), \\ p(\\mu) \\propto 1 \\;, \\end{split} \\end{equation} z(ℓ)=(z1(ℓ),…,zr(ℓ))⊤z(\\ell) = (z_1(\\ell), \\ldots, z_r(\\ell))^{ \\scriptstyle \\top } multivariate Gaussian process separable cross-covariance function Cz(⋅,⋅;θsp,θz)C_z(\\cdot, \\cdot; {\\theta_{\\text{sp}}}, \\theta_z), characterized process parameters θsp{\\theta_{\\text{sp}}} controls within-process spatial-temporal correlation, θz\\theta_z controls -process covariance matrix . Given θz\\theta_z, nr×1nr \\times 1 vector z=(z1⊤,…,zr⊤)⊤z = (z_1^{ \\scriptstyle \\top }, \\ldots, z_r^{ \\scriptstyle \\top })^{ \\scriptstyle \\top }, zj=(zj(ℓ1),…,zj(ℓn))⊤z_j = (z_j(\\ell_1), \\ldots, z_j(\\ell_n))^{ \\scriptstyle \\top } j=1,…,rj = 1, \\ldots, r, follows multivariate Gaussian distribution mean 00 nr×nrnr \\times nr covariance matrix Cz(ℒ;θsp,θz)C_z(\\mathcal{L}; {\\theta_{\\text{sp}}}, \\theta_z). model implemented function stvcGLMexact() fixed hyperparameters, stvcGLMstack() using predictive stacking. also implement different specifications CzC_z package follows. Independent spatial-temporal process: consider rr Gaussian spatial-temporal processes Independent processes: zj(ℓ)∣σzj2,θspj∼ind𝖦𝖯(0,σzj2Rj(⋅,⋅;θspj)),σzj2∼𝖨𝖦(νzj/2,νzj/2),j=1,…,r,\\begin{equation}\\label{eq:z_ind} \\begin{split}  \\text{Independent processes: } z_j(\\ell) \\mid\\sigma_{z_j}^2, {\\theta_{\\text{sp}}}_j & \\overset{\\text{ind}}{\\sim} \\mathsf{GP}(0, \\sigma_{z_j}^2 R_j(\\cdot, \\cdot; {\\theta_{\\text{sp}}}_j)),\\\\  \\sigma_{z_j}^2 & \\sim \\mathsf{IG}(\\nu_{z_j}/2, \\nu_{z_j}/2), \\quad j = 1, \\ldots, r, \\end{split} \\end{equation} σzj2\\sigma_{z_j}^2 variance parameter corresponding process zj(ℓ)z_j(\\ell). corresponds covariance matrix Cz(ℒ;θsp,θz)=⊕j=1rσzj2Rj(θspj)C_z(\\mathcal{L}; {\\theta_{\\text{sp}}}, \\theta_z) = \\oplus_{j = 1}^r \\sigma_{z_j}^2 R_j({\\theta_{\\text{sp}}}_j) θsp={θspj:j=1,…,r}{\\theta_{\\text{sp}}}= \\{ {\\theta_{\\text{sp}}}_j : j = 1, \\ldots, r\\}, θspj{\\theta_{\\text{sp}}}_j denotes covariance kernel parameters jjth process, θz={σz12,…,σzr2}\\theta_z = \\{\\sigma^2_{z_1}, \\ldots, \\sigma^2_{z_r}\\}. accessed setting option process.type = \"independent\" functions. Independent shared spatial-temporal process: corresponds θspj=θsp{\\theta_{\\text{sp}}}_j = {\\theta_{\\text{sp}}} σzj2=σz2\\sigma^2_{zj} = \\sigma^2_z j=1,…,rj = 1, \\ldots, r. accessed setting option process.type = \"independent.shared\" functions. Multivariate spatial-temporal process: can introduce dependence among elements r×1r\\times 1 vector z(ℓ)z(\\ell) using Multivariate process: z(ℓ)∣Σ∼𝖦𝖯(0,R(⋅,⋅;θsp)Σ),Σ∼𝖨𝖶(νz+2r,Ψ),\\begin{equation}\\label{eq:multi_z}  \\text{Multivariate process: }z(\\ell) \\mid\\Sigma \\sim \\mathsf{GP}(0, R(\\cdot, \\cdot; {\\theta_{\\text{sp}}})\\Sigma), \\quad \\Sigma \\sim \\mathsf{IW}(\\nu_z + 2r, \\Psi)\\;, \\end{equation} 𝒢𝒫(0,R(⋅,⋅;θsp)Σ)\\mathcal{GP} (0, R(\\cdot, \\cdot; {\\theta_{\\text{sp}}})\\Sigma) r×1r\\times 1 multivariate Gaussian process matrix-valued cross-covariance function R(⋅,⋅;θsp)ΣR(\\cdot, \\cdot; {\\theta_{\\text{sp}}})\\Sigma Σ\\Sigma r×rr \\times r positive definite random matrix. corresponds spatial-temporal covariance matrix Cz(ℒ;θsp,θz)=Σ⊗R(θsp)C_z(\\mathcal{L}; {\\theta_{\\text{sp}}}, \\theta_z) = \\Sigma \\otimes R({\\theta_{\\text{sp}}}) θz=Σ\\theta_z = \\Sigma. place inverse-Wishart prior scale parameter shape νz+2r\\nu_z + 2r r×rr\\times r positive definite scale matrix Ψ\\Psi, given π(θz)=𝖨𝖶(Σ∣νz+2r,Ψ)\\pi(\\theta_z) = \\mathsf{IW}(\\Sigma \\mid\\nu_z + 2r, \\Psi). accessed setting option process.type = \"multivariate\" functions.","code":""},{"path":"https://span-18.github.io/spStack-dev/articles/technical_overview.html","id":"predictive-stacking","dir":"Articles","previous_headings":"","what":"Predictive stacking","title":"Technical Overview","text":"Following Yao et al. (2018), consider set candidate models based grid values parameters {θsp,δ2}\\{ {\\theta_{\\text{sp}}}, \\delta^2 \\} Gaussian case, {θsp,ϵ}\\{ {\\theta_{\\text{sp}}}, \\epsilon \\} non-Gaussian case, supplied user. build set candidate models based Cartesian product collection values individual parameter ℳ={M1,…,MG}\\mathcal{M} = \\{M_1, \\ldots, M_G\\}. , g=1,…,Gg = 1, \\ldots, G, sample posterior distribution p(σ2,β,z∣y,Mg)p(\\sigma^2, \\beta, z \\mid y, M_g) model MgM_g find leave-one-predictive densities p(yi∣y−,Mg)p(y_i \\mid y_{-}, M_g). solve optimization problem maxw1,…,wG1n∑=1nlog∑g=1Gwgp(yi∣y−,Mg)subject towg≥0,∑g=1Gwg=1\\begin{equation} \\begin{split}  \\max_{w_1, \\ldots, w_G}& \\, \\frac{1}{n} \\sum_{= 1}^n \\log \\sum_{g = 1}^G  w_g p(y_i \\mid y_{-}, M_g) \\\\  \\text{subject } & \\quad w_g \\geq 0, \\sum_{g = 1}^G w_g = 1 \\end{split} \\end{equation} find optimal stacking weights ŵ1,…,ŵG\\hat{w}_1, \\ldots, \\hat{w}_G. obtaining optimal stacking weights, posterior inference quantity interest subsequently proceed stacked posterior, p̃(⋅∣y)=∑g=1Gŵgp(⋅∣y,Mg).\\begin{equation} \\tilde{p}(\\cdot \\mid y) = \\sum_{g = 1}^G \\hat{w}_g p(\\cdot \\mid y, M_g). \\end{equation}","code":""},{"path":[]},{"path":"https://span-18.github.io/spStack-dev/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Soumyakanti Pan. Author, maintainer. Sudipto Banerjee. Author.","code":""},{"path":"https://span-18.github.io/spStack-dev/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Pan S, Banerjee S (2025). spStack: Bayesian Geostatistics Using Predictive Stacking. R package version 1.1.0.9000, https://span-18.github.io/spStack-dev/.","code":"@Manual{,   title = {spStack: Bayesian Geostatistics Using Predictive Stacking},   author = {Soumyakanti Pan and Sudipto Banerjee},   year = {2025},   note = {R package version 1.1.0.9000},   url = {https://span-18.github.io/spStack-dev/}, }"},{"path":[]},{"path":"https://span-18.github.io/spStack-dev/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Bayesian Geostatistics Using Predictive Stacking","text":"spStack R package delivers Bayesian inference point-referenced spatial data assimilating posterior inference collection candidate models using stacking predictive densities. Currently, supports point-referenced Gaussian, Poisson, binomial binary outcomes. Users can supply candidate values spatial process parameters certain auxiliary model parameters, based collection models created. spStack utilizes Bayesian conjugate linear modelling framework Gaussian data generalized conjugate multivariate distribution theory non-Gaussian exponential family data. Learn vignette(\"spStack\"). Technical details methodology available Zhang, Tang, Banerjee 2024 Pan, Zhang, Bradley, , Banerjee 2024.","code":""},{"path":"https://span-18.github.io/spStack-dev/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Bayesian Geostatistics Using Predictive Stacking","text":"quick installation development version, run following command R. installing CRAN, use following.","code":"# Install development version from GitHub # install.packages(\"pak\") pak::pak(\"SPan-18/spStack-dev\") install.packages(\"spStack\")"},{"path":"https://span-18.github.io/spStack-dev/index.html","id":"installing-from-source","dir":"","previous_headings":"Installation","what":"Installing from source","title":"Bayesian Geostatistics Using Predictive Stacking","text":"install package source, download tarball spStack_X.X.XX.tar.gz file. setting working directory file location, either issue R CMD install spStack_X.X.XX.tar.gz terminal, run following command R install package. Note package written C++ calls FORTRAN routines hence contains Makevars file cross-platform portability. , important set correct path FORTRAN libraries well BLAS LAPACK computer. example, working MacOS, create file ~.R/Makevars set global configurations libraries link R. following example Makevars file. tells R use Accelerate framework, comes pre-installed Mac BLAS LAPACK functions. gfortran, simply run brew install gcc terminal install gcc compiler gfortran comes bundled gcc. gcc installed using Homebrew, path , otherwise path gfortran needs set correctly.","code":"install.packages(\"spStack_X.X.XX.tar.gz\", type = \"source\", repos = NULL) # Set Fortran library paths FLIBS = -L/opt/homebrew/opt/gcc/lib/gcc/14 -lgfortran -lquadmath -lm  # BLAS and LAPACK libraries (using Accelerate framework on macOS) BLAS_LIBS = -L/System/Library/Frameworks/Accelerate.framework/Versions/Current/ -framework Accelerate LAPACK_LIBS = -L/System/Library/Frameworks/Accelerate.framework/Versions/Current/ -framework Accelerate"},{"path":"https://span-18.github.io/spStack-dev/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Bayesian Geostatistics Using Predictive Stacking","text":"successfully installed, load library R. View vignette running vignette(\"spStack\") see example code implement predictive stacking different Bayesian hierarchical spatial models.","code":"library(spStack)"},{"path":"https://span-18.github.io/spStack-dev/index.html","id":"acknowledgement","dir":"","previous_headings":"","what":"Acknowledgement","title":"Bayesian Geostatistics Using Predictive Stacking","text":"graphics used logo obtained page Gaussian RF (Boris Kozintsev, 1999). represents realization isotropic Gaussian random field Matérn correlation function decay smoothness parameters 5 2, respectively.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/candidateModels.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a collection of candidate models for stacking — candidateModels","title":"Create a collection of candidate models for stacking — candidateModels","text":"Creates object class 'candidateModels' contains list candidate models stacking. function takes list candidate values model parameter returns list possible combinations values based either simple aggregation Cartesian product indivdual candidate values.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/candidateModels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a collection of candidate models for stacking — candidateModels","text":"","code":"candidateModels(params_list, aggregation = \"simple\")"},{"path":"https://span-18.github.io/spStack-dev/reference/candidateModels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a collection of candidate models for stacking — candidateModels","text":"params_list list candidate values model parameter. See examples details. aggregation character string specifying type aggregation used. Options 'simple' 'cartesian'. Default 'simple'.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/candidateModels.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a collection of candidate models for stacking — candidateModels","text":"object class 'candidateModels'","code":""},{"path":[]},{"path":"https://span-18.github.io/spStack-dev/reference/candidateModels.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a collection of candidate models for stacking — candidateModels","text":"Soumyakanti Pan span18@ucla.edu, Sudipto Banerjee sudipto@ucla.edu","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/candidateModels.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a collection of candidate models for stacking — candidateModels","text":"","code":"m1 <- candidateModels(list(phi_s = c(1, 1), phi_t = c(1, 2)), \"simple\") m1 #> [[1]] #> [[1]]$phi_s #> [1] 1 #>  #> [[1]]$phi_t #> [1] 1 #>  #>  #> [[2]] #> [[2]]$phi_s #> [1] 1 #>  #> [[2]]$phi_t #> [1] 2 #>  #>  #> attr(,\"class\") #> [1] \"candidateModels\" m2 <- candidateModels(list(phi_s = c(1, 1), phi_t = c(1, 2)), \"cartesian\") m2 #> [[1]] #> [[1]]$phi_s #> [1] 1 #>  #> [[1]]$phi_t #> [1] 1 #>  #>  #> [[2]] #> [[2]]$phi_s #> [1] 1 #>  #> [[2]]$phi_t #> [1] 1 #>  #>  #> [[3]] #> [[3]]$phi_s #> [1] 1 #>  #> [[3]]$phi_t #> [1] 2 #>  #>  #> [[4]] #> [[4]]$phi_s #> [1] 1 #>  #> [[4]]$phi_t #> [1] 2 #>  #>  #> attr(,\"class\") #> [1] \"candidateModels\" m3 <- candidateModels(list(phi_s = list(c(1, 1), c(1, 2)),                           phi_t = list(c(1, 3), c(2, 3)),                           boundary = c(0.5, 0.75)),                       \"simple\")"},{"path":"https://span-18.github.io/spStack-dev/reference/cholUpdate.html","id":null,"dir":"Reference","previous_headings":"","what":"Different Cholesky factor updates — cholUpdate","title":"Different Cholesky factor updates — cholUpdate","text":"Provides functions implements different types updates Cholesky factor includes rank-one update, single row/column deletion update block deletion update.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/cholUpdate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Different Cholesky factor updates — cholUpdate","text":"","code":"cholUpdateRankOne(A, v, alpha, beta, lower = TRUE)  cholUpdateDel(A, del.index, lower = TRUE)  cholUpdateDelBlock(A, del.start, del.end, lower = TRUE)"},{"path":"https://span-18.github.io/spStack-dev/reference/cholUpdate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Different Cholesky factor updates — cholUpdate","text":"\\(n\\times n\\) triangular matrix v \\(n\\times 1\\) matrix/vector alpha scalar; supplied, default 1 beta scalar; supplied, default 1 lower logical; lower-triangular del.index integer 1 \\(n\\) indicating row/column deleted del.start integer 1 \\(n\\) indicating first row/column block deleted, must least 1 less del.end del.end integer 1 \\(n\\) indicating last row/column block deleted, must least 1 del.start","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/cholUpdate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Different Cholesky factor updates — cholUpdate","text":"\\(m \\times m\\) lower-triangular matrix \\(m = n\\) case cholUpdateRankOne(), \\(m = n - 1\\) case cholUpdateDel(), , \\(m = n - n_k\\) case cholUpdateDelBlock() \\(n_k\\) size block removed.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/cholUpdate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Different Cholesky factor updates — cholUpdate","text":"Suppose \\(B = AA^\\top\\) \\(n \\times n\\) matrix \\(\\) lower-triangular Cholesky factor. rank-one update corresponds finding Cholesky factor matrix \\(C = \\alpha B + \\beta vv^\\top\\) \\(\\alpha,\\beta\\\\mathbb{R}\\) given \\(\\) (see, Krause Igel 2015). Similarly, single row/column deletion update corresponds finding Cholesky factor \\((n-1)\\times(n-1)\\) matrix \\(B_i\\) obtained removing \\(\\)-th row column \\(B\\), given \\(\\) \\(- 1, \\ldots, n\\). Lastly, block deletion corresponds finding Cholesky factor \\((n-n_k)\\times(n-n_k)\\) matrix \\(B_{}\\) subset \\(\\) \\(\\{1, \\ldots, n\\}\\) containing \\(n_k\\) consecutive indices, given factor \\(\\).","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/cholUpdate.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Different Cholesky factor updates — cholUpdate","text":"Oswin Krause Christian Igel. 2015. \"Efficient Rank-one Covariance Matrix Update Evolution Strategies\". Proceedings 2015 ACM Conference Foundations Genetic Algorithms XIII (FOGA '15). Association Computing Machinery, New York, NY, USA, 129-136. doi:10.1145/2725494.2725496 .","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/cholUpdate.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Different Cholesky factor updates — cholUpdate","text":"Soumyakanti Pan span18@ucla.edu, Sudipto Banerjee sudipto@ucla.edu","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/cholUpdate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Different Cholesky factor updates — cholUpdate","text":"","code":"n <- 10 A <- matrix(rnorm(n^2), n, n) A <- crossprod(A) cholA <- chol(A)  ## Rank-1 update v <- 1:n APlusvvT <- A + tcrossprod(v) cholA1 <- t(chol(APlusvvT)) cholA2 <- cholUpdateRankOne(cholA, v, lower = FALSE) print(all(abs(cholA1 - cholA2) < 1E-9)) #> [1] TRUE  ## Single Row-deletion update ind <- 2 A1 <- A[-ind, -ind] cholA1 <- t(chol(A1)) cholA2 <- cholUpdateDel(cholA, del.index = ind, lower = FALSE) print(all(abs(cholA1 - cholA2) < 1E-9)) #> [1] TRUE  ## Block-deletion update start_ind <- 2 end_ind <- 6 del_ind <- c(start_ind:end_ind) A1 <- A[-del_ind, -del_ind] cholA1 <- t(chol(A1)) cholA2 <- cholUpdateDelBlock(cholA, start_ind, end_ind, lower = FALSE) print(all(abs(cholA1 - cholA2) < 1E-9)) #> [1] TRUE"},{"path":"https://span-18.github.io/spStack-dev/reference/get_stacking_weights.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimal stacking weights — get_stacking_weights","title":"Optimal stacking weights — get_stacking_weights","text":"Obtains optimal stacking weights given leave-one-predictive densities candidate model.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/get_stacking_weights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimal stacking weights — get_stacking_weights","text":"","code":"get_stacking_weights(log_loopd, solver = \"ECOS\")"},{"path":"https://span-18.github.io/spStack-dev/reference/get_stacking_weights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimal stacking weights — get_stacking_weights","text":"log_loopd \\(n \\times M\\) matrix \\(\\)-th row containing leave-one-predictive densities \\(\\)-th data point \\(M\\) candidate models. solver specifies solver use obtaining optimal weights. Default \"ECOS\". Internally calls CVXR::psolve().","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/get_stacking_weights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimal stacking weights — get_stacking_weights","text":"list length 2. weights optimal stacking weights numeric vector length \\(M\\) status solver status, returns \"optimal\" solver succeeded.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/get_stacking_weights.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Optimal stacking weights — get_stacking_weights","text":"Yao Y, Vehtari , Simpson D, Gelman (2018). \"Using Stacking Average Bayesian Predictive Distributions (Discussion).\" Bayesian Analysis, 13(3), 917-1007. doi:10.1214/17-BA1091 .","code":""},{"path":[]},{"path":"https://span-18.github.io/spStack-dev/reference/get_stacking_weights.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Optimal stacking weights — get_stacking_weights","text":"Soumyakanti Pan span18@ucla.edu, Sudipto Banerjee sudipto@ucla.edu","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/get_stacking_weights.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Optimal stacking weights — get_stacking_weights","text":"","code":"set.seed(1234) data(simGaussian) dat <- simGaussian[1:100, ]  mod1 <- spLMstack(y ~ x1, data = dat,                   coords = as.matrix(dat[, c(\"s1\", \"s2\")]),                   cor.fn = \"matern\",                   params.list = list(phi = c(1.5, 3),                                      nu = c(0.5, 1),                                      noise_sp_ratio = c(1)),                   n.samples = 1000, loopd.method = \"exact\",                   parallel = FALSE, solver = \"ECOS\", verbose = TRUE) #>  #> STACKING WEIGHTS: #>  #>           | phi | nu  | noise_sp_ratio | weight | #> +---------+-----+-----+----------------+--------+ #> | Model 1 |  1.5|  0.5|               1| 0.000  | #> | Model 2 |  3.0|  0.5|               1| 0.285  | #> | Model 3 |  1.5|  1.0|               1| 0.000  | #> | Model 4 |  3.0|  1.0|               1| 0.715  | #> +---------+-----+-----+----------------+--------+ #>   loopd_mat <- do.call('cbind', mod1$loopd) w_hat <- get_stacking_weights(loopd_mat) print(round(w_hat$weights, 4)) #> [1] 0.0000 0.2845 0.0000 0.7155 print(w_hat$status) #> [1] \"optimal\""},{"path":"https://span-18.github.io/spStack-dev/reference/iDist.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate distance matrix — iDist","title":"Calculate distance matrix — iDist","text":"Computes inter-site Euclidean distance matrix one two sets points.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/iDist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate distance matrix — iDist","text":"","code":"iDist(coords.1, coords.2, ...)"},{"path":"https://span-18.github.io/spStack-dev/reference/iDist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate distance matrix — iDist","text":"coords.1 \\(n\\times p\\) matrix row corresponding point \\(p\\)-dimensional space. coords.2 \\(m\\times p\\) matrix row corresponding point \\(p\\) dimensional space. missing coords.1 used. ... currently additional arguments.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/iDist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate distance matrix — iDist","text":"\\(n\\times n\\) \\(n\\times m\\) inter-site Euclidean distance matrix.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/iDist.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate distance matrix — iDist","text":"Soumyakanti Pan span18@ucla.edu, Sudipto Banerjee sudipto@ucla.edu","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/iDist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate distance matrix — iDist","text":"","code":"n <- 10 p1 <- cbind(runif(n),runif(n)) m <- 5 p2 <- cbind(runif(m),runif(m)) D <- iDist(p1, p2)"},{"path":"https://span-18.github.io/spStack-dev/reference/posteriorPredict.html","id":null,"dir":"Reference","previous_headings":"","what":"Prediction of latent process at new spatial or temporal locations — posteriorPredict","title":"Prediction of latent process at new spatial or temporal locations — posteriorPredict","text":"function sample posterior predictive distribution latent spatial spatial-temporal process.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/posteriorPredict.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prediction of latent process at new spatial or temporal locations — posteriorPredict","text":"","code":"posteriorPredict(mod_out, coords_new, covars_new, joint = FALSE, nBinom_new)"},{"path":"https://span-18.github.io/spStack-dev/reference/posteriorPredict.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prediction of latent process at new spatial or temporal locations — posteriorPredict","text":"mod_out object returned model fit fixed hyperparameters using predictive stacking, .e., spLMexact(), spLMstack(), spGLMexact(), spGLMstack(), stvcGLMexact(), stvcGLMstack(). coords_new list new spatial spatial-temporal coordinates latent process, mean, response predicted. covars_new list new covariates new spatial spatial-temporal coordinates. See examples structure list. joint logical value indicating whether return joint posterior predictive samples latent process new locations times. Defaults FALSE. nBinom_new vector number trials new prediction location time. required model family \"binomial\". Defaults vector ones, indicating one trial new prediction.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/posteriorPredict.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prediction of latent process at new spatial or temporal locations — posteriorPredict","text":"modified object class name preceeded identifier pp separated .. example, input class spLMstack, output prediction function pp.spLMstack. entry tag samples updated include samples posterior predictive distribution latent process, mean, response new locations times. entry tag prediction added contains new coordinates covariates, whether joint posterior predictive samples requested.","code":""},{"path":[]},{"path":"https://span-18.github.io/spStack-dev/reference/posteriorPredict.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Prediction of latent process at new spatial or temporal locations — posteriorPredict","text":"Soumyakanti Pan span18@ucla.edu, Sudipto Banerjee sudipto@ucla.edu","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/posteriorPredict.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prediction of latent process at new spatial or temporal locations — posteriorPredict","text":"","code":"set.seed(1234) # training and test data sizes n_train <- 100 n_pred <- 10  # Example 1: Spatial linear model # load and split data into training and prediction sets data(simGaussian) dat <- simGaussian dat_train <- dat[1:n_train, ] dat_pred <- dat[n_train + 1:n_pred, ]  # fit a spatial linear model using predictive stacking mod1 <- spLMstack(y ~ x1, data = dat_train,                   coords = as.matrix(dat_train[, c(\"s1\", \"s2\")]),                   cor.fn = \"matern\",                   params.list = list(phi = c(1.5, 3, 5), nu = c(0.75, 1.25),                                      noise_sp_ratio = c(0.5, 1, 2)),                   n.samples = 1000, loopd.method = \"psis\",                   parallel = FALSE, solver = \"ECOS\", verbose = TRUE) #>  #> STACKING WEIGHTS: #>  #>            | phi | nu   | noise_sp_ratio | weight | #> +----------+-----+------+----------------+--------+ #> | Model 1  |  1.5|  0.75|             0.5| 0.000  | #> | Model 2  |  3.0|  0.75|             0.5| 0.000  | #> | Model 3  |  5.0|  0.75|             0.5| 0.404  | #> | Model 4  |  1.5|  1.25|             0.5| 0.076  | #> | Model 5  |  3.0|  1.25|             0.5| 0.520  | #> | Model 6  |  5.0|  1.25|             0.5| 0.000  | #> | Model 7  |  1.5|  0.75|             1.0| 0.000  | #> | Model 8  |  3.0|  0.75|             1.0| 0.000  | #> | Model 9  |  5.0|  0.75|             1.0| 0.000  | #> | Model 10 |  1.5|  1.25|             1.0| 0.000  | #> | Model 11 |  3.0|  1.25|             1.0| 0.000  | #> | Model 12 |  5.0|  1.25|             1.0| 0.000  | #> | Model 13 |  1.5|  0.75|             2.0| 0.000  | #> | Model 14 |  3.0|  0.75|             2.0| 0.000  | #> | Model 15 |  5.0|  0.75|             2.0| 0.000  | #> | Model 16 |  1.5|  1.25|             2.0| 0.000  | #> | Model 17 |  3.0|  1.25|             2.0| 0.000  | #> | Model 18 |  5.0|  1.25|             2.0| 0.000  | #> +----------+-----+------+----------------+--------+ #>   # prepare new coordinates and covariates for prediction sp_pred <- as.matrix(dat_pred[, c(\"s1\", \"s2\")]) X_new <- as.matrix(cbind(rep(1, n_pred), dat_pred$x1))  # carry out posterior prediction mod.pred <- posteriorPredict(mod1, coords_new = sp_pred, covars_new = X_new,                              joint = TRUE)  # sample from the stacked posterior and posterior predictive distribution post_samps <- stackedSampler(mod.pred)  # analyze posterior samples postpred_z <- post_samps$z.pred post_z_summ <- t(apply(postpred_z, 1, function(x) quantile(x, c(0.025, 0.5, 0.975)))) z_combn <- data.frame(z = dat_pred$z_true, zL = post_z_summ[, 1],                       zM = post_z_summ[, 2], zU = post_z_summ[, 3]) library(ggplot2) ggplot(data = z_combn, aes(x = z)) +   geom_errorbar(aes(ymin = zL, ymax = zU), width = 0.05, alpha = 0.15, color = \"skyblue\") +   geom_point(aes(y = zM), size = 0.25, color = \"darkblue\", alpha = 0.5) +   geom_abline(slope = 1, intercept = 0, color = \"red\", linetype = \"solid\") +   xlab(\"True z1\") + ylab(\"Posterior of z1\") + theme_bw() +   theme(panel.background = element_blank(), aspect.ratio = 1)"},{"path":"https://span-18.github.io/spStack-dev/reference/recoverGLMscale.html","id":null,"dir":"Reference","previous_headings":"","what":"Recover posterior samples of scale parameters of spatial/spatial-temporal generalized linear models — recoverGLMscale","title":"Recover posterior samples of scale parameters of spatial/spatial-temporal generalized linear models — recoverGLMscale","text":"function recover posterior samples scale parameters marginalized model fit. applicable spatial , spatial-temporal generalized linear models. function applies outputs functions fits spatial/spatial-temporal generalized linear model, spGLMexact(), spGLMstack(), stvcGLMexact(), stvcGLMstack().","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/recoverGLMscale.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Recover posterior samples of scale parameters of spatial/spatial-temporal generalized linear models — recoverGLMscale","text":"","code":"recoverGLMscale(mod_out)"},{"path":"https://span-18.github.io/spStack-dev/reference/recoverGLMscale.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Recover posterior samples of scale parameters of spatial/spatial-temporal generalized linear models — recoverGLMscale","text":"mod_out object returned fitting spatial spatial-temporal GLM.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/recoverGLMscale.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Recover posterior samples of scale parameters of spatial/spatial-temporal generalized linear models — recoverGLMscale","text":"object class input, updates list tagged samples posterior samples scale parameters. new tags sigmasq.beta z.scale.","code":""},{"path":[]},{"path":"https://span-18.github.io/spStack-dev/reference/recoverGLMscale.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Recover posterior samples of scale parameters of spatial/spatial-temporal generalized linear models — recoverGLMscale","text":"Soumyakanti Pan span18@ucla.edu, Sudipto Banerjee sudipto@ucla.edu","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/recoverGLMscale.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Recover posterior samples of scale parameters of spatial/spatial-temporal generalized linear models — recoverGLMscale","text":"","code":"set.seed(1234) data(\"simPoisson\") dat <- simPoisson[1:100, ] mod1 <- spGLMstack(y ~ x1, data = dat, family = \"poisson\",                    coords = as.matrix(dat[, c(\"s1\", \"s2\")]), cor.fn = \"matern\",                    params.list = list(phi = c(3, 5, 7), nu = c(0.5, 1.5),                                       boundary = c(0.5)),                    n.samples = 100,                    loopd.controls = list(method = \"CV\", CV.K = 10, nMC = 500),                    verbose = TRUE) #>  #> STACKING WEIGHTS: #>  #>           | phi | nu  | boundary | weight | #> +---------+-----+-----+----------+--------+ #> | Model 1 |    3|  0.5|       0.5| 0.000  | #> | Model 2 |    5|  0.5|       0.5| 0.000  | #> | Model 3 |    7|  0.5|       0.5| 0.000  | #> | Model 4 |    3|  1.5|       0.5| 0.398  | #> | Model 5 |    5|  1.5|       0.5| 0.082  | #> | Model 6 |    7|  1.5|       0.5| 0.520  | #> +---------+-----+-----+----------+--------+ #>   # Recover posterior samples of scale parameters mod1.1 <- recoverGLMscale(mod1)  # sample from the stacked posterior distribution post_samps <- stackedSampler(mod1.1)"},{"path":"https://span-18.github.io/spStack-dev/reference/simBinary.html","id":null,"dir":"Reference","previous_headings":"","what":"Synthetic point-referenced binary data — simBinary","title":"Synthetic point-referenced binary data — simBinary","text":"Dataset size 500, binary response variable indexed spatial coordinates sampled uniformly unit square. model includes one covariate spatial random effects induced Matérn covariogram.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/simBinary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Synthetic point-referenced binary data — simBinary","text":"","code":"data(simBinary)"},{"path":"https://span-18.github.io/spStack-dev/reference/simBinary.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Synthetic point-referenced binary data — simBinary","text":"data.frame object. s1, s2 2-D coordinates; latitude longitude. x1 covariate sampled standard normal distribution. y response vector (0/1). z_true true spatial random effects generated data.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/simBinary.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Synthetic point-referenced binary data — simBinary","text":"\\(n = 500\\), binary data simulated using $$ \\begin{aligned} y(s_i) &\\sim \\mathrm{Bernoulli}(\\pi(s_i)), = 1, \\ldots, n,\\\\ \\pi(s_i) &= \\mathrm{ilogit}(x(s_i)^\\top \\beta + z(s_i)) \\end{aligned} $$ function \\(\\mathrm{ilogit}\\) refers inverse-logit function, spatial effects \\(z \\sim N(0, \\sigma^2 R)\\) \\(R\\) \\(n \\times n\\) correlation matrix given Matérn covariogram $$ R(s, s') = \\frac{(\\phi |s-s'|)^\\nu}{\\Gamma(\\nu) 2^{\\nu - 1}} K_\\nu(\\phi |s-s'|), $$ \\(\\phi\\) spatial decay parameter \\(\\nu\\) spatial smoothness parameter. sampled data \\(\\beta = (0.5, -0.5)\\), \\(\\phi = 5\\), \\(\\nu = 0.5\\), \\(\\sigma^2 = 0.4\\). data can generated code given example .","code":""},{"path":[]},{"path":"https://span-18.github.io/spStack-dev/reference/simBinary.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Synthetic point-referenced binary data — simBinary","text":"Soumyakanti Pan span18@ucla.edu, Sudipto Banerjee sudipto@ucla.edu","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/simBinary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Synthetic point-referenced binary data — simBinary","text":"","code":"set.seed(1729) n <- 500 beta <- c(0.5, -0.5) phi0 <- 5 nu0 <- 0.5 spParams <- c(phi0, nu0) spvar <- 0.4 sim1 <- sim_spData(n = n, beta = beta, cor.fn = \"matern\",                    spParams = spParams, spvar = spvar, deltasq = deltasq,                    family = \"binary\") plot1 <- surfaceplot(sim1, coords_name = c(\"s1\", \"s2\"), var_name = \"z_true\")  library(ggplot2) plot2 <- ggplot(sim1, aes(x = s1, y = s2)) +   geom_point(aes(color = factor(y)), alpha = 0.75) +   scale_color_manual(values = c(\"red\", \"blue\"), labels = c(\"0\", \"1\")) +   guides(alpha = 'none') +   theme_bw() +   theme(axis.ticks = element_line(linewidth = 0.25),         panel.background = element_blank(),         panel.grid = element_blank(),         legend.title = element_text(size = 10, hjust = 0.25),         legend.box.just = \"center\", aspect.ratio = 1)"},{"path":"https://span-18.github.io/spStack-dev/reference/simBinom.html","id":null,"dir":"Reference","previous_headings":"","what":"Synthetic point-referenced binomial count data — simBinom","title":"Synthetic point-referenced binomial count data — simBinom","text":"Dataset size 500, binomial response variable indexed spatial coordinates sampled uniformly unit square. model includes one covariate spatial random effects induced Matérn covariogram. number trials location sampled Poisson distribution mean 20.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/simBinom.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Synthetic point-referenced binomial count data — simBinom","text":"","code":"data(simBinom)"},{"path":"https://span-18.github.io/spStack-dev/reference/simBinom.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Synthetic point-referenced binomial count data — simBinom","text":"data.frame object. s1, s2 2-D coordinates; latitude longitude. x1 covariate sampled standard normal distribution. y response vector. n_trials Number trials location. z_true true spatial random effects generated data.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/simBinom.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Synthetic point-referenced binomial count data — simBinom","text":"\\(n = 500\\), count data simulated using $$ \\begin{aligned} y(s_i) &\\sim \\mathrm{Binomial}(m(s_i), \\pi(s_i)), = 1, \\ldots, n,\\\\ \\pi(s_i) &= \\mathrm{ilogit}(x(s_i)^\\top \\beta + z(s_i)) \\end{aligned} $$ function \\(\\mathrm{ilogit}\\) refers inverse-logit function, number trials \\(m(s_i)\\) sampled Poisson distribution mean 20, spatial effects \\(z \\sim N(0, \\sigma^2 R)\\) \\(R\\) \\(n \\times n\\) correlation matrix given Matérn covariogram $$ R(s, s') = \\frac{(\\phi |s-s'|)^\\nu}{\\Gamma(\\nu) 2^{\\nu - 1}} K_\\nu(\\phi |s-s'|), $$ \\(\\phi\\) spatial decay parameter \\(\\nu\\) spatial smoothness parameter. sampled data \\(\\beta = (0.5, -0.5)\\), \\(\\phi = 3\\), \\(\\nu = 0.5\\), \\(\\sigma^2 = 0.4\\). data can generated code given example .","code":""},{"path":[]},{"path":"https://span-18.github.io/spStack-dev/reference/simBinom.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Synthetic point-referenced binomial count data — simBinom","text":"Soumyakanti Pan span18@ucla.edu, Sudipto Banerjee sudipto@ucla.edu","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/simBinom.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Synthetic point-referenced binomial count data — simBinom","text":"","code":"set.seed(1729) n <- 500 beta <- c(0.5, -0.5) phi0 <- 3 nu0 <- 0.5 spParams <- c(phi0, nu0) spvar <- 0.4 sim1 <- sim_spData(n = n, beta = beta, cor.fn = \"matern\",                    spParams = spParams, spvar = spvar, deltasq = deltasq,                    n_binom = rpois(n, 20),                    family = \"binomial\") plot1 <- surfaceplot(sim1, coords_name = c(\"s1\", \"s2\"), var_name = \"z_true\")  library(ggplot2) plot2 <- ggplot(sim1, aes(x = s1, y = s2)) +   geom_point(aes(color = y), alpha = 0.75) +   scale_color_distiller(palette = \"RdYlGn\", direction = -1,                         label = function(x) sprintf(\"%.0f\", x)) +   guides(alpha = 'none') +   theme_bw() +   theme(axis.ticks = element_line(linewidth = 0.25),         panel.background = element_blank(),         panel.grid = element_blank(),         legend.title = element_text(size = 10, hjust = 0.25),         legend.box.just = \"center\", aspect.ratio = 1)"},{"path":"https://span-18.github.io/spStack-dev/reference/simGaussian.html","id":null,"dir":"Reference","previous_headings":"","what":"Synthetic point-referenced Gaussian data — simGaussian","title":"Synthetic point-referenced Gaussian data — simGaussian","text":"Dataset size 500 Gaussian response variable, simulated spatial coordinates sampled uniformly unit square. model includes one covariate spatial random effects induced Matérn covariogram.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/simGaussian.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Synthetic point-referenced Gaussian data — simGaussian","text":"","code":"data(simGaussian)"},{"path":"https://span-18.github.io/spStack-dev/reference/simGaussian.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Synthetic point-referenced Gaussian data — simGaussian","text":"data.frame object. s1, s2 2-D coordinates; latitude longitude. x1 covariate sampled standard normal distribution. y response vector. z_true true spatial random effects generated data.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/simGaussian.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Synthetic point-referenced Gaussian data — simGaussian","text":"data generated using model $$ y = X \\beta + z + \\epsilon, $$ spatial effects \\(z \\sim N(0, \\sigma^2 R)\\) independent measurement error \\(\\epsilon \\sim N(0, \\delta^2 \\sigma^2 I_n)\\) \\(\\delta^2\\) noise--spatial variance ratio \\(R\\) \\(n \\times n\\) correlation matrix given Matérn covariogram $$ R(s, s') = \\frac{(\\phi |s-s'|)^\\nu}{\\Gamma(\\nu) 2^{\\nu - 1}} K_\\nu(\\phi |s-s'|), $$ \\(\\phi\\) spatial decay parameter \\(\\nu\\) spatial smoothness parameter. sampled data \\(\\beta = (2, 5)\\), \\(\\phi = 2\\), \\(\\nu = 0.5\\), \\(\\delta^2 = 1\\) \\(\\sigma^2 = 0.4\\). data can generated code given example.","code":""},{"path":[]},{"path":"https://span-18.github.io/spStack-dev/reference/simGaussian.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Synthetic point-referenced Gaussian data — simGaussian","text":"Soumyakanti Pan span18@ucla.edu","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/simGaussian.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Synthetic point-referenced Gaussian data — simGaussian","text":"","code":"set.seed(1729) n <- 500 beta <- c(2, 5) phi0 <- 2 nu0 <- 0.5 spParams <- c(phi0, nu0) spvar <- 0.4 deltasq <- 1 sim1 <- sim_spData(n = n, beta = beta, cor.fn = \"matern\",                    spParams = spParams, spvar = spvar, deltasq = deltasq,                    family = \"gaussian\") plot1 <- surfaceplot(sim1, coords_name = c(\"s1\", \"s2\"), var_name = \"z_true\",                      mark_points = TRUE) plot1   library(ggplot2) plot2 <- ggplot(sim1, aes(x = s1, y = s2)) +   geom_point(aes(color = y), alpha = 0.75) +   scale_color_distiller(palette = \"RdYlGn\", direction = -1,                         label = function(x) sprintf(\"%.0f\", x)) +   guides(alpha = 'none') + theme_bw() +   theme(axis.ticks = element_line(linewidth = 0.25),         panel.background = element_blank(), panel.grid = element_blank(),         legend.title = element_text(size = 10, hjust = 0.25),         legend.box.just = \"center\", aspect.ratio = 1) plot2"},{"path":"https://span-18.github.io/spStack-dev/reference/simPoisson.html","id":null,"dir":"Reference","previous_headings":"","what":"Synthetic point-referenced Poisson count data — simPoisson","title":"Synthetic point-referenced Poisson count data — simPoisson","text":"Dataset size 500, Poisson distributed response variable indexed spatial coordinates sampled uniformly unit square. model includes one covariate spatial random effects induced Matérn covariogram.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/simPoisson.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Synthetic point-referenced Poisson count data — simPoisson","text":"","code":"data(simPoisson)"},{"path":"https://span-18.github.io/spStack-dev/reference/simPoisson.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Synthetic point-referenced Poisson count data — simPoisson","text":"data.frame object. s1, s2 2-D coordinates; latitude longitude. x1 covariate sampled standard normal distribution. y response vector. z_true true spatial random effects generated data.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/simPoisson.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Synthetic point-referenced Poisson count data — simPoisson","text":"\\(n = 500\\), count data simulated using $$ \\begin{aligned} y(s_i) &\\sim \\mathrm{Poisson}(\\lambda(s_i)), = 1, \\ldots, n,\\\\ \\log \\lambda(s_i) &= x(s_i)^\\top \\beta + z(s_i) \\end{aligned} $$ spatial effects \\(z \\sim N(0, \\sigma^2 R)\\) \\(R\\) \\(n \\times n\\) correlation matrix given Matérn covariogram $$ R(s, s') = \\frac{(\\phi |s-s'|)^\\nu}{\\Gamma(\\nu) 2^{\\nu - 1}} K_\\nu(\\phi |s-s'|), $$ \\(\\phi\\) spatial decay parameter \\(\\nu\\) spatial smoothness parameter. sampled data \\(\\beta = (2, -0.5)\\), \\(\\phi = 5\\), \\(\\nu = 0.5\\), \\(\\sigma^2 = 0.4\\). data can generated code given example .","code":""},{"path":[]},{"path":"https://span-18.github.io/spStack-dev/reference/simPoisson.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Synthetic point-referenced Poisson count data — simPoisson","text":"","code":"set.seed(1729) n <- 500 beta <- c(2, -0.5) phi0 <- 5 nu0 <- 0.5 spParams <- c(phi0, nu0) spvar <- 0.4 sim1 <- sim_spData(n = n, beta = beta, cor.fn = \"matern\",                    spParams = spParams, spvar = spvar, deltasq = deltasq,                    family = \"poisson\")  # Plot an interpolated spatial surface of the true random spatial effects plot1 <- surfaceplot(sim1, coords_name = c(\"s1\", \"s2\"), var_name = \"z_true\")  # Plot the simulated count data library(ggplot2) plot2 <- ggplot(sim1, aes(x = s1, y = s2)) +   geom_point(aes(color = y), alpha = 0.75) +   scale_color_distiller(palette = \"RdYlGn\", direction = -1,                         label = function(x) sprintf(\"%.0f\", x)) +   guides(alpha = 'none') + theme_bw() +   theme(axis.ticks = element_line(linewidth = 0.25),         panel.background = element_blank(), panel.grid = element_blank(),         legend.title = element_text(size = 10, hjust = 0.25),         legend.box.just = \"center\", aspect.ratio = 1)"},{"path":"https://span-18.github.io/spStack-dev/reference/sim_spData.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate spatial data on unit square — sim_spData","title":"Simulate spatial data on unit square — sim_spData","text":"Generates synthetic spatial data different types spatial co-ordinates sampled uniformly unit square. Different types include point-referenced Gaussian, Poisson, binomial binary data. design includes intercept fixed covariates sampled standard normal distribution.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/sim_spData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate spatial data on unit square — sim_spData","text":"","code":"sim_spData(n, beta, cor.fn, spParams, spvar, deltasq, family, n_binom)"},{"path":"https://span-18.github.io/spStack-dev/reference/sim_spData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate spatial data on unit square — sim_spData","text":"n sample size. beta \\(p\\)-dimensional vector fixed effects. cor.fn quoted keyword specifies correlation function used model spatial dependence structure among observations. Supported covariance model key words : 'exponential' 'matern'. spParams numeric vector containing spatial process parameters - e.g., spatial decay smoothness. spvar value spatial variance parameter. deltasq value noise--spatial variance ratio. family character specifying distribution response member exponential family. Valid inputs 'gaussian', 'poisson', 'binary', 'binomial'. n_binom necessary family = 'binomial'. Must vector length n specify number trials observation. length 1, value considered common value number trials n observations.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/sim_spData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate spatial data on unit square — sim_spData","text":"data.frame object containing columns - s1, s2 2D-coordinates unit square x1, x2, ... covariates, including intercept y response n_trials present binomial data generated z_true true spatial effects data generated","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/sim_spData.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulate spatial data on unit square — sim_spData","text":"Soumyakanti Pan span18@ucla.edu, Sudipto Banerjee sudipto@ucla.edu","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/sim_spData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate spatial data on unit square — sim_spData","text":"","code":"set.seed(1729) n <- 10 beta <- c(2, 5) phi0 <- 2 nu0 <- 0.5 spParams <- c(phi0, nu0) spvar <- 0.4 deltasq <- 1 sim1 <- sim_spData(n = n, beta = beta, cor.fn = \"matern\",                    spParams = spParams, spvar = spvar, deltasq = deltasq,                    family = \"gaussian\")"},{"path":"https://span-18.github.io/spStack-dev/reference/sim_stvcPoisson.html","id":null,"dir":"Reference","previous_headings":"","what":"Synthetic point-referenced spatial-temporal Poisson count data simulated using spatially-temporally varying coefficients — sim_stvcPoisson","title":"Synthetic point-referenced spatial-temporal Poisson count data simulated using spatially-temporally varying coefficients — sim_stvcPoisson","text":"Dataset size 500, Poisson distributed response variable indexed spatial temporal coordinates sampled uniformly unit square. model includes intercept covariate spatially temporally varying coefficients, spatial-temporal random effects induced Matérn covariogram.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/sim_stvcPoisson.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Synthetic point-referenced spatial-temporal Poisson count data simulated using spatially-temporally varying coefficients — sim_stvcPoisson","text":"","code":"data(sim_stvcPoisson)"},{"path":"https://span-18.github.io/spStack-dev/reference/sim_stvcPoisson.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Synthetic point-referenced spatial-temporal Poisson count data simulated using spatially-temporally varying coefficients — sim_stvcPoisson","text":"data.frame object. s1, s2 2-D coordinates; latitude longitude. t_coords temporal coordinates. x1 covariate sampled standard normal distribution. y response vector. z1_true true spatial-temporal random effect associated intercept. z2_true true spatial-temporal random effect associated covariate.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/sim_stvcPoisson.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Synthetic point-referenced spatial-temporal Poisson count data simulated using spatially-temporally varying coefficients — sim_stvcPoisson","text":"\\(n = 500\\), count data simulated using $$ \\begin{aligned} y(s_i) &\\sim \\mathrm{Poisson}(\\lambda(s_i)), = 1, \\ldots, n,\\\\ \\log \\lambda(s_i) &= x(s_i)^\\top \\beta + x(s_i)^\\top z(s_i), \\end{aligned} $$ spatial-temporal random effects \\(z(s) = (z_1(s), z_2(s))^\\top\\) independent processes \\(z_j(s) \\sim GP(0, \\sigma_j^2 R(\\cdot, \\cdot; \\theta_j))\\) \\(j = 1, 2\\), \\(R(\\cdot, \\cdot; \\theta_j)\\) given $$ R((s, t), (s', t'); \\theta_j) = \\frac{1}{\\phi_{tj} |t - t'|^2 + 1} \\exp \\left( - \\frac{\\phi_{sj} \\lVert s - s' \\rVert}{\\sqrt{1 + \\phi_{tj} |t - t'|^2}} \\right) , $$ \\(\\phi_s\\) spatial decay parameter, \\(\\phi_t\\) temporal decay parameter. sampled data \\(\\beta = (2, -0.5)\\), \\(\\phi_{s1} = 2\\), \\(\\phi_{s2} = 3\\), \\(\\phi_{t1} = 2\\), \\(\\phi_{t2} = 4\\), \\(\\sigma^2_1 = \\sigma^2_2 = 1\\). data can generated code given example .","code":""},{"path":[]},{"path":"https://span-18.github.io/spStack-dev/reference/sim_stvcPoisson.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Synthetic point-referenced spatial-temporal Poisson count data simulated using spatially-temporally varying coefficients — sim_stvcPoisson","text":"","code":"rmvn <- function(n, mu = 0, V = matrix(1)) { p <- length(mu)   if (any(is.na(match(dim(V), p))))     stop(\"error: dimension mismatch.\")   D <- chol(V)   t(matrix(rnorm(n * p), ncol = p) %*% D + rep(mu, rep(n, p))) } set.seed(1726) n <- 500 beta <- c(2, -0.5) p <- length(beta) X <- cbind(rep(1, n), sapply(1:(p - 1), function(x) rnorm(n))) X_tilde <- X phi_s <- c(2, 3) phi_t <- c(2, 4) S <- data.frame(s1 = runif(n, 0, 1), s2 = runif(n, 0, 1)) Tm <- runif(n) dist_S <- as.matrix(dist(as.matrix(S))) dist_T <- as.matrix(dist(as.matrix(Tm))) Vz1 <- 1/(1 + phi_t[1] * dist_T^2) * exp(- (phi_s[1] * dist_S) / sqrt(1 + phi_t[1] * dist_T^2)) Vz2 <- 1/(1 + phi_t[2] * dist_T^2) * exp(- (phi_s[2] * dist_S) / sqrt(1 + phi_t[2] * dist_T^2)) z1 <- rmvn(1, rep(0, n), Vz1) z2 <- rmvn(1, rep(0, n), Vz2) muFixed <- X %*% beta muSpT <- X_tilde[, 1] * z1 + X_tilde[, 2] * z2 mu <- muFixed + muSpT y <- sapply(1:n, function(x) rpois(n = 1, lambda = exp(mu[x]))) dat <- cbind(S, Tm, X[, -1], y, z1, z2) names(dat) <- c(\"s1\", \"s2\", \"t_coords\", paste(\"x\", 1:(p - 1), sep = \"\"), \"y\", \"z1_true\", \"z2_true\")"},{"path":"https://span-18.github.io/spStack-dev/reference/spGLMexact.html","id":null,"dir":"Reference","previous_headings":"","what":"Univariate Bayesian spatial generalized linear model — spGLMexact","title":"Univariate Bayesian spatial generalized linear model — spGLMexact","text":"Fits Bayesian spatial generalized linear model fixed values spatial process parameters auxiliary model parameters. output contains posterior samples fixed effects, spatial random effects , required, finds leave-one-predictive densities.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spGLMexact.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Univariate Bayesian spatial generalized linear model — spGLMexact","text":"","code":"spGLMexact(   formula,   data = parent.frame(),   family,   coords,   cor.fn,   priors,   spParams,   boundary = 0.5,   n.samples,   loopd = FALSE,   loopd.method = \"exact\",   CV.K = 10,   loopd.nMC = 500,   verbose = TRUE,   ... )"},{"path":"https://span-18.github.io/spStack-dev/reference/spGLMexact.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Univariate Bayesian spatial generalized linear model — spGLMexact","text":"formula symbolic description regression model fit. See example . data optional data frame containing variables model. found data, variables taken environment(formula), typically environment spGLMexact called. family Specifies distribution response member exponential family. Supported options 'poisson', 'binomial' 'binary'. coords \\(n \\times 2\\) matrix observation coordinates \\(\\mathbb{R}^2\\) (e.g., easting northing). cor.fn quoted keyword specifies correlation function used model spatial dependence structure among observations. Supported covariance model key words : 'exponential' 'matern'. See details. priors (optional) list tag corresponding hyperparameter name containing hyperprior details. Valid tags include V.beta, nu.beta, nu.z sigmaSq.xi. Values nu.beta nu.z must least 2.1. supplied, uses defaults. spParams fixed values spatial process parameters. boundary Specifies boundary adjustment parameter. Must real number 0 1. Default 0.5. n.samples number posterior samples generated. loopd logical. loopd=TRUE, returns leave-one-predictive densities, using method given loopd.method. Default FALSE. loopd.method character. Ignored loopd=FALSE. loopd=TRUE, valid inputs 'exact', 'CV' 'PSIS'. option 'exact' corresponds exact leave-one-predictive densities requires computation almost equivalent fitting model \\(n\\) times. options 'CV' 'PSIS' faster implement \\(K\\)-fold cross validation Pareto-smoothed importance sampling find approximate leave-one-predictive densities (Vehtari et al. 2017). CV.K integer 10 20. Considered loopd.method='CV'. Default 10 (recommended Vehtari et. al 2017). loopd.nMC Number Monte Carlo samples used evaluate leave-one-predictive densities loopd.method set either 'exact' 'CV'. verbose logical. verbose = TRUE, prints model description. ... currently additional argument.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spGLMexact.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Univariate Bayesian spatial generalized linear model — spGLMexact","text":"object class spGLMexact, list following tags - priors details priors used, containing values boundary adjustment parameter (boundary), variance parameter fine-scale variation term (simasq.xi) others. samples list length 3, containing posterior samples fixed effects (beta), spatial effects (z) fine-scale variation term (xi). loopd loopd=TRUE, contains leave-one-predictive densities. model.params Values fixed parameters includes phi (spatial decay), nu (spatial smoothness). return object might include additional data can used subsequent prediction /model fit evaluation.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spGLMexact.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Univariate Bayesian spatial generalized linear model — spGLMexact","text":"function, fit Bayesian hierarchical spatial generalized linear model sampling exactly joint posterior distribution utilizing generalized conjugate multivariate distribution theory (Bradley Clinch 2024). Suppose \\(\\chi = (s_1, \\ldots, s_n)\\) denotes \\(n\\) spatial locations response \\(y\\) observed. Let \\(y(s)\\) outcome location \\(s\\) endowed probability law natural exponential family, denote $$ y(s) \\sim \\mathrm{EF}(x(s)^\\top \\beta + z(s); b, \\psi) $$ positive parameter \\(b > 0\\) unit log partition function \\(\\psi\\). consider following response models based input supplied argument family. 'poisson' considers point-referenced Poisson responses \\(y(s) \\sim \\mathrm{Poisson}(e^{x(s)^\\top \\beta + z(s)})\\). , \\(b = 1\\) \\(\\psi(t) = e^t\\). 'binomial' considers point-referenced binomial counts \\(y(s) \\sim \\mathrm{Binomial}(m(s), \\pi(s))\\) , \\(m(s)\\) denotes total number trials probability success \\(\\pi(s) = \\mathrm{ilogit}(x(s)^\\top \\beta + z(s))\\) location \\(s\\). , \\(b = m(s)\\) \\(\\psi(t) = \\log(1+e^t)\\). 'binary' considers point-referenced binary data (0 , 1) .e., \\(y(s) \\sim \\mathrm{Bernoulli}(\\pi(s))\\), probability success \\(\\pi(s) = \\mathrm{ilogit}(x(s)^\\top \\beta + z(s))\\) location \\(s\\). , \\(b = 1\\) \\(\\psi(t) = \\log(1 + e^t)\\). hierarchical model given $$ \\begin{aligned} y(s_i) &\\mid \\beta, z, \\xi \\sim EF(x(s_i)^\\top \\beta + z(s_i) + \\xi_i - \\mu_i; b_i, \\psi_y), = 1, \\ldots, n\\\\ \\xi &\\mid \\beta, z, \\sigma^2_\\xi, \\alpha_\\epsilon \\sim \\mathrm{GCM_c}(\\cdots),\\\\ \\beta &\\mid \\sigma^2_\\beta \\sim N(0, \\sigma^2_\\beta V_\\beta), \\quad \\sigma^2_\\beta \\sim \\mathrm{IG}(\\nu_\\beta/2, \\nu_\\beta/2)\\\\ z &\\mid \\sigma^2_z \\sim N(0, \\sigma^2_z R(\\chi; \\phi, \\nu)), \\quad \\sigma^2_z \\sim \\mathrm{IG}(\\nu_z/2, \\nu_z/2), \\end{aligned} $$ \\(\\mu = (\\mu_1, \\ldots, \\mu_n)^\\top\\) denotes discrepancy parameter. fix spatial process parameters \\(\\phi\\) \\(\\nu\\) hyperparameters \\(V_\\beta\\), \\(\\nu_\\beta\\), \\(\\nu_z\\) \\(\\sigma^2_\\xi\\). term \\(\\xi\\) known fine-scale variation term given conditional generalized conjugate multivariate distribution prior. details, see Pan et al. 2024. Default values \\(V_\\beta\\), \\(\\nu_\\beta\\), \\(\\nu_z\\), \\(\\sigma^2_\\xi\\) diagonal diagonal element 100, 2.1, 2.1 0.1 respectively.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spGLMexact.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Univariate Bayesian spatial generalized linear model — spGLMexact","text":"Bradley JR, Clinch M (2024). \"Generating Independent Replicates Directly Posterior Distribution Class Spatial Hierarchical Models.\" Journal Computational Graphical Statistics, 0(0), 1-17. doi:10.1080/10618600.2024.2365728 . Pan S, Zhang L, Bradley JR, Banerjee S (2024). \"Bayesian Inference Spatial-temporal Non-Gaussian Data Using Predictive Stacking.\" doi:10.48550/arXiv.2406.04655 . Vehtari , Gelman , Gabry J (2017). \"Practical Bayesian Model Evaluation Using Leave-One-Cross-Validation WAIC.\" Statistics Computing, 27(5), 1413-1432. ISSN 0960-3174. doi:10.1007/s11222-016-9696-4 .","code":""},{"path":[]},{"path":"https://span-18.github.io/spStack-dev/reference/spGLMexact.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Univariate Bayesian spatial generalized linear model — spGLMexact","text":"Soumyakanti Pan span18@ucla.edu","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spGLMexact.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Univariate Bayesian spatial generalized linear model — spGLMexact","text":"","code":"# Example 1: Analyze spatial poisson count data data(simPoisson) dat <- simPoisson[1:10, ] mod1 <- spGLMexact(y ~ x1, data = dat, family = \"poisson\",                    coords = as.matrix(dat[, c(\"s1\", \"s2\")]),                    cor.fn = \"matern\",                    spParams = list(phi = 4, nu = 0.4),                    n.samples = 100, verbose = TRUE) #> ---------------------------------------- #> \tModel description #> ---------------------------------------- #> Model fit with 10 observations. #>  #> Family = poisson. #>  #> Number of covariates 2 (including intercept). #>  #> Using the matern spatial correlation function. #>  #> Priors: #> \tbeta: Gaussian #> \tmu:\t0.00\t0.00\t #> \tcov: #> \t 100.00\t 0.00\t #> \t 0.00\t 100.00\t #>  #> \tsigmaSq.beta ~ IG(nu.beta/2, nu.beta/2) #> \tsigmaSq.z ~ IG(nu.z/2, nu.z/2) #> \tnu.beta = 2.10, nu.z = 2.10. #> \tsigmaSq.xi = 0.10. #> \tBoundary adjustment parameter = 0.50. #>  #> Spatial process parameters: #> \tphi = 4.00, and, nu = 0.40. #>  #> Number of posterior samples = 100. #> ----------------------------------------  # summarize posterior samples post_beta <- mod1$samples$beta print(t(apply(post_beta, 1, function(x) quantile(x, c(0.025, 0.5, 0.975))))) #>            2.5%        50%     97.5% #> [1,]  0.4031546  2.1316362 4.3996223 #> [2,] -1.2780079 -0.4119679 0.6808467  # Example 2: Analyze spatial binomial count data data(simBinom) dat <- simBinom[1:10, ] mod2 <- spGLMexact(cbind(y, n_trials) ~ x1, data = dat, family = \"binomial\",                    coords = as.matrix(dat[, c(\"s1\", \"s2\")]),                    cor.fn = \"matern\",                    spParams = list(phi = 3, nu = 0.4),                    n.samples = 100, verbose = TRUE) #> ---------------------------------------- #> \tModel description #> ---------------------------------------- #> Model fit with 10 observations. #>  #> Family = binomial. #>  #> Number of covariates 2 (including intercept). #>  #> Using the matern spatial correlation function. #>  #> Priors: #> \tbeta: Gaussian #> \tmu:\t0.00\t0.00\t #> \tcov: #> \t 100.00\t 0.00\t #> \t 0.00\t 100.00\t #>  #> \tsigmaSq.beta ~ IG(nu.beta/2, nu.beta/2) #> \tsigmaSq.z ~ IG(nu.z/2, nu.z/2) #> \tnu.beta = 2.10, nu.z = 2.10. #> \tsigmaSq.xi = 0.10. #> \tBoundary adjustment parameter = 0.50. #>  #> Spatial process parameters: #> \tphi = 3.00, and, nu = 0.40. #>  #> Number of posterior samples = 100. #> ----------------------------------------  # summarize posterior samples post_beta <- mod2$samples$beta print(t(apply(post_beta, 1, function(x) quantile(x, c(0.025, 0.5, 0.975))))) #>            2.5%        50%     97.5% #> [1,] -0.6230326  1.0619639 2.6529332 #> [2,] -1.9705288 -0.5585171 0.4772962  # Example 3: Analyze spatial binary data data(simBinary) dat <- simBinary[1:10, ] mod3 <- spGLMexact(y ~ x1, data = dat, family = \"binary\",                    coords = as.matrix(dat[, c(\"s1\", \"s2\")]),                    cor.fn = \"matern\",                    spParams = list(phi = 4, nu = 0.4),                    n.samples = 100, verbose = TRUE) #> ---------------------------------------- #> \tModel description #> ---------------------------------------- #> Model fit with 10 observations. #>  #> Family = binary. #>  #> Number of covariates 2 (including intercept). #>  #> Using the matern spatial correlation function. #>  #> Priors: #> \tbeta: Gaussian #> \tmu:\t0.00\t0.00\t #> \tcov: #> \t 100.00\t 0.00\t #> \t 0.00\t 100.00\t #>  #> \tsigmaSq.beta ~ IG(nu.beta/2, nu.beta/2) #> \tsigmaSq.z ~ IG(nu.z/2, nu.z/2) #> \tnu.beta = 2.10, nu.z = 2.10. #> \tsigmaSq.xi = 0.10. #> \tBoundary adjustment parameter = 0.50. #>  #> Spatial process parameters: #> \tphi = 4.00, and, nu = 0.40. #>  #> Number of posterior samples = 100. #> ----------------------------------------  # summarize posterior samples post_beta <- mod3$samples$beta print(t(apply(post_beta, 1, function(x) quantile(x, c(0.025, 0.5, 0.975))))) #>           2.5%        50%    97.5% #> [1,] -1.099885  0.9949421 3.572417 #> [2,] -2.135907 -0.3900626 1.299150"},{"path":"https://span-18.github.io/spStack-dev/reference/spGLMstack.html","id":null,"dir":"Reference","previous_headings":"","what":"Bayesian spatial generalized linear model using predictive stacking — spGLMstack","title":"Bayesian spatial generalized linear model using predictive stacking — spGLMstack","text":"Fits Bayesian spatial generalized linear model collection candidate models constructed based candidate values model parameters specified user subsequently combines inference stacking predictive densities. See Pan, Zhang, Bradley, Banerjee (2024) details.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spGLMstack.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bayesian spatial generalized linear model using predictive stacking — spGLMstack","text":"","code":"spGLMstack(   formula,   data = parent.frame(),   family,   coords,   cor.fn,   priors,   params.list,   n.samples,   loopd.controls,   parallel = FALSE,   solver = \"ECOS\",   verbose = TRUE,   ... )"},{"path":"https://span-18.github.io/spStack-dev/reference/spGLMstack.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bayesian spatial generalized linear model using predictive stacking — spGLMstack","text":"formula symbolic description regression model fit. See example . data optional data frame containing variables model. found data, variables taken environment(formula), typically environment spLMstack called. family Specifies distribution response member exponential family. Supported options 'poisson', 'binomial' 'binary'. coords \\(n \\times 2\\) matrix observation coordinates \\(\\mathbb{R}^2\\) (e.g., easting northing). cor.fn quoted keyword specifies correlation function used model spatial dependence structure among observations. Supported covariance model key words : 'exponential' 'matern'. See details. priors (optional) list tag corresponding parameter name containing prior details. Valid tags include V.beta, nu.beta, nu.z sigmaSq.xi. params.list list containing candidate values spatial process parameters cor.fn used, , boundary parameter. n.samples number posterior samples generated. loopd.controls list details leave-one-predictive densities (LOO-PD) calculated. Valid tags include method, CV.K nMC. tag method can either 'exact' 'CV'. sample size 100, default 'CV' CV.K equal default value 10 (Gelman et al. 2024). tag nMC decides many Monte Carlo samples used evaluate leave-one-predictive densities, must least 500 (default). parallel logical. parallel=FALSE, parallelization plan, set user, ignored. parallel=TRUE, function inherits parallelization plan set user via function future::plan() . Depending parallel backend available, users may choose plan. details available https://cran.R-project.org/package=future. solver (optional) Specifies name solver used obtain optimal stacking weights candidate model. Default 'ECOS'. Users can use solvers supported CVXR-package package. verbose logical. TRUE, prints model-specific optimal stacking weights. ... currently additional argument.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spGLMstack.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bayesian spatial generalized linear model using predictive stacking — spGLMstack","text":"object class spGLMstack, list including following tags - family distribution responses indicated function call samples list length equal total number candidate models entry corresponding list length 3, containing posterior samples fixed effects (beta), spatial effects (z) fine-scale variation term (xi) particular model. loopd list length equal total number candidate models entry containing leave-one-predictive densities particular model. loopd.method list containing details algorithm used calculation leave-one-predictive densities. n.models number candidate models fit. candidate.models matrix n_model rows row containing details model parameters optimal weight. stacking.weights numeric vector length equal number candidate models storing optimal stacking weights. run.time proc_time object runtime details. solver.status solver status returned optimization routine. return object might include additional data useful subsequent prediction, model fit evaluation utilities.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spGLMstack.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Bayesian spatial generalized linear model using predictive stacking — spGLMstack","text":"Instead assigning prior process parameters \\(\\phi\\) \\(\\nu\\), boundary adjustment parameter \\(\\epsilon\\), consider set candidate models based candidate values parameters supplied user. Suppose set candidate models \\(\\mathcal{M} = \\{M_1, \\ldots, M_G\\}\\). \\(g = 1, \\ldots, G\\), sample posterior distribution \\(p(\\sigma^2, \\beta, z \\mid y, M_g)\\) model \\(M_g\\) find leave-one-predictive densities \\(p(y_i \\mid y_{-}, M_g)\\). solve optimization problem $$ \\begin{aligned} \\max_{w_1, \\ldots, w_G}& \\, \\frac{1}{n} \\sum_{= 1}^n \\log \\sum_{g = 1}^G w_g p(y_i \\mid y_{-}, M_g) \\\\ \\text{subject } & \\quad w_g \\geq 0, \\sum_{g = 1}^G w_g = 1 \\end{aligned} $$ find optimal stacking weights \\(\\hat{w}_1, \\ldots, \\hat{w}_G\\).","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spGLMstack.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Bayesian spatial generalized linear model using predictive stacking — spGLMstack","text":"Pan S, Zhang L, Bradley JR, Banerjee S (2024). \"Bayesian Inference Spatial-temporal Non-Gaussian Data Using Predictive Stacking.\" doi:10.48550/arXiv.2406.04655 . Vehtari , Simpson D, Gelman , Yao Y, Gabry J (2024). \"Pareto Smoothed Importance Sampling.\" Journal Machine Learning Research, 25(72), 1-58. URL https://jmlr.org/papers/v25/19-556.html.","code":""},{"path":[]},{"path":"https://span-18.github.io/spStack-dev/reference/spGLMstack.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Bayesian spatial generalized linear model using predictive stacking — spGLMstack","text":"Soumyakanti Pan span18@ucla.edu, Sudipto Banerjee sudipto@ucla.edu","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spGLMstack.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bayesian spatial generalized linear model using predictive stacking — spGLMstack","text":"","code":"# \\donttest{ set.seed(1234) data(\"simPoisson\") dat <- simPoisson[1:100,] mod1 <- spGLMstack(y ~ x1, data = dat, family = \"poisson\",                    coords = as.matrix(dat[, c(\"s1\", \"s2\")]), cor.fn = \"matern\",                   params.list = list(phi = c(3, 7, 10), nu = c(0.25, 0.5, 1.5),                                      boundary = c(0.5, 0.6)),                   n.samples = 1000,                   loopd.controls = list(method = \"CV\", CV.K = 10, nMC = 1000),                   parallel = TRUE, solver = \"ECOS\", verbose = TRUE) #>  #> STACKING WEIGHTS: #>  #>            | phi | nu   | boundary | weight | #> +----------+-----+------+----------+--------+ #> | Model 1  |    3|  0.25|       0.5| 0.000  | #> | Model 2  |    7|  0.25|       0.5| 0.000  | #> | Model 3  |   10|  0.25|       0.5| 0.000  | #> | Model 4  |    3|  0.50|       0.5| 0.000  | #> | Model 5  |    7|  0.50|       0.5| 0.000  | #> | Model 6  |   10|  0.50|       0.5| 0.000  | #> | Model 7  |    3|  1.50|       0.5| 0.379  | #> | Model 8  |    7|  1.50|       0.5| 0.000  | #> | Model 9  |   10|  1.50|       0.5| 0.000  | #> | Model 10 |    3|  0.25|       0.6| 0.000  | #> | Model 11 |    7|  0.25|       0.6| 0.000  | #> | Model 12 |   10|  0.25|       0.6| 0.000  | #> | Model 13 |    3|  0.50|       0.6| 0.000  | #> | Model 14 |    7|  0.50|       0.6| 0.000  | #> | Model 15 |   10|  0.50|       0.6| 0.000  | #> | Model 16 |    3|  1.50|       0.6| 0.000  | #> | Model 17 |    7|  1.50|       0.6| 0.621  | #> | Model 18 |   10|  1.50|       0.6| 0.000  | #> +----------+-----+------+----------+--------+ #>   # print(mod1$solver.status) # print(mod1$run.time)  post_samps <- stackedSampler(mod1) post_beta <- post_samps$beta print(t(apply(post_beta, 1, function(x) quantile(x, c(0.025, 0.5, 0.975))))) #>                   2.5%        50%      97.5% #> (Intercept) -0.3453064  2.0902024  4.7383619 #> x1          -0.7002986 -0.5688996 -0.4339641  post_z <- post_samps$z post_z_summ <- t(apply(post_z, 1, function(x) quantile(x, c(0.025, 0.5, 0.975))))  z_combn <- data.frame(z = dat$z_true,                       zL = post_z_summ[, 1],                       zM = post_z_summ[, 2],                       zU = post_z_summ[, 3])  library(ggplot2) plot_z <- ggplot(data = z_combn, aes(x = z)) +  geom_errorbar(aes(ymin = zL, ymax = zU),                width = 0.05, alpha = 0.15,                color = \"skyblue\") +  geom_point(aes(y = zM), size = 0.25,             color = \"darkblue\", alpha = 0.5) +  geom_abline(slope = 1, intercept = 0,              color = \"red\", linetype = \"solid\") +  xlab(\"True z\") + ylab(\"Posterior of z\") +  theme_bw() +  theme(panel.background = element_blank(),        aspect.ratio = 1) # }"},{"path":"https://span-18.github.io/spStack-dev/reference/spLMexact.html","id":null,"dir":"Reference","previous_headings":"","what":"Univariate Bayesian spatial linear model — spLMexact","title":"Univariate Bayesian spatial linear model — spLMexact","text":"Fits Bayesian spatial linear model spatial process parameters noise--spatial variance ratio fixed value supplied user. output contains posterior samples fixed effects, variance parameter, spatial random effects , required, leave-one-predictive densities.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spLMexact.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Univariate Bayesian spatial linear model — spLMexact","text":"","code":"spLMexact(   formula,   data = parent.frame(),   coords,   cor.fn,   priors,   spParams,   noise_sp_ratio,   n.samples,   loopd = FALSE,   loopd.method = \"exact\",   verbose = TRUE,   ... )"},{"path":"https://span-18.github.io/spStack-dev/reference/spLMexact.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Univariate Bayesian spatial linear model — spLMexact","text":"formula symbolic description regression model fit. See example . data optional data frame containing variables model. found data, variables taken environment(formula), typically environment spLMexact called. coords \\(n \\times 2\\) matrix observation coordinates \\(\\mathbb{R}^2\\) (e.g., easting northing). cor.fn quoted keyword specifies correlation function used model spatial dependence structure among observations. Supported covariance model key words : 'exponential' 'matern'. See details. priors list tag corresponding parameter name containing prior details. spParams fixed value spatial process parameters. noise_sp_ratio noise--spatial variance ratio. n.samples number posterior samples generated. loopd logical. loopd=TRUE, returns leave-one-predictive densities, using method given loopd.method. Default FALSE. loopd.method character. Ignored loopd=FALSE. loopd=TRUE, valid inputs 'exact' 'PSIS'. option 'exact' corresponds exact leave-one-predictive densities requires computation almost equivalent fitting model \\(n\\) times. option 'PSIS' faster finds approximate leave-one-predictive densities using Pareto-smoothed importance sampling (Gelman et al. 2024). verbose logical. verbose = TRUE, prints model description. ... currently additional argument.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spLMexact.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Univariate Bayesian spatial linear model — spLMexact","text":"object class spLMexact, list following tags - samples list length 3, containing posterior samples fixed effects (beta), variance parameter (sigmaSq), spatial effects (z). loopd loopd=TRUE, contains leave-one-predictive densities. model.params Values fixed parameters includes phi (spatial decay), nu (spatial smoothness) noise_sp_ratio (noise--spatial variance ratio). return object might include additional data used subsequent prediction /model fit evaluation.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spLMexact.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Univariate Bayesian spatial linear model — spLMexact","text":"Suppose \\(\\chi = (s_1, \\ldots, s_n)\\) denotes \\(n\\) spatial locations response \\(y\\) observed. function, fit conjugate Bayesian hierarchical spatial model $$ \\begin{aligned} y \\mid z, \\beta, \\sigma^2 &\\sim N(X\\beta + z, \\delta^2 \\sigma^2 I_n), \\quad z \\mid \\sigma^2 \\sim N(0, \\sigma^2 R(\\chi; \\phi, \\nu)), \\\\ \\beta \\mid \\sigma^2 &\\sim N(\\mu_\\beta, \\sigma^2 V_\\beta), \\quad \\sigma^2 \\sim \\mathrm{IG}(a_\\sigma, b_\\sigma) \\end{aligned} $$ fix spatial process parameters \\(\\phi\\) \\(\\nu\\), noise--spatial variance ratio \\(\\delta^2\\) hyperparameters \\(\\mu_\\beta\\), \\(V_\\beta\\), \\(a_\\sigma\\) \\(b_\\sigma\\). utilize composition sampling strategy sample model parameters joint posterior distribution can written $$ p(\\sigma^2, \\beta, z \\mid y) = p(\\sigma^2 \\mid y) \\times p(\\beta \\mid \\sigma^2, y) \\times p(z \\mid \\beta, \\sigma^2, y). $$ proceed first sampling \\(\\sigma^2\\) marginal posterior, given samples \\(\\sigma^2\\), sample \\(\\beta\\) subsequently, sample \\(z\\) conditioned posterior samples \\(\\beta\\) \\(\\sigma^2\\) (Banerjee 2020).","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spLMexact.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Univariate Bayesian spatial linear model — spLMexact","text":"Banerjee S (2020). \"Modeling massive spatial datasets using conjugate Bayesian linear modeling framework.\" Spatial Statistics, 37, 100417. ISSN 2211-6753. doi:10.1016/j.spasta.2020.100417 . Vehtari , Simpson D, Gelman , Yao Y, Gabry J (2024). \"Pareto Smoothed Importance Sampling.\" Journal Machine Learning Research, 25(72), 1-58. URL https://jmlr.org/papers/v25/19-556.html.","code":""},{"path":[]},{"path":"https://span-18.github.io/spStack-dev/reference/spLMexact.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Univariate Bayesian spatial linear model — spLMexact","text":"Soumyakanti Pan span18@ucla.edu, Sudipto Banerjee sudipto@ucla.edu","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spLMexact.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Univariate Bayesian spatial linear model — spLMexact","text":"","code":"# load data data(simGaussian) dat <- simGaussian[1:100, ]  # setup prior list muBeta <- c(0, 0) VBeta <- cbind(c(1.0, 0.0), c(0.0, 1.0)) sigmaSqIGa <- 2 sigmaSqIGb <- 0.1 prior_list <- list(beta.norm = list(muBeta, VBeta),                    sigma.sq.ig = c(sigmaSqIGa, sigmaSqIGb))  # supply fixed values of model parameters phi0 <- 3 nu0 <- 0.75 noise.sp.ratio <- 0.8  mod1 <- spLMexact(y ~ x1, data = dat,                   coords = as.matrix(dat[, c(\"s1\", \"s2\")]),                   cor.fn = \"matern\",                   priors = prior_list,                   spParams = list(phi = phi0, nu = nu0),                   noise_sp_ratio = noise.sp.ratio,                   n.samples = 100,                   loopd = TRUE, loopd.method = \"exact\") #> ---------------------------------------- #> \tModel description #> ---------------------------------------- #> Model fit with 100 observations. #>  #> Number of covariates 2 (including intercept). #>  #> Using the matern spatial correlation function. #>  #> Priors: #> \tbeta: Gaussian #> \tmu:\t0.00\t0.00\t #> \tcov: #> \t 1.00\t 0.00\t #> \t 0.00\t 1.00\t #>  #> \tsigma.sq: Inverse-Gamma #> \tshape = 2.00, scale = 0.10. #>  #> Spatial process parameters: #> \tphi = 3.00, and, nu = 0.75. #> Noise-to-spatial variance ratio = 0.80. #>  #> Number of posterior samples = 100. #>  #> LOO-PD calculation method = exact. #> ----------------------------------------  beta.post <- mod1$samples$beta z.post.median <- apply(mod1$samples$z, 1, median) dat$z.post.median <- z.post.median plot1 <- surfaceplot(dat, coords_name = c(\"s1\", \"s2\"),                      var_name = \"z_true\") plot2 <- surfaceplot(dat, coords_name = c(\"s1\", \"s2\"),                      var_name = \"z.post.median\") plot1  plot2"},{"path":"https://span-18.github.io/spStack-dev/reference/spLMstack.html","id":null,"dir":"Reference","previous_headings":"","what":"Bayesian spatial linear model using predictive stacking — spLMstack","title":"Bayesian spatial linear model using predictive stacking — spLMstack","text":"Fits Bayesian spatial linear model collection candidate models constructed based candidate values model parameters specified user subsequently combines inference stacking predictive densities. See Zhang, Tang Banerjee (2024) details.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spLMstack.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bayesian spatial linear model using predictive stacking — spLMstack","text":"","code":"spLMstack(   formula,   data = parent.frame(),   coords,   cor.fn,   priors,   params.list,   n.samples,   loopd.method,   parallel = FALSE,   solver = \"ECOS\",   verbose = TRUE,   ... )"},{"path":"https://span-18.github.io/spStack-dev/reference/spLMstack.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bayesian spatial linear model using predictive stacking — spLMstack","text":"formula symbolic description regression model fit. See example . data optional data frame containing variables model. found data, variables taken environment(formula), typically environment spLMstack called. coords \\(n \\times 2\\) matrix observation coordinates \\(\\mathbb{R}^2\\) (e.g., easting northing). cor.fn quoted keyword specifies correlation function used model spatial dependence structure among observations. Supported covariance model key words : 'exponential' 'matern'. See details. priors list tag corresponding parameter name containing prior details. supplied, uses defaults. params.list list containing candidate values spatial process parameters cor.fn used, , noise--spatial variance ratio. n.samples number posterior samples generated. loopd.method character. Valid inputs 'exact' 'PSIS'. option 'exact' corresponds exact leave-one-predictive densities. option 'PSIS' faster, finds approximate leave-one-predictive densities using Pareto-smoothed importance sampling (Gelman et al. 2024). parallel logical. parallel=FALSE, parallelization plan, set user, ignored. parallel=TRUE, function inherits parallelization plan set user via function future::plan() . Depending parallel backend available, users may choose plan. details available https://cran.R-project.org/package=future. solver (optional) Specifies name solver used obtain optimal stacking weights candidate model. Default \"ECOS\". Users can use solvers supported CVXR-package package. verbose logical. TRUE, prints model-specific optimal stacking weights. ... currently additional argument.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spLMstack.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bayesian spatial linear model using predictive stacking — spLMstack","text":"object class spLMstack, list including following tags - samples list length equal total number candidate models entry corresponding list length 3, containing posterior samples fixed effects (beta), variance parameter (sigmaSq), spatial effects (z) model. loopd list length equal total number candidate models entry containing leave-one-predictive densities particular model. n.models number candidate models fit. candidate.models matrix n_model rows row containing details model parameters optimal weight. stacking.weights numeric vector length equal number candidate models storing optimal stacking weights. run.time proc_time object runtime details. solver.status solver status returned optimization routine. return object might include additional data useful subsequent prediction, model fit evaluation utilities.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spLMstack.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Bayesian spatial linear model using predictive stacking — spLMstack","text":"Instead assigning prior process parameters \\(\\phi\\) \\(\\nu\\), noise--spatial variance ratio \\(\\delta^2\\), consider set candidate models based candidate values parameters supplied user. Suppose set candidate models \\(\\mathcal{M} = \\{M_1, \\ldots, M_G\\}\\). \\(g = 1, \\ldots, G\\), sample posterior distribution \\(p(\\sigma^2, \\beta, z \\mid y, M_g)\\) model \\(M_g\\) find leave-one-predictive densities \\(p(y_i \\mid y_{-}, M_g)\\). solve optimization problem $$  \\begin{aligned}  \\max_{w_1, \\ldots, w_G}& \\, \\frac{1}{n} \\sum_{= 1}^n \\log \\sum_{g = 1}^G  w_g p(y_i \\mid y_{-}, M_g) \\\\  \\text{subject } & \\quad w_g \\geq 0, \\sum_{g = 1}^G w_g = 1  \\end{aligned}  $$ find optimal stacking weights \\(\\hat{w}_1, \\ldots, \\hat{w}_G\\).","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spLMstack.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Bayesian spatial linear model using predictive stacking — spLMstack","text":"Vehtari , Simpson D, Gelman , Yao Y, Gabry J (2024). \"Pareto Smoothed Importance Sampling.\" Journal Machine Learning Research, 25(72), 1-58. URL https://jmlr.org/papers/v25/19-556.html. Zhang L, Tang W, Banerjee S (2024). \"Bayesian Geostatistics Using Predictive Stacking.\" doi:10.48550/arXiv.2304.12414 .","code":""},{"path":[]},{"path":"https://span-18.github.io/spStack-dev/reference/spLMstack.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Bayesian spatial linear model using predictive stacking — spLMstack","text":"Soumyakanti Pan span18@ucla.edu, Sudipto Banerjee sudipto@ucla.edu","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spLMstack.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bayesian spatial linear model using predictive stacking — spLMstack","text":"","code":"set.seed(1234) # load data and work with first 100 rows data(simGaussian) dat <- simGaussian[1:100, ]  # setup prior list muBeta <- c(0, 0) VBeta <- cbind(c(1.0, 0.0), c(0.0, 1.0)) sigmaSqIGa <- 2 sigmaSqIGb <- 2 prior_list <- list(beta.norm = list(muBeta, VBeta),                    sigma.sq.ig = c(sigmaSqIGa, sigmaSqIGb))  mod1 <- spLMstack(y ~ x1, data = dat,                   coords = as.matrix(dat[, c(\"s1\", \"s2\")]),                   cor.fn = \"matern\",                   priors = prior_list,                   params.list = list(phi = c(1.5, 3),                                      nu = c(0.5, 1),                                      noise_sp_ratio = c(1)),                   n.samples = 1000, loopd.method = \"exact\",                   parallel = FALSE, solver = \"ECOS\", verbose = TRUE) #>  #> STACKING WEIGHTS: #>  #>           | phi | nu  | noise_sp_ratio | weight | #> +---------+-----+-----+----------------+--------+ #> | Model 1 |  1.5|  0.5|               1| 0      | #> | Model 2 |  3.0|  0.5|               1| 0      | #> | Model 3 |  1.5|  1.0|               1| 0      | #> | Model 4 |  3.0|  1.0|               1| 1      | #> +---------+-----+-----+----------------+--------+ #>   post_samps <- stackedSampler(mod1) post_beta <- post_samps$beta print(t(apply(post_beta, 1, function(x) quantile(x, c(0.025, 0.5, 0.975))))) #>                 2.5%      50%    97.5% #> (Intercept) 0.878944 1.739341 2.612417 #> x1          4.745753 4.925319 5.076682  post_z <- post_samps$z post_z_summ <- t(apply(post_z, 1,                        function(x) quantile(x, c(0.025, 0.5, 0.975))))  z_combn <- data.frame(z = dat$z_true,                       zL = post_z_summ[, 1],                       zM = post_z_summ[, 2],                       zU = post_z_summ[, 3])  library(ggplot2) plot1 <- ggplot(data = z_combn, aes(x = z)) +   geom_point(aes(y = zM), size = 0.25,              color = \"darkblue\", alpha = 0.5) +   geom_errorbar(aes(ymin = zL, ymax = zU),                 width = 0.05, alpha = 0.15) +   geom_abline(slope = 1, intercept = 0,               color = \"red\", linetype = \"solid\") +   xlab(\"True z\") + ylab(\"Stacked posterior of z\") +   theme_bw() +   theme(panel.background = element_blank(),         aspect.ratio = 1)"},{"path":"https://span-18.github.io/spStack-dev/reference/spStack-package.html","id":null,"dir":"Reference","previous_headings":"","what":"spStack: Bayesian Geostatistics Using Predictive Stacking — spStack-package","title":"spStack: Bayesian Geostatistics Using Predictive Stacking — spStack-package","text":"package delivers functions fit Bayesian hierarchical spatial process models point-referenced Gaussian, Poisson, binomial, binary data using stacking predictive densities. involves sampling analytically available posterior distributions conditional upon candidate values spatial process parameters Gaussian response model well non-Gaussian responses, , subsequently assimilate inference individual posterior distributions using Bayesian predictive stacking. algorithm highly parallelizable hence, much faster traditional Markov chain Monte Carlo algorithms delivering competitive predictive performance. context inference spatial point-referenced data, Bayesian hierarchical models involve latent spatial processes characterized spatial process parameters, besides lacking substantive relevance scientific contexts, also weakly identified hence, impedes convergence MCMC algorithms. motivates us build methodology involves fast sampling posterior distributions conditioned grid weakly identified model parameters combine inference stacking predictive densities (Yao et. al 2018). exploit Bayesian conjugate linear modeling framework Gaussian case (Zhang, Tang Banerjee 2024) generalized conjugate multivariate distribution theory (Pan, Zhang, Bradley Banerjee 2024) analytically derive individual posterior distributions.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spStack-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"spStack: Bayesian Geostatistics Using Predictive Stacking — spStack-package","text":"Accepts formula, e.g., y~x1+x2, regression models accompanied candidate values spatial process parameters, returns posterior samples regression coefficients latent spatial random effects. Posterior inference prediction quantity interest proceed samples. Main functions - spLMexact()spGLMexact()spLMstack()spGLMstack()","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/spStack-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"spStack: Bayesian Geostatistics Using Predictive Stacking — spStack-package","text":"Zhang L, Tang W, Banerjee S (2025). \"Bayesian Geostatistics Using Predictive Stacking.\" doi:10.48550/arXiv.2304.12414 . Pan S, Zhang L, Bradley JR, Banerjee S (2025). \"Bayesian Inference Spatial-temporal Non-Gaussian Data Using Predictive Stacking.\" doi:10.48550/arXiv.2406.04655 . Yao Y, Vehtari , Simpson D, Gelman (2018). \"Using Stacking Average Bayesian Predictive Distributions (Discussion).\" Bayesian Analysis, 13(3), 917-1007. doi:10.1214/17-BA1091 .","code":""},{"path":[]},{"path":"https://span-18.github.io/spStack-dev/reference/spStack-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"spStack: Bayesian Geostatistics Using Predictive Stacking — spStack-package","text":"Maintainer: Soumyakanti Pan span18@ucla.edu (ORCID) Authors: Sudipto Banerjee sudipto@ucla.edu","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/stackedSampler.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample from the stacked posterior distribution — stackedSampler","title":"Sample from the stacked posterior distribution — stackedSampler","text":"helper function sample stacked posterior distribution obtain final posterior samples can used subsequent analysis. function applies outputs functions spLMstack() spGLMstack().","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/stackedSampler.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample from the stacked posterior distribution — stackedSampler","text":"","code":"stackedSampler(mod_out, n.samples)"},{"path":"https://span-18.github.io/spStack-dev/reference/stackedSampler.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample from the stacked posterior distribution — stackedSampler","text":"mod_out object output model fit prediction task, .e., class either spLMstack, 'pp.spLMstack', spGLMstack, pp.spGLMstack, stvcGLMexact, pp.stvcGLMexact. n.samples (optional) missing, inherits number posterior samples original output. Otherwise, specifies number posterior samples draw stacked posterior. exceeds number posterior draws used original function, message thrown samples obtained resampling. recommended running original model fit/prediction enough samples.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/stackedSampler.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample from the stacked posterior distribution — stackedSampler","text":"object class stacked_posterior, list includes following tags - beta samples fixed effect stacked joint posterior. z samples spatial random effects stacked joint posterior. list may also include scale parameters corresponding model.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/stackedSampler.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sample from the stacked posterior distribution — stackedSampler","text":"obtaining optimal stacking weights \\(\\hat{w}_1, \\ldots, \\hat{w}_G\\), posterior inference quantities interest subsequently proceed stacked posterior, $$ \\tilde{p}(\\cdot \\mid y) = \\sum_{g = 1}^G \\hat{w}_g p(\\cdot \\mid y, M_g), $$ \\(\\mathcal{M} = \\{M_1, \\ldots, M_g\\}\\) collection candidate models.","code":""},{"path":[]},{"path":"https://span-18.github.io/spStack-dev/reference/stackedSampler.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Sample from the stacked posterior distribution — stackedSampler","text":"Soumyakanti Pan span18@ucla.edu, Sudipto Banerjee sudipto@ucla.edu","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/stackedSampler.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample from the stacked posterior distribution — stackedSampler","text":"","code":"set.seed(1234) data(simGaussian) dat <- simGaussian[1:100, ]  mod1 <- spLMstack(y ~ x1, data = dat,                   coords = as.matrix(dat[, c(\"s1\", \"s2\")]),                   cor.fn = \"matern\",                   params.list = list(phi = c(1.5, 3),                                      nu = c(0.5, 1),                                      noise_sp_ratio = c(1)),                   n.samples = 1000, loopd.method = \"exact\",                   parallel = FALSE, solver = \"ECOS\", verbose = TRUE) #>  #> STACKING WEIGHTS: #>  #>           | phi | nu  | noise_sp_ratio | weight | #> +---------+-----+-----+----------------+--------+ #> | Model 1 |  1.5|  0.5|               1| 0.000  | #> | Model 2 |  3.0|  0.5|               1| 0.285  | #> | Model 3 |  1.5|  1.0|               1| 0.000  | #> | Model 4 |  3.0|  1.0|               1| 0.715  | #> +---------+-----+-----+----------------+--------+ #>  print(mod1$solver.status) #> [1] \"optimal\" print(mod1$run.time) #>    user  system elapsed  #>   0.317   0.416   0.239   post_samps <- stackedSampler(mod1) post_beta <- post_samps$beta print(t(apply(post_beta, 1, function(x) quantile(x, c(0.025, 0.5, 0.975))))) #>                 2.5%      50%    97.5% #> (Intercept) 1.638227 2.377214 3.099662 #> x1          4.848999 4.980607 5.093982"},{"path":"https://span-18.github.io/spStack-dev/reference/stvcGLMexact.html","id":null,"dir":"Reference","previous_headings":"","what":"Bayesian spatially-temporally varying generalized linear model — stvcGLMexact","title":"Bayesian spatially-temporally varying generalized linear model — stvcGLMexact","text":"Fits Bayesian generalized linear model spatially-temporally varying coefficients fixed values spatial-temporal process parameters auxiliary model parameters. output contains posterior samples fixed effects, spatial-temporal random effects , required, finds leave-one-predictive densities.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/stvcGLMexact.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bayesian spatially-temporally varying generalized linear model — stvcGLMexact","text":"","code":"stvcGLMexact(   formula,   data = parent.frame(),   family,   sp_coords,   time_coords,   cor.fn,   process.type,   sptParams,   priors,   boundary = 0.5,   n.samples,   loopd = FALSE,   loopd.method = \"exact\",   CV.K = 10,   loopd.nMC = 500,   verbose = TRUE,   ... )"},{"path":"https://span-18.github.io/spStack-dev/reference/stvcGLMexact.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bayesian spatially-temporally varying generalized linear model — stvcGLMexact","text":"formula symbolic description regression model fit. Variables parenthesis assigned spatially-temporally varying coefficients. See examples. data optional data frame containing variables model. found data, variables taken environment(formula), typically environment stvcGLMexact called. family Specifies distribution response member exponential family. Supported options 'poisson', 'binomial' 'binary'. sp_coords \\(n \\times 2\\) matrix observation spatial coordinates \\(\\mathbb{R}^2\\) (e.g., easting northing). time_coords \\(n \\times 1\\) matrix observation temporal coordinates \\(\\mathcal{T} \\subseteq [0, \\infty)\\). cor.fn quoted keyword specifies correlation function used model spatial-temporal dependence structure among observations. Supported covariance model key words : 'gneiting-decay' (Gneiting Guttorp 2010). See details. process.type quoted keyword specifying model spatial-temporal process. Supported keywords 'independent' indicates independent processes varying coefficients characterized different process parameters, independent.shared implies independent processes varying coefficients shares common process parameters, multivariate implies correlated processes varying coefficients modeled multivariate Gaussian process inverse-Wishart prior correlation matrix. input sptParams priors must given accordingly. sptParams fixed values spatial-temporal process parameters usually list length 2. cor.fn='gneiting-decay', list length 2 tags phi_s phi_t. process.type='independent', phi_s phi_t contain fixed values \\(r\\) spatial-temporal processes, otherwise contain scalars. See examples . priors (optional) list tag corresponding hyperparameter name containing hyperprior details. Valid tags include V.beta, nu.beta, nu.z, sigmaSq.xi IW.scale. Values nu.beta nu.z must least 2.1. supplied, uses defaults. boundary Specifies boundary adjustment parameter. Must real number 0 1. Default 0.5. n.samples number posterior samples generated. loopd logical. loopd=TRUE, returns leave-one-predictive densities, using method given loopd.method. Default FALSE. loopd.method character. Ignored loopd=FALSE. loopd=TRUE, valid inputs 'exact', 'CV'. option 'exact' corresponds exact leave-one-predictive densities requires computation almost equivalent fitting model \\(n\\) times. options 'CV' faster implements \\(K\\)-fold cross validation find approximate leave-one-predictive densities (Vehtari et al. 2017). CV.K integer 10 20. Considered loopd.method='CV'. Default 10 (recommended Vehtari et. al 2017). loopd.nMC Number Monte Carlo samples used evaluate leave-one-predictive densities loopd.method set either 'exact' 'CV'. verbose logical. verbose = TRUE, prints model description. ... currently additional argument.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/stvcGLMexact.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bayesian spatially-temporally varying generalized linear model — stvcGLMexact","text":"object class stvcGLMexact, list following tags - priors details priors used, containing values boundary adjustment parameter (boundary), variance parameter fine-scale variation term (simasq.xi) others. samples list length 3, containing posterior samples fixed effects (beta), spatial-temporal effects (z) fine-scale variation term (xi). element tag z list length \\(r\\), containing posterior samples spatial-temporal random effects corresponding varying coefficient. loopd loopd=TRUE, contains leave-one-predictive densities. model.params Values fixed parameters includes phi_s (spatial decay), phi_t (temporal smoothness). return object might include additional data can used subsequent prediction /model fit evaluation.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/stvcGLMexact.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Bayesian spatially-temporally varying generalized linear model — stvcGLMexact","text":"function, fit Bayesian hierarchical spatially-temporally varying generalized linear model sampling exactly joint posterior distribution utilizing generalized conjugate multivariate distribution theory (Bradley Clinch 2024). Suppose \\(\\chi = (\\ell_1, \\ldots, \\ell_n)\\) denotes \\(n\\) spatial-temporal co-ordinates \\(\\mathcal{L} = \\mathcal{S} \\times \\mathcal{T}\\), response \\(y\\) observed. Let \\(y(\\ell)\\) outcome co-ordinate \\(\\ell\\) endowed probability law natural exponential family, denote $$ y(\\ell) \\sim \\mathrm{EF}(x(\\ell)^\\top \\beta + \\tilde{x}(\\ell)^\\top z(\\ell); b(\\ell), \\psi) $$ positive parameter \\(b(\\ell) > 0\\) unit log partition function \\(\\psi\\). , \\(\\tilde{x}(\\ell)\\) denotes covariates spatially-temporally varying coefficients consider following response models based input supplied argument family. 'poisson' considers point-referenced Poisson responses \\(y(\\ell) \\sim \\mathrm{Poisson}(e^{x(\\ell)^\\top \\beta + \\tilde{x}(\\ell)^\\top z(\\ell)})\\). , \\(b(\\ell) = 1\\) \\(\\psi(t) = e^t\\). 'binomial' considers point-referenced binomial counts \\(y(\\ell) \\sim \\mathrm{Binomial}(m(\\ell), \\pi(\\ell))\\) , \\(m(\\ell)\\) denotes total number trials probability success \\(\\pi(\\ell) = \\mathrm{ilogit}(x(\\ell)^\\top \\beta + \\tilde{x}(\\ell)^\\top z(\\ell))\\) spatial-temporal co-ordinate \\(\\ell\\). , \\(b = m(\\ell)\\) \\(\\psi(t) = \\log(1+e^t)\\). 'binary' considers point-referenced binary data (0 , 1) .e., \\(y(\\ell) \\sim \\mathrm{Bernoulli}(\\pi(\\ell))\\), probability success \\(\\pi(\\ell) = \\mathrm{ilogit}(x(\\ell)^\\top \\beta + \\tilde{x}(\\ell)^\\top z(\\ell))\\) spatial-temporal co-ordinate \\(\\ell\\). , \\(b(\\ell) = 1\\) \\(\\psi(t) = \\log(1 + e^t)\\). hierarchical model given $$ \\begin{aligned} y(\\ell_i) &\\mid \\beta, z, \\xi \\sim EF(x(\\ell_i)^\\top \\beta + \\tilde{x}(\\ell_i)^\\top z(s_i) + \\xi_i - \\mu_i; b_i, \\psi_y), = 1, \\ldots, n\\\\ \\xi &\\mid \\beta, z, \\sigma^2_\\xi, \\alpha_\\epsilon \\sim \\mathrm{GCM_c}(\\cdots),\\\\ \\beta &\\mid \\sigma^2_\\beta \\sim N(0, \\sigma^2_\\beta V_\\beta), \\quad \\sigma^2_\\beta \\sim \\mathrm{IG}(\\nu_\\beta/2, \\nu_\\beta/2)\\\\ z_j &\\mid \\sigma^2_{z_j} \\sim N(0, \\sigma^2_{z_j} R(\\chi; \\phi_s, \\phi_t)), \\quad \\sigma^2_{z_j} \\sim \\mathrm{IG}(\\nu_z/2, \\nu_z/2), j = 1, \\ldots, r \\end{aligned} $$ \\(\\mu = (\\mu_1, \\ldots, \\mu_n)^\\top\\) denotes discrepancy parameter. fix spatial-temporal process parameters \\(\\phi_s\\) \\(\\phi_t\\) hyperparameters \\(V_\\beta\\), \\(\\nu_\\beta\\), \\(\\nu_z\\) \\(\\sigma^2_\\xi\\). term \\(\\xi\\) known fine-scale variation term given conditional generalized conjugate multivariate distribution prior. details, see Pan et al. 2024. Default values \\(V_\\beta\\), \\(\\nu_\\beta\\), \\(\\nu_z\\), \\(\\sigma^2_\\xi\\) diagonal diagonal element 100, 2.1, 2.1 0.1 respectively.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/stvcGLMexact.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Bayesian spatially-temporally varying generalized linear model — stvcGLMexact","text":"Bradley JR, Clinch M (2024). \"Generating Independent Replicates Directly Posterior Distribution Class Spatial Hierarchical Models.\" Journal Computational Graphical Statistics, 0(0), 1-17. doi:10.1080/10618600.2024.2365728 . T. Gneiting P. Guttorp (2010). \"Continuous-parameter spatio-temporal processes.\" .E. Gelfand, P.J. Diggle, M. Fuentes, P Guttorp, editors, Handbook Spatial Statistics, Chapman & Hall CRC Handbooks Modern Statistical Methods, p 427–436. Taylor Francis. Pan S, Zhang L, Bradley JR, Banerjee S (2024). \"Bayesian Inference Spatial-temporal Non-Gaussian Data Using Predictive Stacking.\" doi:10.48550/arXiv.2406.04655 . Vehtari , Gelman , Gabry J (2017). \"Practical Bayesian Model Evaluation Using Leave-One-Cross-Validation WAIC.\" Statistics Computing, 27(5), 1413-1432. ISSN 0960-3174. doi:10.1007/s11222-016-9696-4 .","code":""},{"path":[]},{"path":"https://span-18.github.io/spStack-dev/reference/stvcGLMexact.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Bayesian spatially-temporally varying generalized linear model — stvcGLMexact","text":"Soumyakanti Pan span18@ucla.edu","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/stvcGLMexact.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bayesian spatially-temporally varying generalized linear model — stvcGLMexact","text":"","code":"data(\"sim_stvcPoisson\") dat <- sim_stvcPoisson[1:100, ]  # Fit a spatial-temporal varying coefficient Poisson GLM mod1 <- stvcGLMexact(y ~ x1 + (x1), data = dat, family = \"poisson\",                      sp_coords = as.matrix(dat[, c(\"s1\", \"s2\")]),                      time_coords = as.matrix(dat[, \"t_coords\"]),                      cor.fn = \"gneiting-decay\",                      process.type = \"multivariate\",                      sptParams = list(phi_s = 1, phi_t = 1),                      verbose = FALSE, n.samples = 100)"},{"path":"https://span-18.github.io/spStack-dev/reference/stvcGLMstack.html","id":null,"dir":"Reference","previous_headings":"","what":"Bayesian spatially-temporally varying coefficients generalized linear model using predictive stacking — stvcGLMstack","title":"Bayesian spatially-temporally varying coefficients generalized linear model using predictive stacking — stvcGLMstack","text":"Fits Bayesian spatial-temporal generalized linear model spatially-temporally varying coefficients collection candidate models constructed based candidate values model parameters specified user subsequently combines inference stacking predictive densities. See Pan, Zhang, Bradley, Banerjee (2024) details.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/stvcGLMstack.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bayesian spatially-temporally varying coefficients generalized linear model using predictive stacking — stvcGLMstack","text":"","code":"stvcGLMstack(   formula,   data = parent.frame(),   family,   sp_coords,   time_coords,   cor.fn,   process.type,   priors,   candidate.models,   n.samples,   loopd.controls,   parallel = FALSE,   solver = \"ECOS\",   verbose = TRUE,   ... )"},{"path":"https://span-18.github.io/spStack-dev/reference/stvcGLMstack.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bayesian spatially-temporally varying coefficients generalized linear model using predictive stacking — stvcGLMstack","text":"formula symbolic description regression model fit. Variables parenthesis assigned spatially-temporally varying coefficients. See examples. data optional data frame containing variables model. found data, variables taken environment(formula), typically environment stvcGLMstack called. family Specifies distribution response member exponential family. Supported options 'poisson', 'binomial' 'binary'. sp_coords \\(n \\times 2\\) matrix observation spatial coordinates \\(\\mathbb{R}^2\\) (e.g., easting northing). time_coords \\(n \\times 1\\) matrix observation temporal coordinates \\(\\mathcal{T} \\subseteq [0, \\infty)\\). cor.fn quoted keyword specifies correlation function used model spatial-temporal dependence structure among observations. Supported covariance model key words : 'gneiting-decay' (Gneiting Guttorp 2010). See details. process.type quoted keyword specifying model spatial-temporal process. Supported keywords 'independent' indicates independent processes varying coefficients characterized different process parameters, independent.shared implies independent processes varying coefficients shares common process parameters, multivariate implies correlated processes varying coefficients modeled multivariate Gaussian process inverse-Wishart prior correlation matrix. input sptParams priors must given accordingly. priors (optional) list tag corresponding hyperparameter name containing hyperprior details. Valid tags include V.beta, nu.beta, nu.z, sigmaSq.xi IW.scale. Values nu.beta nu.z must least 2.1. supplied, uses defaults. candidate.models object class candidateModels containing list candidate models stacking. See candidateModels() details. n.samples number samples drawn posterior distribution. loopd.controls list details leave-one-predictive densities (LOO-PD) calculated. Valid tags include method, CV.K nMC. tag method can either 'exact' 'CV'. sample size 100, default 'CV' CV.K equal default value 10 (Gelman et al. 2024). tag nMC decides many Monte Carlo samples used evaluate leave-one-predictive densities, must least 500 (default). parallel logical. parallel=FALSE, parallelization plan, set user, ignored. parallel=TRUE, function inherits parallelization plan set user via function future::plan() . Depending parallel backend available, users may choose plan. details available https://cran.R-project.org/package=future. solver (optional) Specifies name solver used obtain optimal stacking weights candidate model. Default 'ECOS'. Users can use solvers supported CVXR-package package. verbose logical. TRUE, prints model-specific optimal stacking weights. ... currently additional argument.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/stvcGLMstack.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bayesian spatially-temporally varying coefficients generalized linear model using predictive stacking — stvcGLMstack","text":"object class stvcGLMstack, list including following tags - samples list length equal total number candidate models entry corresponding list length 3, containing posterior samples fixed effects (beta), spatial effects (z), fine scale variation xi model. loopd list length equal total number candidate models entry containing leave-one-predictive densities particular model. n.models number candidate models fit. candidate.models list length n_model rows entry containing details model parameters. stacking.weights numeric vector length equal number candidate models storing optimal stacking weights. run.time proc_time object runtime details. solver.status solver status returned optimization routine. object can used recover posterior samples scale parameters model, subsequrently, make predictions new locations times using function posteriorPredict().","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/stvcGLMstack.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bayesian spatially-temporally varying coefficients generalized linear model using predictive stacking — stvcGLMstack","text":"","code":"# \\donttest{ set.seed(1234) data(\"sim_stvcPoisson\") dat <- sim_stvcPoisson[1:100, ]  # create list of candidate models (multivariate) mod.list2 <- candidateModels(list(phi_s = list(2, 3),                                   phi_t = list(1, 2),                                   boundary = c(0.5, 0.75)), \"cartesian\")  # fit a spatial-temporal varying coefficient model using predictive stacking mod1 <- stvcGLMstack(y ~ x1 + (x1), data = dat, family = \"poisson\",                      sp_coords = as.matrix(dat[, c(\"s1\", \"s2\")]),                      time_coords = as.matrix(dat[, \"t_coords\"]),                      cor.fn = \"gneiting-decay\",                      process.type = \"multivariate\",                      candidate.models = mod.list2,                      loopd.controls = list(method = \"CV\", CV.K = 10, nMC = 500),                      n.samples = 500) #>  #> STACKING WEIGHTS: #>  #>           | phi_s | phi_t | boundary | weight | #> +---------+-------+-------+----------+--------+ #> | Model 1 |      2|      1|      0.50| 0.000  | #> | Model 2 |      3|      1|      0.50| 0.244  | #> | Model 3 |      2|      2|      0.50| 0.000  | #> | Model 4 |      3|      2|      0.50| 0.100  | #> | Model 5 |      2|      1|      0.75| 0.000  | #> | Model 6 |      3|      1|      0.75| 0.000  | #> | Model 7 |      2|      2|      0.75| 0.000  | #> | Model 8 |      3|      2|      0.75| 0.657  | #> +---------+-------+-------+----------+--------+ #>  # }"},{"path":"https://span-18.github.io/spStack-dev/reference/surfaceplot.html","id":null,"dir":"Reference","previous_headings":"","what":"Make a surface plot — surfaceplot","title":"Make a surface plot — surfaceplot","text":"Make surface plot","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/surfaceplot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make a surface plot — surfaceplot","text":"","code":"surfaceplot(tab, coords_name, var_name, h = 8, col.pal, mark_points = FALSE)"},{"path":"https://span-18.github.io/spStack-dev/reference/surfaceplot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make a surface plot — surfaceplot","text":"tab data-frame containing spatial co-ordinates variable plot coords_name name two columns contains co-ordinates points var_name name column containing variable plotted h integer; (optional) controls smoothness spatial interpolation appearing MBA::mba.surf() function. Default 8. col.pal Optional; color palette, preferably divergent, use colorRampPalette function grDevices. Default 'RdYlBu'. mark_points Logical; TRUE, input points marked. Default FALSE.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/surfaceplot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make a surface plot — surfaceplot","text":"ggplot object containing surface plot","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/surfaceplot.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Make a surface plot — surfaceplot","text":"Soumyakanti Pan span18@ucla.edu, Sudipto Banerjee sudipto@ucla.edu","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/surfaceplot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make a surface plot — surfaceplot","text":"","code":"data(simGaussian) plot1 <- surfaceplot(simGaussian, coords_name = c(\"s1\", \"s2\"),                      var_name = \"z_true\") plot1   # try your favourite color palette col.br <- colorRampPalette(c(\"blue\", \"white\", \"red\")) col.br.pal <- col.br(100) plot2 <- surfaceplot(simGaussian, coords_name = c(\"s1\", \"s2\"),                      var_name = \"z_true\", col.pal = col.br.pal) plot2"},{"path":"https://span-18.github.io/spStack-dev/reference/surfaceplot2.html","id":null,"dir":"Reference","previous_headings":"","what":"Make two side-by-side surface plots — surfaceplot2","title":"Make two side-by-side surface plots — surfaceplot2","text":"Make two side--side surface plots, particularly useful towards comparative study two spatial surfaces.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/surfaceplot2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make two side-by-side surface plots — surfaceplot2","text":"","code":"surfaceplot2(   tab,   coords_name,   var1_name,   var2_name,   h = 8,   col.pal,   mark_points = FALSE )"},{"path":"https://span-18.github.io/spStack-dev/reference/surfaceplot2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make two side-by-side surface plots — surfaceplot2","text":"tab data-frame containing spatial co-ordinates variables plot coords_name name two columns contains co-ordinates points var1_name name column containing first variable plotted var2_name name column containing second variable plotted h integer; (optional) controls smoothness spatial interpolation appearing MBA::mba.surf() function. Default 8. col.pal Optional; color palette, preferably divergent, use colorRampPalette function grDevices. Default 'RdYlBu'. mark_points Logical; TRUE, input points marked. Default FALSE.","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/surfaceplot2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make two side-by-side surface plots — surfaceplot2","text":"list containing two ggplot objects","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/surfaceplot2.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Make two side-by-side surface plots — surfaceplot2","text":"Soumyakanti Pan span18@ucla.edu, Sudipto Banerjee sudipto@ucla.edu","code":""},{"path":"https://span-18.github.io/spStack-dev/reference/surfaceplot2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make two side-by-side surface plots — surfaceplot2","text":"","code":"data(simGaussian) plots_2 <- surfaceplot2(simGaussian, coords_name = c(\"s1\", \"s2\"),                         var1_name = \"z_true\", var2_name = \"y\") plots_2 #> [[1]]  #>  #> [[2]]  #>"},{"path":"https://span-18.github.io/spStack-dev/news/index.html","id":"spstack-111","dir":"Changelog","previous_headings":"","what":"spStack 1.1.1","title":"spStack 1.1.1","text":"lmulm_XTilde_VC(), lmulv_XTilde_VC(): Fixed address sanitizer issue string comparison pointer string literal.","code":""},{"path":"https://span-18.github.io/spStack-dev/news/index.html","id":"spstack-110","dir":"Changelog","previous_headings":"","what":"spStack 1.1.0","title":"spStack 1.1.0","text":"CRAN release: 2025-07-12 stvcGLMexact(), stvcGLMstack(): New functions spatially-temporally varying coefficients GLM. posteriorPredict(): New functions posterior predictive inference using predictive stacking. recoverGLMscale(): Utility recovering posterior samples scale parameters spatial spatial-temporal GLMs.","code":""},{"path":"https://span-18.github.io/spStack-dev/news/index.html","id":"spstack-101","dir":"Changelog","previous_headings":"","what":"spStack 1.0.1","title":"spStack 1.0.1","text":"CRAN release: 2024-10-08 Fix memory leak issue.","code":""},{"path":"https://span-18.github.io/spStack-dev/news/index.html","id":"spstack-100","dir":"Changelog","previous_headings":"","what":"spStack 1.0.0","title":"spStack 1.0.0","text":"CRAN release: 2024-10-03 Initial CRAN submission.","code":""}]
