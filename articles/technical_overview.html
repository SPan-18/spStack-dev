<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Technical Overview â€¢ spStack</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Technical Overview">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" integrity="sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js" integrity="sha384-7zkQWkzuo3B5mTepMUcHkMB5jZaolc2xDwL6VFqjFALcbeS9Ggm/Yr2r3Dy4lfFg" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">spStack</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="Released version">1.1.1</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../articles/spStack.html">Get started</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/posterior-predictive.html">Posterior Predictive Inference</a></li>
    <li><a class="dropdown-item" href="../articles/spatial-temporal.html">Spatial-Temporal Regression Models</a></li>
    <li><a class="dropdown-item" href="../articles/spatial.html">Spatial Regression Models</a></li>
    <li><a class="dropdown-item" href="../articles/technical_overview.html">Technical Overview</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/SPan-18/spStack-dev/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Technical Overview</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/SPan-18/spStack-dev/blob/master/vignettes/technical_overview.Rmd" class="external-link"><code>vignettes/technical_overview.Rmd</code></a></small>
      <div class="d-none name"><code>technical_overview.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>Geostatistics refers to the study of a spatially distributed variable
of interest, which in theory is defined at every point over a bounded
study region of interest. Statistical modelling and analysis for
spatially oriented point-referenced outcomes play a crucial role in
diverse scientific applications such as earth and environmental
sciences, ecology, epidemiology, and economics. With the advent of
Markov chain Monte Carlo (MCMC) algorithms, Bayesian hierarchical models
have gained massive popularity in analyzing such point-referenced or,
geostatistical data. These models involve latent spatial processes
characterized by spatial process parameters, which besides lacking
substantive relevance in scientific contexts, are also weakly identified
and hence, impedes convergence of MCMC algorithms. Thus, even for
moderately large datasets
(~<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>10</mn><mn>3</mn></msup><annotation encoding="application/x-tex">10^3</annotation></semantics></math>
or higher), the computation for MCMC becomes too onerous for practical
use.</p>
<p>We introduce the R package <code>spStack</code> that implements
Bayesian inference for a class of geostatistical models, where we
obviate the issues mentioned by sampling from analytically available
posterior distributions conditional upon some candidate values of the
spatial process parameters and, subsequently assimilate inference from
these individual posterior distributions using Bayesian predictive
stacking. Besides delivering competitive predictive performance as
compared to fully Bayesian inference using MCMC, our proposed algorithm
is embarrassingly parallel, thus drastically improves runtime and
elevating the utility of the package for a diverse group of
practitioners with limited computational resources at their disposal.
This package, to the best of our knowledge, is the first to implement
stacking for Bayesian analysis of spatial data.</p>
<p>Technical details surrounding the methodology can be found in the
articles <span class="citation">Zhang, Tang, and Banerjee (<a href="#ref-zhang2024stacking">2025</a>)</span> which discuss the case
where the distribution of the point-referenced outcomes are Gaussian,
and, in <span class="citation">Pan et al. (<a href="#ref-pan2024stacking">2025</a>)</span> where the case of
non-Gaussian outcomes is explored. The code for this package is written
primarily in C/C++ with additional calls to FORTRAN routines for
optimized linear algebra operations. We leverage the
<code>F77_NAME</code> macro to interface with legacy FORTRAN functions
in conjunction with efficient matrix computation libraries such as <a href="https://netlib.org/blas/" class="external-link">BLAS</a> (Basic Linear Algebra
Subprograms) and <a href="https://netlib.org/lapack/" class="external-link">LAPACK</a> (Linear
Algebra Package) to implement our stacking algorithm.</p>
<p>The remainder of the vignette evolves as follows - the next two
sections discuss Bayesian hierarchical spatial models for Gaussian and
non-Gaussian outcomes, which is followed by a section providing brief
details on predictive stacking and a section dedicated for illustration
of functions in the package.</p>
</div>
<div class="section level2">
<h2 id="bayesian-gaussian-spatial-regression-models">Bayesian Gaussian spatial regression models<a class="anchor" aria-label="anchor" href="#bayesian-gaussian-spatial-regression-models"></a>
</h2>
Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Ï‡</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>s</mi><mn>1</mn></msub><mo>,</mo><mi>â€¦</mi><mo>,</mo><msub><mi>s</mi><mi>n</mi></msub><mo stretchy="false" form="postfix">}</mo><mo>âˆˆ</mo><mi>ğ’Ÿ</mi></mrow><annotation encoding="application/x-tex">\chi = \{s_1, \ldots, s_n\} \in \mathcal{D}</annotation></semantics></math>
be a be a set of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
spatial locations yielding measurements
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>y</mi><mn>1</mn></msub><mo>,</mo><mi>â€¦</mi><mo>,</mo><msub><mi>y</mi><mi>n</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>âŠ¤</mi></msup></mrow><annotation encoding="application/x-tex">y = (y_1, \ldots, y_n)^{ \scriptstyle \top }</annotation></semantics></math>
with known values of predictors at these locations collected in the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>Ã—</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">n \times p</annotation></semantics></math>
full rank matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">[</mo><mi>x</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>â€¦</mi><mo>,</mo><mi>x</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>n</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mi>âŠ¤</mi></msup></mrow><annotation encoding="application/x-tex">X = [x(s_1), \ldots, x(s_n)]^{ \scriptstyle \top }</annotation></semantics></math>.
A customary geostatistical model is
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mi>x</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>âŠ¤</mi></msup><mi>Î²</mi><mo>+</mo><mi>z</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>Ïµ</mi><mi>i</mi></msub><mo>,</mo><mspace width="1.0em"></mspace><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>â€¦</mi><mo>,</mo><mi>n</mi><mo>,</mo></mrow><annotation encoding="application/x-tex">\begin{equation}
  y_i = x(s_i)^{ \scriptstyle \top }\beta + z(s_i) + \epsilon_i, \quad i = 1, \ldots, n,
\end{equation}</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Î²</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>
is the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>Ã—</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p \times 1</annotation></semantics></math>
vector of slopes,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>âˆ¼</mo><mrow><mi>ğ–¦</mi><mi>ğ–¯</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mi>R</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>â‹…</mo><mo>,</mo><mo>â‹…</mo><mo>;</mo><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">z(s) \sim \mathsf{GP}(0, R(\cdot, \cdot; {\theta_{\text{sp}}}))</annotation></semantics></math>
is a zero-centered spatial Gaussian process on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’Ÿ</mi><annotation encoding="application/x-tex">\mathcal{D}</annotation></semantics></math>
with spatial correlation function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>â‹…</mo><mo>,</mo><mo>â‹…</mo><mo>;</mo><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">R(\cdot, \cdot; {\theta_{\text{sp}}})</annotation></semantics></math>
characterized by process parameters
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub><annotation encoding="application/x-tex">{\theta_{\text{sp}}}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>Ïƒ</mi><mn>2</mn></msup><annotation encoding="application/x-tex">\sigma^2</annotation></semantics></math>
is the spatial variance parameter (â€œpartial sillâ€) and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Ïµ</mi><mi>i</mi></msub><mo>âˆ¼</mo><mi>ğ–­</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msup><mi>Ï„</mi><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>â€¦</mi><mo>,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\epsilon_i \sim \mathsf{N}(0, \tau^2), i = 1, \ldots, n</annotation></semantics></math>
are i.i.d. with variance
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>Ï„</mi><mn>2</mn></msup><annotation encoding="application/x-tex">\tau^2</annotation></semantics></math>
(â€œnuggetâ€) capturing measurement error. The spatial process
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>â‹…</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">z(\cdot)</annotation></semantics></math>
is assumed to be independent of the measurement errors
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msub><mi>Ïµ</mi><mi>i</mi></msub><mo>,</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>â€¦</mi><mo>,</mo><mi>n</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{\epsilon_i, i = 1, \ldots, n\}</annotation></semantics></math>.
Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>â€¦</mi><mo>,</mo><mi>z</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>n</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mi>âŠ¤</mi></msup></mrow><annotation encoding="application/x-tex">z = (z(s_1), \ldots, z(s_n))^{ \scriptstyle \top }</annotation></semantics></math>
denotes the realization of the spatial process on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Ï‡</mi><annotation encoding="application/x-tex">\chi</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>Ã—</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n \times n</annotation></semantics></math>
correlation matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Ï‡</mi><mo>;</mo><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>R</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo>,</mo><msub><mi>s</mi><mi>j</mi></msub><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mn>1</mn><mo>â‰¤</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo>â‰¤</mo><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">R(\chi; {\theta_{\text{sp}}}) = (R(s_i, s_j {\theta_{\text{sp}}}))_{1 \leq i,j \leq n}</annotation></semantics></math>.
We build a conjugate Bayesian hierarchical spatial model,
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>y</mi><mo>âˆ£</mo><mi>z</mi><mo>,</mo><mi>Î²</mi><mo>,</mo><msup><mi>Ïƒ</mi><mn>2</mn></msup></mtd><mtd columnalign="left" style="text-align: left"><mo>âˆ¼</mo><mi>ğ–­</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>X</mi><mi>Î²</mi><mo>+</mo><mi>z</mi><mo>,</mo><msup><mi>Î´</mi><mn>2</mn></msup><msup><mi>Ïƒ</mi><mn>2</mn></msup><msub><mi>I</mi><mi>n</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>z</mi><mo>âˆ£</mo><msup><mi>Ïƒ</mi><mn>2</mn></msup></mtd><mtd columnalign="left" style="text-align: left"><mo>âˆ¼</mo><mi>ğ–­</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msup><mi>Ïƒ</mi><mn>2</mn></msup><mi>R</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Ï‡</mi><mo>;</mo><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>Î²</mi><mo>âˆ£</mo><msup><mi>Ïƒ</mi><mn>2</mn></msup></mtd><mtd columnalign="left" style="text-align: left"><mo>âˆ¼</mo><mi>ğ–­</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Î¼</mi><mi>Î²</mi></msub><mo>,</mo><msup><mi>Ïƒ</mi><mn>2</mn></msup><msub><mi>V</mi><mi>Î²</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="1.0em"></mspace><msup><mi>Ïƒ</mi><mn>2</mn></msup><mo>âˆ¼</mo><mrow><mi>ğ–¨</mi><mi>ğ–¦</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>a</mi><mi>Ïƒ</mi></msub><mo>,</mo><msub><mi>b</mi><mi>Ïƒ</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr></mtable></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\begin{split}
y \mid z, \beta, \sigma^2 &amp;\sim \mathsf{N}(X\beta + z, \delta^2 \sigma^2 I_n), \\
z \mid \sigma^2 &amp;\sim \mathsf{N}(0, \sigma^2 R(\chi; {\theta_{\text{sp}}})), \\
\beta \mid \sigma^2 &amp;\sim \mathsf{N}(\mu_\beta, \sigma^2 V_\beta), \quad
\sigma^2 \sim \mathsf{IG}(a_\sigma, b_\sigma),
\end{split}
\end{aligned}</annotation></semantics></math><p>where we fix the noise-to-spatial variance ratio
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Î´</mi><mn>2</mn></msup><mo>=</mo><msup><mi>Ï„</mi><mn>2</mn></msup><mi>/</mi><msup><mi>Ïƒ</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\delta^2 = \tau^2 / \sigma^2</annotation></semantics></math>,
the process parameters
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub><annotation encoding="application/x-tex">{\theta_{\text{sp}}}</annotation></semantics></math>
and the hyperparameters
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Î¼</mi><mi>Î²</mi></msub><annotation encoding="application/x-tex">\mu_\beta</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>V</mi><mi>Î²</mi></msub><annotation encoding="application/x-tex">V_\beta</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mi>Ïƒ</mi></msub><annotation encoding="application/x-tex">a_\sigma</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>b</mi><mi>Ïƒ</mi></msub><annotation encoding="application/x-tex">b_\sigma</annotation></semantics></math>.
In this package, we use the Matern covariogram specified by spatial
decay parameter
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Ï•</mi><annotation encoding="application/x-tex">\phi</annotation></semantics></math>
and smoothness parameter
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Î½</mi><annotation encoding="application/x-tex">\nu</annotation></semantics></math>
i.e.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>Ï•</mi><mo>,</mo><mi>Î½</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">{\theta_{\text{sp}}}= \{\phi, \nu\}</annotation></semantics></math>,
given by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo>,</mo><mi>s</mi><mi>â€²</mi><mo>;</mo><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>Ï•</mi><mo stretchy="false" form="prefix">|</mo><mi>s</mi><mo>âˆ’</mo><mi>s</mi><mi>â€²</mi><mo stretchy="false" form="postfix">|</mo><mo stretchy="true" form="postfix">)</mo></mrow><mi>Î½</mi></msup><mrow><msup><mn>2</mn><mrow><mi>Î½</mi><mo>âˆ’</mo><mn>1</mn></mrow></msup><mi>Î“</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Î½</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><msub><mi>K</mi><mi>Î½</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>Ï•</mi><mo stretchy="false" form="prefix">|</mo><mi>s</mi><mo>âˆ’</mo><mi>s</mi><mi>â€²</mi><mo stretchy="false" form="postfix">|</mo><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="false" form="postfix">)</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation}
R(s, s'; {\theta_{\text{sp}}}) = \frac{(\phi \lvert s - s' \rvert)^\nu}{2^{\nu - 1} \Gamma(\nu)} K_\nu (\phi \lvert s - s' \rvert)).
\end{equation}</annotation></semantics></math> We utilize a composition
sampling strategy to sample the model parameters from their joint
posterior distribution which can be written as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>Ïƒ</mi><mn>2</mn></msup><mo>,</mo><mi>Î²</mi><mo>,</mo><mi>z</mi><mo>âˆ£</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>p</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>Ïƒ</mi><mn>2</mn></msup><mo>âˆ£</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>Ã—</mo><mi>p</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Î²</mi><mo>âˆ£</mo><msup><mi>Ïƒ</mi><mn>2</mn></msup><mo>,</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>Ã—</mo><mi>p</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo>âˆ£</mo><mi>Î²</mi><mo>,</mo><msup><mi>Ïƒ</mi><mn>2</mn></msup><mo>,</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation}
p(\sigma^2, \beta, z \mid y) = p(\sigma^2 \mid y) \times
p(\beta \mid \sigma^2, y) \times p(z \mid \beta, \sigma^2, y).
\end{equation}</annotation></semantics></math> We proceed by first
sampling
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>Ïƒ</mi><mn>2</mn></msup><annotation encoding="application/x-tex">\sigma^2</annotation></semantics></math>
from its marginal posterior, then given the samples of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>Ïƒ</mi><mn>2</mn></msup><annotation encoding="application/x-tex">\sigma^2</annotation></semantics></math>,
we sample
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Î²</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>
and subsequently, we sample
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>
conditioned on the posterior samples of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Î²</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>Ïƒ</mi><mn>2</mn></msup><annotation encoding="application/x-tex">\sigma^2</annotation></semantics></math><span class="citation">(<a href="#ref-banerjee_massivespatial">Banerjee
2020</a>)</span>. More details can be found in <span class="citation">Zhang, Tang, and Banerjee (<a href="#ref-zhang2024stacking">2025</a>)</span>.</p>
<p>The function <code><a href="../reference/spLMexact.html">spLMexact()</a></code> delivers samples from this
posterior distribution conditional on fixed hyperparameters. For
predictive stacking, use the function <code><a href="../reference/spLMstack.html">spLMstack()</a></code>.</p>
</div>
<div class="section level2">
<h2 id="bayesian-non-gaussian-spatial-regression-models">Bayesian non-Gaussian spatial regression models<a class="anchor" aria-label="anchor" href="#bayesian-non-gaussian-spatial-regression-models"></a>
</h2>
<p>Analyzing non-Gaussian spatial data typically requires introducing
spatial dependence in generalized linear models through the link
function of an exponential family distribution. Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">y(s)</annotation></semantics></math>
be the outcome at location
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>âˆˆ</mo><mi>ğ’Ÿ</mi></mrow><annotation encoding="application/x-tex">s \in \mathcal{D}</annotation></semantics></math>
endowed with a probability law from the natural exponential family,
which we denote by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>âˆ¼</mo><mrow><mi>ğ–¤</mi><mi>ğ–¥</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>âŠ¤</mi></msup><mi>Î²</mi><mo>+</mo><mi>z</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>;</mo><mi>b</mi><mo>,</mo><msub><mi>Ïˆ</mi><mi>y</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{equation}
    y(s) \sim \mathsf{EF}(x(s)^{ \scriptstyle \top }\beta  + z(s); b, \psi_y)
\end{equation}</annotation></semantics></math> for some positive
parameter
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">b &gt; 0</annotation></semantics></math>
and unit log partition function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Ïˆ</mi><mi>y</mi></msub><annotation encoding="application/x-tex">\psi_y</annotation></semantics></math>.
Fixed effects regression and spatial dependence, e.g.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>âŠ¤</mi></msup><mi>Î²</mi><mo>+</mo><mi>z</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">x(s)^{{ \scriptstyle \top }}\beta + z(s)</annotation></semantics></math>,
is introduced in the natural parameter, where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">x(s)</annotation></semantics></math>
is a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>Ã—</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p \times 1</annotation></semantics></math>
vector of predictors referenced with respect to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Î²</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>
is a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>Ã—</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p \times 1</annotation></semantics></math>
vector of slopes measuring the trend,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">z(s)</annotation></semantics></math>
is a zero-centered spatial process on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’Ÿ</mi><annotation encoding="application/x-tex">\mathcal{D}</annotation></semantics></math>
specified by a scale parameter
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Ïƒ</mi><mi>z</mi></msub><annotation encoding="application/x-tex">\sigma_z</annotation></semantics></math>
and a spatial correlation function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>â‹…</mo><mo>,</mo><mo>â‹…</mo><mo>;</mo><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">R(\cdot, \cdot ; {\theta_{\text{sp}}})</annotation></semantics></math>
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub><annotation encoding="application/x-tex">{\theta_{\text{sp}}}</annotation></semantics></math>
consisting of spatial-temporal decay and smoothness parameters.</p>
<p>Unlike in Gaussian likelihoods, inference is considerably encumbered
by the inability to analytically integrate out the random effects and
reduce the dimension of the parameter space. Iterative algorithms such
as Markov Chain Monte Carlo (MCMC), thus attempt to sample from a very
high-dimensional posterior distribution, and convergence is often
hampered by high auto-correlations and weakly identified spatial process
parameters
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub><annotation encoding="application/x-tex">{\theta_{\text{sp}}}</annotation></semantics></math>.</p>
<p>This model is implemented using the function
<code><a href="../reference/spGLMexact.html">spGLMexact()</a></code> when using fixed hyperparameters, and
<code><a href="../reference/spGLMstack.html">spGLMstack()</a></code> when using predictive stacking.</p>
<p>We consider the following three point-referenced data -</p>
<ul>
<li><p><strong>Poisson count data</strong>: Here
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">b = 1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Ïˆ</mi><mi>y</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mi>e</mi><mi>t</mi></msup></mrow><annotation encoding="application/x-tex">\psi_y(t) = e^t</annotation></semantics></math>.
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>âˆ¼</mo><mrow><mi>ğ–¯</mi><mi>ğ—ˆ</mi><mi>ğ—‚</mi><mi>ğ—Œ</mi><mi>ğ—Œ</mi><mi>ğ—ˆ</mi><mi>ğ—‡</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>Î»</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="1.0em"></mspace><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>â€¦</mi><mo>,</mo><mi>n</mi><mi>.</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>Î»</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>âŠ¤</mi></msup><mi>Î²</mi><mo>+</mo><mi>z</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{equation}
\begin{split}
y(s_i) &amp;\sim \mathsf{Poisson}(\lambda(s_i)), \quad i = 1, \dots, n.\\
\lambda(s_i) &amp; = \exp(x(s_i)^{ \scriptstyle \top }\beta + z(s_i))
\end{split}
\end{equation}</annotation></semantics></math> This is accessed by
setting <code>family = "poisson"</code> in the above functions.</p></li>
<li><p><strong>Binomial count data</strong>: Here
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mi>m</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">b = m(s_i)</annotation></semantics></math>
for each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Ïˆ</mi><mi>y</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>+</mo><msup><mi>e</mi><mi>t</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\psi_y(t) = \log(1 + e^t)</annotation></semantics></math>.
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>âˆ¼</mo><mrow><mi>ğ–¡</mi><mi>ğ—‚</mi><mi>ğ—‡</mi><mi>ğ—ˆ</mi><mi>ğ—†</mi><mi>ğ—‚</mi><mi>ğ–º</mi><mi>ğ—…</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>Ï€</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="1.0em"></mspace><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>â€¦</mi><mo>,</mo><mi>n</mi><mi>.</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>Ï€</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">t</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>âŠ¤</mi></msup><mi>Î²</mi><mo>+</mo><mi>z</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{equation}
\begin{split}
y(s_i) &amp;\sim \mathsf{Binomial}(m(s_i), \pi(s_i)), \quad i = 1, \dots, n.\\
\pi(s_i) &amp; = \mathrm{ilogit}(x(s_i)^{ \scriptstyle \top }\beta + z(s_i))
\end{split}
\end{equation}</annotation></semantics></math> This is accessed by
setting <code>family = "binomial"</code> in the above
functions.</p></li>
<li><p><strong>Binary data</strong>: Here
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">b = 1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Ïˆ</mi><mi>y</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>+</mo><msup><mi>e</mi><mi>t</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\psi_y(t) = \log(1 + e^t)</annotation></semantics></math>.
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>âˆ¼</mo><mrow><mi>ğ–¡</mi><mi>ğ–¾</mi><mi>ğ—‹</mi><mi>ğ—‡</mi><mi>ğ—ˆ</mi><mi>ğ—</mi><mi>ğ—…</mi><mi>ğ—…</mi><mi>ğ—‚</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>Ï€</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="1.0em"></mspace><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>â€¦</mi><mo>,</mo><mi>n</mi><mi>.</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>Ï€</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">t</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>âŠ¤</mi></msup><mi>Î²</mi><mo>+</mo><mi>z</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{equation}
\begin{split}
y(s_i) &amp;\sim \mathsf{Bernoulli}(\pi(s_i)), \quad i = 1, \dots, n.\\
\pi(s_i) &amp; = \mathrm{ilogit}(x(s_i)^{ \scriptstyle \top }\beta + z(s_i))
\end{split}
\end{equation}</annotation></semantics></math> This is accessed by
setting <code>family = "binary"</code> in the above functions.</p></li>
</ul>
<p>Following <span class="citation">Bradley and Clinch (<a href="#ref-bradleyclinch2024">2024</a>)</span>, we introduce a Bayesian
hierarchical spatial model as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>âˆ£</mo><mi>Î²</mi><mo>,</mo><mi>z</mi><mo>,</mo><mi>Î¾</mi></mtd><mtd columnalign="left" style="text-align: left"><mo>âˆ¼</mo><mrow><mi>ğ–¤</mi><mi>ğ–¥</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>âŠ¤</mi></msup><mi>Î²</mi><mo>+</mo><mi>z</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>Î¾</mi><mi>i</mi></msub><mo>âˆ’</mo><msub><mi>Î¼</mi><mi>i</mi></msub><mo>;</mo><msub><mi>b</mi><mi>i</mi></msub><mo>,</mo><msub><mi>Ïˆ</mi><mi>y</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>â€¦</mi><mo>,</mo><mi>n</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>Î²</mi><mo>âˆ£</mo><msubsup><mi>Ïƒ</mi><mi>Î²</mi><mn>2</mn></msubsup></mtd><mtd columnalign="left" style="text-align: left"><mo>âˆ¼</mo><mi>ğ–­</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msubsup><mi>Ïƒ</mi><mi>Î²</mi><mn>2</mn></msubsup><msub><mi>V</mi><mi>Î²</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="1.0em"></mspace><msubsup><mi>Ïƒ</mi><mi>Î²</mi><mn>2</mn></msubsup><mo>âˆ¼</mo><mrow><mi>ğ–¨</mi><mi>ğ–¦</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Î½</mi><mi>Î²</mi></msub><mi>/</mi><mn>2</mn><mo>,</mo><msub><mi>Î½</mi><mi>Î²</mi></msub><mi>/</mi><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>z</mi><mo>âˆ£</mo><msubsup><mi>Ïƒ</mi><mi>z</mi><mn>2</mn></msubsup></mtd><mtd columnalign="left" style="text-align: left"><mo>âˆ¼</mo><mi>ğ–­</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msubsup><mi>Ïƒ</mi><mi>z</mi><mn>2</mn></msubsup><mi>R</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Ï‡</mi><mo>;</mo><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="1.0em"></mspace><msubsup><mi>Ïƒ</mi><mi>z</mi><mn>2</mn></msubsup><mo>âˆ¼</mo><mrow><mi>ğ–¨</mi><mi>ğ–¦</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Î½</mi><mi>z</mi></msub><mi>/</mi><mn>2</mn><mo>,</mo><msub><mi>Î½</mi><mi>z</mi></msub><mi>/</mi><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>Î¾</mi><mo>âˆ£</mo><mi>Î²</mi><mo>,</mo><mi>z</mi><mo>,</mo><msubsup><mi>Ïƒ</mi><mi>Î¾</mi><mn>2</mn></msubsup><mo>,</mo><msub><mi>Î±</mi><mi>Ïµ</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>âˆ¼</mo><mrow><mi>ğ–¦</mi><mi>ğ–¢</mi><msub><mi>ğ–¬</mi><mi>ğ–¼</mi></msub></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>Î¼</mi><mo accent="true">Ìƒ</mo></mover><mi>Î¾</mi></msub><mo>,</mo><msub><mi>H</mi><mi>Î¾</mi></msub><mo>,</mo><mi>Ïµ</mi><mo>,</mo><msub><mi>Îº</mi><mi>Î¾</mi></msub><mo>;</mo><msub><mi>Ïˆ</mi><mi>Î¾</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{equation}
\begin{split}
y(s_i) \mid \beta, z, \xi &amp; \sim \mathsf{EF}\left(x(s_i)^{ \scriptstyle \top }\beta + z(s_i) +
\xi_i - \mu_i; b_i, \psi_y\right), i = 1, \ldots, n\\
\beta \mid \sigma^2_\beta &amp;\sim \mathsf{N}(0, \sigma^2_\beta V_\beta), \quad
\sigma^2_\beta \sim \mathsf{IG}(\nu_\beta/2, \nu_\beta/2)\\
z \mid \sigma^2_z &amp;\sim \mathsf{N}\left(0, \sigma^2_z R(\chi; {\theta_{\text{sp}}})\right), \quad
\sigma^2_z \sim \mathsf{IG}(\nu_z/2, \nu_z/2),\\
\xi \mid \beta, z, \sigma^2_\xi, \alpha_\epsilon &amp;\sim
\mathsf{GCM_c}\left(\tilde{\mu}_\xi, H_\xi, \epsilon, \kappa_\xi; \psi_\xi\right),
\end{split}
\end{equation}</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Î¼</mi><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Î¼</mi><mn>1</mn></msub><mo>,</mo><mi>â€¦</mi><mo>,</mo><msub><mi>Î¼</mi><mi>n</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>âŠ¤</mi></msup></mrow><annotation encoding="application/x-tex">\mu = (\mu_1, \ldots, \mu_n)^{ \scriptstyle \top }</annotation></semantics></math>
denotes the discrepancy parameter. We fix the spatial process parameters
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub><annotation encoding="application/x-tex">{\theta_{\text{sp}}}</annotation></semantics></math>,
the boundary adjustment parameter
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Ïµ</mi><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math>
and the hyperparameters
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>V</mi><mi>Î²</mi></msub><annotation encoding="application/x-tex">V_\beta</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Î½</mi><mi>Î²</mi></msub><annotation encoding="application/x-tex">\nu_\beta</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Î½</mi><mi>z</mi></msub><annotation encoding="application/x-tex">\nu_z</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>Ïƒ</mi><mi>Î¾</mi><mn>2</mn></msubsup><annotation encoding="application/x-tex">\sigma^2_\xi</annotation></semantics></math>.
The term
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Î¾</mi><annotation encoding="application/x-tex">\xi</annotation></semantics></math>
is known as the fine-scale variation term which is given a conditional
generalized conjugate multivariate distribution
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">G</mi><mi mathvariant="normal">C</mi><msub><mi mathvariant="normal">M</mi><mi mathvariant="normal">c</mi></msub></mrow><annotation encoding="application/x-tex">\mathrm{GCM_c}</annotation></semantics></math>)
as prior. For details, see <span class="citation">Pan et al. (<a href="#ref-pan2024stacking">2025</a>)</span>.</p>
</div>
<div class="section level2">
<h2 id="bayesian-non-gaussian-spatial-temporal-regression-model">Bayesian non-Gaussian spatial-temporal regression model<a class="anchor" aria-label="anchor" href="#bayesian-non-gaussian-spatial-temporal-regression-model"></a>
</h2>
<p>We consider a rich family of Bayesian spatial-temporal model with
spatially-temporally varying regression coefficients. Suppose
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>â„“</mo><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo>,</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\ell = (s, t)</annotation></semantics></math>,
with location
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>âˆˆ</mo><mi>ğ’Ÿ</mi></mrow><annotation encoding="application/x-tex">s \in \mathcal{D}</annotation></semantics></math>
and time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>âˆˆ</mo><mi>ğ’¯</mi></mrow><annotation encoding="application/x-tex">t \in \mathcal{T}</annotation></semantics></math>,
denote a spatial-temporal coordinate in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>â„’</mi><mo>=</mo><mi>ğ’Ÿ</mi><mo>Ã—</mo><mi>ğ’¯</mi></mrow><annotation encoding="application/x-tex">\mathcal{L} = \mathcal{D} \times \mathcal{T}</annotation></semantics></math>.</p>
<p>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>â„’</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msub><mo>â„“</mo><mn>1</mn></msub><mo>,</mo><mi>â€¦</mi><mo>,</mo><msub><mo>â„“</mo><mi>n</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\mathcal{L} = \{\ell_1, \ldots, \ell_n\}</annotation></semantics></math>
be a fixed set of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
distinct space-time coordinates in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’Ÿ</mi><annotation encoding="application/x-tex">\mathcal{D}</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>â„’</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mo>â„“</mo><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>â€¦</mi><mo>,</mo><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mo>â„“</mo><mi>n</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mi>âŠ¤</mi></msup></mrow><annotation encoding="application/x-tex">y(\mathcal{L}) = (y(\ell_1), \dots, y(\ell_n))^\top</annotation></semantics></math>,
which we simply denote by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>,
is the vector of observed outcomes, each distributed as a member of the
natural exponential family with log partition function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Ïˆ</mi><mi>y</mi></msub><annotation encoding="application/x-tex">\psi_y</annotation></semantics></math>.
Suppose,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mo>â„“</mo><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">x(\ell_i)</annotation></semantics></math>
is a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>Ã—</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p\times 1</annotation></semantics></math>
vector of predictors,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Î²</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>
is the corresponding
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>Ã—</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p \times 1</annotation></semantics></math>
vector of slopes (fixed effects),
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>x</mi><mo accent="true">Ìƒ</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><msub><mo>â„“</mo><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\tilde{x}(\ell_i)</annotation></semantics></math>
is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>Ã—</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r\times 1</annotation></semantics></math>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>â‰¤</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">r \leq p</annotation></semantics></math>)
consisting of predictors in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mo>â„“</mo><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">x(\ell_i)</annotation></semantics></math>
that are posited to have spatially-temporally varying regression
coefficients
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mo>â„“</mo><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>z</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mo>â„“</mo><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>â€¦</mi><mo>,</mo><msub><mi>z</mi><mi>r</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mo>â„“</mo><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mi>âŠ¤</mi></msup></mrow><annotation encoding="application/x-tex">z(\ell_i) = (z_1(\ell_i), \ldots, z_r(\ell_i))^\top</annotation></semantics></math>,
where each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mo>â„“</mo><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">z_j(\ell_i)</annotation></semantics></math>
is a spatially-temporally varying coefficient for the predictor
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>x</mi><mo accent="true">Ìƒ</mo></mover><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mo>â„“</mo><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\tilde{x}_j(\ell_i)</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Î¾</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\xi_i</annotation></semantics></math>
is a fine-scale variation term and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Î¼</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\mu_i</annotation></semantics></math>
is the discrepancy parameter (see above). We introduce
spatially-temporally varying coefficients in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Î·</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>â„“</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\eta(\ell)</annotation></semantics></math>
as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mo>â„“</mo><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>âˆ£</mo><mi>Î²</mi><mo>,</mo><mi>z</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mo>â„“</mo><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><msub><mi>Î¾</mi><mi>i</mi></msub><mo>,</mo><msub><mi>Î¼</mi><mi>i</mi></msub><mover><mo>âˆ¼</mo><mtext mathvariant="normal">ind</mtext></mover><mrow><mi>ğ–¤</mi><mi>ğ–¥</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>Î·</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mo>â„“</mo><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>Î¾</mi><mi>i</mi></msub><mo>âˆ’</mo><msub><mi>Î¼</mi><mi>i</mi></msub><mo>;</mo><msub><mi>b</mi><mi>i</mi></msub><mo>,</mo><msub><mi>Ïˆ</mi><mi>y</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="0.222em"></mspace><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>â€¦</mi><mo>,</mo><mi>n</mi><mspace width="0.278em"></mspace><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>Î·</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>â„“</mo><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mi>x</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><mo>â„“</mo><mo stretchy="true" form="postfix">)</mo></mrow><mi>âŠ¤</mi></msup><mi>Î²</mi><mo>+</mo><mover><mi>x</mi><mo accent="true">Ìƒ</mo></mover><msup><mrow><mo stretchy="true" form="prefix">(</mo><mo>â„“</mo><mo stretchy="true" form="postfix">)</mo></mrow><mi>âŠ¤</mi></msup><mi>z</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>â„“</mo><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="1.0em"></mspace><mi>Î²</mi><mo>âˆ£</mo><msubsup><mi>Ïƒ</mi><mi>Î²</mi><mn>2</mn></msubsup><mo>,</mo><msub><mi>Î¼</mi><mi>Î²</mi></msub><mo>,</mo><msub><mi>V</mi><mi>Î²</mi></msub><mo>âˆ¼</mo><mi>ğ–­</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Î¼</mi><mi>Î²</mi></msub><mo>,</mo><msubsup><mi>Ïƒ</mi><mi>Î²</mi><mn>2</mn></msubsup><msub><mi>V</mi><mi>Î²</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="1.0em"></mspace><msubsup><mi>Ïƒ</mi><mi>Î²</mi><mn>2</mn></msubsup><mo>âˆ¼</mo><msub><mi>Ï€</mi><mi>Î²</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>Ïƒ</mi><mi>Î²</mi><mn>2</mn></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.278em"></mspace><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>z</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>â„“</mo><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>âˆ£</mo><msub><mi>Î¸</mi><mi>z</mi></msub><mo>,</mo><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub><mo>âˆ¼</mo><mrow><mi>ğ–¦</mi><mi>ğ–¯</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msub><mi>C</mi><mi>z</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mo>â‹…</mo><mo>,</mo><mo>â‹…</mo><mo>;</mo><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub><mo>,</mo><msub><mi>Î¸</mi><mi>z</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.278em"></mspace><mo>,</mo><mspace width="1.0em"></mspace><msub><mi>Î¸</mi><mi>z</mi></msub><mo>âˆ¼</mo><msub><mi>Ï€</mi><mi>z</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Î¸</mi><mi>z</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.278em"></mspace><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>Î¾</mi></mtd><mtd columnalign="left" style="text-align: left"><mo>âˆ£</mo><mi>Î²</mi><mo>,</mo><mi>z</mi><mo>,</mo><mi>Î¼</mi><mo>,</mo><msub><mi>Î±</mi><mi>Ïµ</mi></msub><mo>,</mo><msub><mi>Îº</mi><mi>Ïµ</mi></msub><mo>,</mo><msubsup><mi>Ïƒ</mi><mi>Î¾</mi><mn>2</mn></msubsup><mo>âˆ¼</mo><mrow><mi>ğ–¦</mi><mi>ğ–¢</mi><msub><mi>ğ–¬</mi><mi>ğ–¼</mi></msub></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>Î¼</mi><mo accent="true">Ìƒ</mo></mover><mi>Î¾</mi></msub><mo>,</mo><msub><mi>H</mi><mi>Î¾</mi></msub><mo>,</mo><msub><mi>Î±</mi><mi>Î¾</mi></msub><mo>,</mo><msub><mi>Îº</mi><mi>Î¾</mi></msub><mo>,</mo><msub><mi>D</mi><mi>Î¾</mi></msub><mo>,</mo><msub><mi>Ï€</mi><mi>Î¾</mi></msub><mo>;</mo><msub><mi>Ïˆ</mi><mi>Î¾</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="0.222em"></mspace><msubsup><mi>Ïƒ</mi><mi>Î¾</mi><mn>2</mn></msubsup><mo>âˆ¼</mo><msub><mi>Ï€</mi><mi>Î¾</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>Ïƒ</mi><mi>Î¾</mi><mn>2</mn></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="0.222em"></mspace><mi>p</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Î¼</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>âˆ</mo><mn>1</mn><mspace width="0.278em"></mspace><mo>,</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{equation}
\begin{split}
    y(\ell_i) &amp;\mid \beta, z(\ell_i), \xi_i, \mu_i \overset{\text{ind}}{\sim} \mathsf{EF}\left(\eta(\ell_i) + \xi_i - \mu_i; b_i, \psi_y \right), \ i=1,\ldots,n\;,\\
    \eta(\ell) &amp;= x(\ell)^{ \scriptstyle \top }\beta + \tilde{x}(\ell)^{{ \scriptstyle \top }}z(\ell), \quad  \beta \mid \sigma^2_\beta, \mu_\beta, V_\beta \sim \mathsf{N}(\mu_\beta, \sigma^2_\beta V_\beta), \quad \sigma^2_\beta \sim \pi_\beta(\sigma^2_\beta) \;,\\
    z(\ell) &amp;\mid \theta_z, {\theta_{\text{sp}}}\sim \mathsf{GP}(0, C_z(\cdot, \cdot; {\theta_{\text{sp}}}, \theta_z))\;,\quad \theta_z \sim \pi_{z}(\theta_z)\;, \\
    \xi &amp;\mid \beta, z, \mu, \alpha_\epsilon, \kappa_\epsilon, \sigma^2_\xi \sim \mathsf{GCM_c}(\tilde{\mu}_\xi, H_\xi, \alpha_\xi, \kappa_\xi, D_\xi, \pi_\xi; \psi_\xi), \ \sigma^2_\xi \sim \pi_\xi(\sigma^2_\xi), \ p(\mu) \propto 1 \;,
\end{split}
\end{equation}</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>â„“</mo><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>z</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mo>â„“</mo><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>â€¦</mi><mo>,</mo><msub><mi>z</mi><mi>r</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mo>â„“</mo><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mi>âŠ¤</mi></msup></mrow><annotation encoding="application/x-tex">z(\ell) = (z_1(\ell), \ldots, z_r(\ell))^{ \scriptstyle \top }</annotation></semantics></math>
is a multivariate Gaussian process with a separable cross-covariance
function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>z</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mo>â‹…</mo><mo>,</mo><mo>â‹…</mo><mo>;</mo><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub><mo>,</mo><msub><mi>Î¸</mi><mi>z</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">C_z(\cdot, \cdot; {\theta_{\text{sp}}}, \theta_z)</annotation></semantics></math>,
characterized by process parameters
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub><annotation encoding="application/x-tex">{\theta_{\text{sp}}}</annotation></semantics></math>
which controls the within-process spatial-temporal correlation, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Î¸</mi><mi>z</mi></msub><annotation encoding="application/x-tex">\theta_z</annotation></semantics></math>
which controls the between-process covariance matrix . Given
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Î¸</mi><mi>z</mi></msub><annotation encoding="application/x-tex">\theta_z</annotation></semantics></math>,
the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>r</mi><mo>Ã—</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">nr \times 1</annotation></semantics></math>
vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>z</mi><mn>1</mn><mi>âŠ¤</mi></msubsup><mo>,</mo><mi>â€¦</mi><mo>,</mo><msubsup><mi>z</mi><mi>r</mi><mi>âŠ¤</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mi>âŠ¤</mi></msup></mrow><annotation encoding="application/x-tex">z = (z_1^{ \scriptstyle \top }, \ldots, z_r^{ \scriptstyle \top })^{ \scriptstyle \top }</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mi>j</mi></msub><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>z</mi><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mo>â„“</mo><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>â€¦</mi><mo>,</mo><msub><mi>z</mi><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mo>â„“</mo><mi>n</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mi>âŠ¤</mi></msup></mrow><annotation encoding="application/x-tex">z_j = (z_j(\ell_1), \ldots, z_j(\ell_n))^{ \scriptstyle \top }</annotation></semantics></math>
for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>â€¦</mi><mo>,</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">j = 1, \ldots, r</annotation></semantics></math>,
follows a multivariate Gaussian distribution with mean
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>r</mi><mo>Ã—</mo><mi>n</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">nr \times nr</annotation></semantics></math>
covariance matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>z</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>â„’</mi><mo>;</mo><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub><mo>,</mo><msub><mi>Î¸</mi><mi>z</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">C_z(\mathcal{L}; {\theta_{\text{sp}}}, \theta_z)</annotation></semantics></math>.</p>
<p>This model is implemented by the function <code><a href="../reference/stvcGLMexact.html">stvcGLMexact()</a></code>
under fixed hyperparameters, and <code><a href="../reference/stvcGLMstack.html">stvcGLMstack()</a></code> when using
predictive stacking. We also implement different specifications for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mi>z</mi></msub><annotation encoding="application/x-tex">C_z</annotation></semantics></math>
in this package as follows.</p>
<ol style="list-style-type: decimal">
<li><p><strong>Independent spatial-temporal process</strong>: We
consider
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>r</mi><annotation encoding="application/x-tex">r</annotation></semantics></math>
Gaussian spatial-temporal processes
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mrow><mtext mathvariant="normal">Independent processes: </mtext><mspace width="0.333em"></mspace></mrow><msub><mi>z</mi><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mo>â„“</mo><mo stretchy="true" form="postfix">)</mo></mrow><mo>âˆ£</mo><msubsup><mi>Ïƒ</mi><msub><mi>z</mi><mi>j</mi></msub><mn>2</mn></msubsup><mo>,</mo><msub><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub><mi>j</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mover><mo>âˆ¼</mo><mtext mathvariant="normal">ind</mtext></mover><mrow><mi>ğ–¦</mi><mi>ğ–¯</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msubsup><mi>Ïƒ</mi><msub><mi>z</mi><mi>j</mi></msub><mn>2</mn></msubsup><msub><mi>R</mi><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mo>â‹…</mo><mo>,</mo><mo>â‹…</mo><mo>;</mo><msub><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msubsup><mi>Ïƒ</mi><msub><mi>z</mi><mi>j</mi></msub><mn>2</mn></msubsup></mtd><mtd columnalign="left" style="text-align: left"><mo>âˆ¼</mo><mrow><mi>ğ–¨</mi><mi>ğ–¦</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Î½</mi><msub><mi>z</mi><mi>j</mi></msub></msub><mi>/</mi><mn>2</mn><mo>,</mo><msub><mi>Î½</mi><msub><mi>z</mi><mi>j</mi></msub></msub><mi>/</mi><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="1.0em"></mspace><mi>j</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>â€¦</mi><mo>,</mo><mi>r</mi><mo>,</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{equation}\label{eq:z_ind}
\begin{split}
 \text{Independent processes: } z_j(\ell) \mid\sigma_{z_j}^2, {\theta_{\text{sp}}}_j &amp; \overset{\text{ind}}{\sim} \mathsf{GP}(0, \sigma_{z_j}^2 R_j(\cdot, \cdot; {\theta_{\text{sp}}}_j)),\\
 \sigma_{z_j}^2 &amp; \sim \mathsf{IG}(\nu_{z_j}/2, \nu_{z_j}/2), \quad j = 1, \ldots, r,
\end{split}
\end{equation}</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>Ïƒ</mi><msub><mi>z</mi><mi>j</mi></msub><mn>2</mn></msubsup><annotation encoding="application/x-tex">\sigma_{z_j}^2</annotation></semantics></math>
is the variance parameter corresponding to process
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mo>â„“</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">z_j(\ell)</annotation></semantics></math>.
This corresponds to the covariance matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>z</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>â„’</mi><mo>;</mo><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub><mo>,</mo><msub><mi>Î¸</mi><mi>z</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msubsup><mo>âŠ•</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>r</mi></msubsup><msubsup><mi>Ïƒ</mi><msub><mi>z</mi><mi>j</mi></msub><mn>2</mn></msubsup><msub><mi>R</mi><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">C_z(\mathcal{L}; {\theta_{\text{sp}}}, \theta_z) = \oplus_{j = 1}^r \sigma_{z_j}^2 R_j({\theta_{\text{sp}}}_j)</annotation></semantics></math>
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msub><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub><mi>j</mi></msub><mo>:</mo><mi>j</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>â€¦</mi><mo>,</mo><mi>r</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">{\theta_{\text{sp}}}= \{ {\theta_{\text{sp}}}_j : j = 1, \ldots, r\}</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub><mi>j</mi></msub><annotation encoding="application/x-tex">{\theta_{\text{sp}}}_j</annotation></semantics></math>
denotes covariance kernel parameters for the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>th
process, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Î¸</mi><mi>z</mi></msub><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msubsup><mi>Ïƒ</mi><msub><mi>z</mi><mn>1</mn></msub><mn>2</mn></msubsup><mo>,</mo><mi>â€¦</mi><mo>,</mo><msubsup><mi>Ïƒ</mi><msub><mi>z</mi><mi>r</mi></msub><mn>2</mn></msubsup><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\theta_z = \{\sigma^2_{z_1}, \ldots, \sigma^2_{z_r}\}</annotation></semantics></math>.
This is accessed by setting the option
<code>process.type = "independent"</code> in the above
functions.</p></li>
<li><p><strong>Independent shared spatial-temporal process</strong>:
This corresponds to the above with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub><mi>j</mi></msub><mo>=</mo><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub></mrow><annotation encoding="application/x-tex">{\theta_{\text{sp}}}_j = {\theta_{\text{sp}}}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>Ïƒ</mi><mrow><mi>z</mi><mi>j</mi></mrow><mn>2</mn></msubsup><mo>=</mo><msubsup><mi>Ïƒ</mi><mi>z</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\sigma^2_{zj} = \sigma^2_z</annotation></semantics></math>
for all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>â€¦</mi><mo>,</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">j = 1, \ldots, r</annotation></semantics></math>.
This is accessed by setting the option
<code>process.type = "independent.shared"</code> in the above
functions.</p></li>
<li><p><strong>Multivariate spatial-temporal process</strong>: We can
introduce dependence among the elements of the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>Ã—</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r\times 1</annotation></semantics></math>
vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>â„“</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">z(\ell)</annotation></semantics></math>
using
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mtext mathvariant="normal">Multivariate process: </mtext><mspace width="0.333em"></mspace></mrow><mi>z</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>â„“</mo><mo stretchy="true" form="postfix">)</mo></mrow><mo>âˆ£</mo><mi>Î£</mi><mo>âˆ¼</mo><mrow><mi>ğ–¦</mi><mi>ğ–¯</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mi>R</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>â‹…</mo><mo>,</mo><mo>â‹…</mo><mo>;</mo><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>Î£</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="1.0em"></mspace><mi>Î£</mi><mo>âˆ¼</mo><mrow><mi>ğ–¨</mi><mi>ğ–¶</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Î½</mi><mi>z</mi></msub><mo>+</mo><mn>2</mn><mi>r</mi><mo>,</mo><mi>Î¨</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.278em"></mspace><mo>,</mo></mrow><annotation encoding="application/x-tex">\begin{equation}\label{eq:multi_z}
 \text{Multivariate process: }z(\ell) \mid\Sigma \sim \mathsf{GP}(0, R(\cdot, \cdot; {\theta_{\text{sp}}})\Sigma), \quad \Sigma \sim \mathsf{IW}(\nu_z + 2r, \Psi)\;,
\end{equation}</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>ğ’¢</mi><mi>ğ’«</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mi>R</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>â‹…</mo><mo>,</mo><mo>â‹…</mo><mo>;</mo><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>Î£</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{GP} (0, R(\cdot, \cdot; {\theta_{\text{sp}}})\Sigma)</annotation></semantics></math>
is an
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>Ã—</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r\times 1</annotation></semantics></math>
multivariate Gaussian process with matrix-valued cross-covariance
function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>â‹…</mo><mo>,</mo><mo>â‹…</mo><mo>;</mo><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>Î£</mi></mrow><annotation encoding="application/x-tex">R(\cdot, \cdot; {\theta_{\text{sp}}})\Sigma</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Î£</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>
is an
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>Ã—</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">r \times r</annotation></semantics></math>
positive definite random matrix. This corresponds to the
spatial-temporal covariance matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>z</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>â„’</mi><mo>;</mo><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub><mo>,</mo><msub><mi>Î¸</mi><mi>z</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>Î£</mi><mo>âŠ—</mo><mi>R</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">C_z(\mathcal{L}; {\theta_{\text{sp}}}, \theta_z) = \Sigma \otimes R({\theta_{\text{sp}}})</annotation></semantics></math>
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Î¸</mi><mi>z</mi></msub><mo>=</mo><mi>Î£</mi></mrow><annotation encoding="application/x-tex">\theta_z = \Sigma</annotation></semantics></math>.
We place an inverse-Wishart prior on the scale parameter with shape
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Î½</mi><mi>z</mi></msub><mo>+</mo><mn>2</mn><mi>r</mi></mrow><annotation encoding="application/x-tex">\nu_z + 2r</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>Ã—</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">r\times r</annotation></semantics></math>
positive definite scale matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Î¨</mi><annotation encoding="application/x-tex">\Psi</annotation></semantics></math>,
given by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Ï€</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Î¸</mi><mi>z</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mi>ğ–¨</mi><mi>ğ–¶</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>Î£</mi><mo>âˆ£</mo><msub><mi>Î½</mi><mi>z</mi></msub><mo>+</mo><mn>2</mn><mi>r</mi><mo>,</mo><mi>Î¨</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\pi(\theta_z) = \mathsf{IW}(\Sigma \mid\nu_z + 2r, \Psi)</annotation></semantics></math>.
This is accessed by setting the option
<code>process.type = "multivariate"</code> in the above
functions.</p></li>
</ol>
</div>
<div class="section level2">
<h2 id="predictive-stacking">Predictive stacking<a class="anchor" aria-label="anchor" href="#predictive-stacking"></a>
</h2>
<p>Following <span class="citation">Yao et al. (<a href="#ref-yao2018stacking">2018</a>)</span>, we consider a set of
candidate models based on a grid of values of the parameters in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub><mo>,</mo><msup><mi>Î´</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{ {\theta_{\text{sp}}}, \delta^2 \}</annotation></semantics></math>
for the Gaussian case, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msub><mi>Î¸</mi><mtext mathvariant="normal">sp</mtext></msub><mo>,</mo><mi>Ïµ</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{ {\theta_{\text{sp}}}, \epsilon \}</annotation></semantics></math>
for the non-Gaussian case, as will be supplied by the user. We build a
set of candidate models based on the Cartesian product of the collection
of values for each individual parameter as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>â„³</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>M</mi><mn>1</mn></msub><mo>,</mo><mi>â€¦</mi><mo>,</mo><msub><mi>M</mi><mi>G</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\mathcal{M} = \{M_1, \ldots, M_G\}</annotation></semantics></math>.
Then, for each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>â€¦</mi><mo>,</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">g = 1, \ldots, G</annotation></semantics></math>,
we sample from the posterior distribution
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>Ïƒ</mi><mn>2</mn></msup><mo>,</mo><mi>Î²</mi><mo>,</mo><mi>z</mi><mo>âˆ£</mo><mi>y</mi><mo>,</mo><msub><mi>M</mi><mi>g</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">p(\sigma^2, \beta, z \mid y, M_g)</annotation></semantics></math>
under the model
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mi>g</mi></msub><annotation encoding="application/x-tex">M_g</annotation></semantics></math>
and find leave-one-out predictive densities
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>âˆ£</mo><msub><mi>y</mi><mrow><mo>âˆ’</mo><mi>i</mi></mrow></msub><mo>,</mo><msub><mi>M</mi><mi>g</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">p(y_i \mid y_{-i}, M_g)</annotation></semantics></math>.
Then we solve the optimization problem
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><munder><mo>max</mo><mrow><msub><mi>w</mi><mn>1</mn></msub><mo>,</mo><mi>â€¦</mi><mo>,</mo><msub><mi>w</mi><mi>G</mi></msub></mrow></munder></mtd><mtd columnalign="left" style="text-align: left"><mspace width="0.167em"></mspace><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>âˆ‘</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo>log</mo><munderover><mo>âˆ‘</mo><mrow><mi>g</mi><mo>=</mo><mn>1</mn></mrow><mi>G</mi></munderover><msub><mi>w</mi><mi>g</mi></msub><mi>p</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>âˆ£</mo><msub><mi>y</mi><mrow><mo>âˆ’</mo><mi>i</mi></mrow></msub><mo>,</mo><msub><mi>M</mi><mi>g</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mtext mathvariant="normal">subject to</mtext></mtd><mtd columnalign="left" style="text-align: left"><mspace width="1.0em"></mspace><msub><mi>w</mi><mi>g</mi></msub><mo>â‰¥</mo><mn>0</mn><mo>,</mo><munderover><mo>âˆ‘</mo><mrow><mi>g</mi><mo>=</mo><mn>1</mn></mrow><mi>G</mi></munderover><msub><mi>w</mi><mi>g</mi></msub><mo>=</mo><mn>1</mn></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{equation}
\begin{split}
 \max_{w_1, \ldots, w_G}&amp; \, \frac{1}{n} \sum_{i = 1}^n \log \sum_{g = 1}^G
 w_g p(y_i \mid y_{-i}, M_g) \\
 \text{subject to} &amp; \quad w_g \geq 0, \sum_{g = 1}^G w_g = 1
\end{split}
\end{equation}</annotation></semantics></math> to find the optimal
stacking weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>w</mi><mo accent="true">Ì‚</mo></mover><mn>1</mn></msub><mo>,</mo><mi>â€¦</mi><mo>,</mo><msub><mover><mi>w</mi><mo accent="true">Ì‚</mo></mover><mi>G</mi></msub></mrow><annotation encoding="application/x-tex">\hat{w}_1, \ldots, \hat{w}_G</annotation></semantics></math>.
After obtaining the optimal stacking weights, posterior inference of any
quantity of interest subsequently proceed from the <em>stacked</em>
posterior,
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>p</mi><mo accent="true">Ìƒ</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mo>â‹…</mo><mo>âˆ£</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><munderover><mo>âˆ‘</mo><mrow><mi>g</mi><mo>=</mo><mn>1</mn></mrow><mi>G</mi></munderover><msub><mover><mi>w</mi><mo accent="true">Ì‚</mo></mover><mi>g</mi></msub><mi>p</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>â‹…</mo><mo>âˆ£</mo><mi>y</mi><mo>,</mo><msub><mi>M</mi><mi>g</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation}
\tilde{p}(\cdot \mid y) = \sum_{g = 1}^G \hat{w}_g p(\cdot \mid y, M_g).
\end{equation}</annotation></semantics></math></p>
</div>
<div class="section level2 unnumbered">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-banerjee_massivespatial" class="csl-entry">
Banerjee, Sudipto. 2020. <span>â€œModeling Massive Spatial Datasets Using
a Conjugate <span>B</span>ayesian Linear Modeling Framework.â€</span>
<em>Spatial Statistics</em> 37: 100417. <a href="https://doi.org/10.1016/j.spasta.2020.100417" class="external-link">https://doi.org/10.1016/j.spasta.2020.100417</a>.
</div>
<div id="ref-bradleyclinch2024" class="csl-entry">
Bradley, Jonathan R., and Madelyn Clinch. 2024. <span>â€œGenerating
Independent Replicates Directly from the Posterior Distribution for a
Class of Spatial Hierarchical Models.â€</span> <em>Journal of
Computational and Graphical Statistics</em> 0 (0): 1â€“17. <a href="https://doi.org/10.1080/10618600.2024.2365728" class="external-link">https://doi.org/10.1080/10618600.2024.2365728</a>.
</div>
<div id="ref-pan2024stacking" class="csl-entry">
Pan, Soumyakanti, Lu Zhang, Jonathan R. Bradley, and Sudipto Banerjee.
2025. <span>â€œBayesian Inference for Spatial-Temporal Non-Gaussian Data
Using Predictive Stacking.â€</span> <a href="https://doi.org/10.48550/arXiv.2406.04655" class="external-link">https://doi.org/10.48550/arXiv.2406.04655</a>.
</div>
<div id="ref-yao2018stacking" class="csl-entry">
Yao, Yuling, Aki Vehtari, Daniel Simpson, and Andrew Gelman. 2018.
<span>â€œ<span class="nocase">Using Stacking to Average
<span>B</span>ayesian Predictive Distributions (with
Discussion)</span>.â€</span> <em>Bayesian Analysis</em> 13 (3): 917â€“1007.
<a href="https://doi.org/10.1214/17-BA1091" class="external-link">https://doi.org/10.1214/17-BA1091</a>.
</div>
<div id="ref-zhang2024stacking" class="csl-entry">
Zhang, Lu, Wenpin Tang, and Sudipto Banerjee. 2025. <span>â€œBayesian
Geostatistics Using Predictive Stacking.â€</span> <em>Journal of the
American Statistical Association</em>. <a href="https://doi.org/10.1080/01621459.2025.2566449" class="external-link">https://doi.org/10.1080/01621459.2025.2566449</a>.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Soumyakanti Pan, Sudipto Banerjee.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer>
</div>





  </body>
</html>
